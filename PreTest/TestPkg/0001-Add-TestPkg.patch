From 1660c9c181e523b0169bd4101df6d9eb346f4b16 Mon Sep 17 00:00:00 2001
From: "Feng, Bob C" <bob.c.feng@intel.com>
Date: Wed, 25 Nov 2020 23:22:15 +0800
Subject: [Patch] Add TestPkg

Signed-off-by: Feng, Bob C <bob.c.feng@intel.com>
---
 CryptoPkg/Library/OpensslLib/openssl          |    2 +-
 TestPkg/AcpiTables/AcpiTables.inf             |   40 +
 TestPkg/AcpiTables/Dsdt.asl                   |  692 ++++++++++
 TestPkg/AcpiTables/Facp.aslc                  |   89 ++
 TestPkg/AcpiTables/Facs.aslc                  |   78 ++
 TestPkg/AcpiTables/ForAddTest.asi             |   33 +
 TestPkg/AcpiTables/ForAddTest.asl             |  704 ++++++++++
 TestPkg/AcpiTables/ForAddTest.h               |   11 +
 TestPkg/AcpiTables/ForHIncludedH.h            |   10 +
 TestPkg/AcpiTables/Madt.aslc                  |  153 +++
 TestPkg/AcpiTables/Platform.h                 |   69 +
 TestPkg/AcpiTables/Ssdt.asl                   |   13 +
 TestPkg/AcpiTables/TestPlatform.asl           |   10 +
 TestPkg/AcpiTables/test.asi                   |   32 +
 TestPkg/FakeBinary/FakeBinary.inf             |   29 +
 TestPkg/FakeBinary/FakeBinary.txt             |    1 +
 TestPkg/FakeBinary/FakeBinary.uni             |   16 +
 TestPkg/FakeEmuSec/Ia32/FakeTest.h            |   10 +
 TestPkg/FakeEmuSec/Ia32/FakeTest.i            |   10 +
 TestPkg/FakeEmuSec/Ia32/FakeTest.inc          |   14 +
 TestPkg/FakeEmuSec/Ia32/ForAddTest.asm        |   20 +
 TestPkg/FakeEmuSec/Ia32/SwitchRam.S           |   89 ++
 TestPkg/FakeEmuSec/Ia32/SwitchRam.asm         |   88 ++
 TestPkg/FakeEmuSec/Ia32/TempRam.c             |   59 +
 TestPkg/FakeEmuSec/Ia32/Test.asm              |   18 +
 TestPkg/FakeEmuSec/Ia32/Test_inf.h            |   10 +
 TestPkg/FakeEmuSec/Sec.c                      |  140 ++
 TestPkg/FakeEmuSec/Sec.h                      |   45 +
 TestPkg/FakeEmuSec/Sec.inf                    |   52 +
 TestPkg/FakeEmuSec/X64/SwitchRam.S            |   66 +
 TestPkg/FakeEmuSec/X64/SwitchRam.asm          |   70 +
 TestPkg/FakeEmuSec/X64/Test_Inf.h             |   11 +
 TestPkg/FakeLogo/HaveATest.jpg                |  Bin 0 -> 31331 bytes
 TestPkg/FakeLogo/JpegLogo.idf                 |   10 +
 TestPkg/FakeLogo/JpegLogoDxe.inf              |   53 +
 TestPkg/FakeLogo/Logo.c                       |  153 +++
 TestPkg/FakeLogo/Logo.jpg                     |  Bin 0 -> 11944 bytes
 TestPkg/FakeTimeStamp.txt                     |    1 +
 TestPkg/FvmainCompactScratchEnd.fdf.inc       |   65 +
 TestPkg/Library/AcpiTimerLib/AcpiTimerLib.c   |  210 +++
 TestPkg/Library/AcpiTimerLib/AcpiTimerLib.h   |   23 +
 .../Library/AcpiTimerLib/BaseAcpiTimerLib.c   |  103 ++
 .../Library/AcpiTimerLib/BaseAcpiTimerLib.inf |   32 +
 .../AcpiTimerLib/BaseAcpiTimerLibBhyve.c      |   32 +
 .../AcpiTimerLib/BaseAcpiTimerLibBhyve.inf    |   30 +
 .../AcpiTimerLib/BaseRomAcpiTimerLib.c        |  121 ++
 .../AcpiTimerLib/BaseRomAcpiTimerLib.inf      |   31 +
 .../Library/AcpiTimerLib/DxeAcpiTimerLib.c    |   83 ++
 .../Library/AcpiTimerLib/DxeAcpiTimerLib.inf  |   35 +
 .../BaseFakeLibraryLib/BaseFakeLibraryLib.c   |  152 ++
 .../BaseFakeLibraryLib/BaseFakeLibraryLib.inf |   50 +
 .../BaseFakeLibraryLib/BaseFakeLibraryLib.uni |   20 +
 TestPkg/Library/BaseFakeLibraryLib/Extra.uni  |   26 +
 .../BaseFakeLibraryLib/UniIncluded.uni        |   21 +
 .../DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf |   40 +
 TestPkg/Library/DxePciLibI440FxQ35/PciLib.c   | 1223 +++++++++++++++++
 TestPkg/Library/NvVarsFileLib/FsAccess.c      |  508 +++++++
 TestPkg/Library/NvVarsFileLib/NvVarsFileLib.c |   77 ++
 TestPkg/Library/NvVarsFileLib/NvVarsFileLib.h |   55 +
 .../Library/NvVarsFileLib/NvVarsFileLib.inf   |   56 +
 .../DebugIoPortNocheck.c                      |   25 +
 .../PlatformDebugLibIoPort/DebugIoPortQemu.c  |   34 +
 .../Library/PlatformDebugLibIoPort/DebugLib.c |  361 +++++
 .../PlatformDebugLibIoPort/DebugLibDetect.c   |   65 +
 .../PlatformDebugLibIoPort/DebugLibDetect.h   |   45 +
 .../DebugLibDetectRom.c                       |   42 +
 .../PlatformDebugLibIoPort.inf                |   49 +
 .../PlatformRomDebugLibIoPort.inf             |   49 +
 .../PlatformRomDebugLibIoPortNocheck.inf      |   48 +
 .../ResetSystemLib/BaseResetShutdown.c        |   51 +
 .../ResetSystemLib/BaseResetShutdownBhyve.c   |   34 +
 .../ResetSystemLib/BaseResetSystemLib.inf     |   38 +
 .../BaseResetSystemLibBhyve.inf               |   40 +
 .../Library/ResetSystemLib/DxeResetShutdown.c |   62 +
 .../ResetSystemLib/DxeResetSystemLib.inf      |   43 +
 .../Library/ResetSystemLib/ResetSystemLib.c   |  120 ++
 TestPkg/LibraryClass.dsc                      |  204 +++
 TestPkg/License.txt                           |   79 ++
 TestPkg/NetworkLibs.dsc                       |  210 +++
 TestPkg/OvmfPkg.ci.yaml                       |   83 ++
 TestPkg/PcdSettings.dsc                       |  185 +++
 TestPkg/PlatformBuild.py                      |  156 +++
 TestPkg/PlatformDxe/FirstTestFile.h           |    9 +
 TestPkg/PlatformDxe/ForAddTest.hfr            |   16 +
 TestPkg/PlatformDxe/JustATest.uni             |  Bin 0 -> 904 bytes
 TestPkg/PlatformDxe/Platform.c                |  869 ++++++++++++
 TestPkg/PlatformDxe/Platform.h                |   37 +
 TestPkg/PlatformDxe/Platform.inf              |   64 +
 TestPkg/PlatformDxe/Platform.uni              |   28 +
 TestPkg/PlatformDxe/PlatformConfig.c          |  125 ++
 TestPkg/PlatformDxe/PlatformConfig.h          |   53 +
 TestPkg/PlatformDxe/PlatformForms.vfr         |   67 +
 TestPkg/PlatformDxe/SecondTestFile.h          |    9 +
 TestPkg/PlatformDxe/ThirdTestFile.uni         |  Bin 0 -> 950 bytes
 TestPkg/README                                |    0
 TestPkg/ResetVector/Ia32/PageTables64.asm     |  148 ++
 TestPkg/ResetVector/ResetVector.inf           |   37 +
 TestPkg/ResetVector/ResetVector.nasmb         |   67 +
 TestPkg/Sec/Ia32/ForHAddTest.h                |    9 +
 TestPkg/Sec/Ia32/ForHAddTest.inc              |    9 +
 TestPkg/Sec/Ia32/ForNASMIncludeH.h            |   10 +
 TestPkg/Sec/Ia32/SecEntry.nasm                |   68 +
 TestPkg/Sec/SecMain.c                         |  941 +++++++++++++
 TestPkg/Sec/SecMain.inf                       |   73 +
 TestPkg/Sec/X64/SecEntry.nasm                 |   69 +
 TestPkg/TestIa32X64.fdf                       |  348 +++++
 TestPkg/TestPkg.dec                           |    0
 TestPkg/TestPkgDefines.fdf.inc                |   91 ++
 TestPkg/TestPkgIA32X64.dsc                    |  197 +++
 TestPkg/VarStore.fdf.inc                      |  115 ++
 TestPkg/buildoptions.dsc                      |   42 +
 TestPkg/iasl_ext_dep.yaml                     |   21 +
 TestPkg/modulelist.txt                        |   37 +
 113 files changed, 11475 insertions(+), 1 deletion(-)
 create mode 100644 TestPkg/AcpiTables/AcpiTables.inf
 create mode 100644 TestPkg/AcpiTables/Dsdt.asl
 create mode 100644 TestPkg/AcpiTables/Facp.aslc
 create mode 100644 TestPkg/AcpiTables/Facs.aslc
 create mode 100644 TestPkg/AcpiTables/ForAddTest.asi
 create mode 100644 TestPkg/AcpiTables/ForAddTest.asl
 create mode 100644 TestPkg/AcpiTables/ForAddTest.h
 create mode 100644 TestPkg/AcpiTables/ForHIncludedH.h
 create mode 100644 TestPkg/AcpiTables/Madt.aslc
 create mode 100644 TestPkg/AcpiTables/Platform.h
 create mode 100644 TestPkg/AcpiTables/Ssdt.asl
 create mode 100644 TestPkg/AcpiTables/TestPlatform.asl
 create mode 100644 TestPkg/AcpiTables/test.asi
 create mode 100644 TestPkg/FakeBinary/FakeBinary.inf
 create mode 100644 TestPkg/FakeBinary/FakeBinary.txt
 create mode 100644 TestPkg/FakeBinary/FakeBinary.uni
 create mode 100644 TestPkg/FakeEmuSec/Ia32/FakeTest.h
 create mode 100644 TestPkg/FakeEmuSec/Ia32/FakeTest.i
 create mode 100644 TestPkg/FakeEmuSec/Ia32/FakeTest.inc
 create mode 100644 TestPkg/FakeEmuSec/Ia32/ForAddTest.asm
 create mode 100644 TestPkg/FakeEmuSec/Ia32/SwitchRam.S
 create mode 100644 TestPkg/FakeEmuSec/Ia32/SwitchRam.asm
 create mode 100644 TestPkg/FakeEmuSec/Ia32/TempRam.c
 create mode 100644 TestPkg/FakeEmuSec/Ia32/Test.asm
 create mode 100644 TestPkg/FakeEmuSec/Ia32/Test_inf.h
 create mode 100644 TestPkg/FakeEmuSec/Sec.c
 create mode 100644 TestPkg/FakeEmuSec/Sec.h
 create mode 100644 TestPkg/FakeEmuSec/Sec.inf
 create mode 100644 TestPkg/FakeEmuSec/X64/SwitchRam.S
 create mode 100644 TestPkg/FakeEmuSec/X64/SwitchRam.asm
 create mode 100644 TestPkg/FakeEmuSec/X64/Test_Inf.h
 create mode 100644 TestPkg/FakeLogo/HaveATest.jpg
 create mode 100644 TestPkg/FakeLogo/JpegLogo.idf
 create mode 100644 TestPkg/FakeLogo/JpegLogoDxe.inf
 create mode 100644 TestPkg/FakeLogo/Logo.c
 create mode 100644 TestPkg/FakeLogo/Logo.jpg
 create mode 100644 TestPkg/FakeTimeStamp.txt
 create mode 100644 TestPkg/FvmainCompactScratchEnd.fdf.inc
 create mode 100644 TestPkg/Library/AcpiTimerLib/AcpiTimerLib.c
 create mode 100644 TestPkg/Library/AcpiTimerLib/AcpiTimerLib.h
 create mode 100644 TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLib.c
 create mode 100644 TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLib.inf
 create mode 100644 TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLibBhyve.c
 create mode 100644 TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLibBhyve.inf
 create mode 100644 TestPkg/Library/AcpiTimerLib/BaseRomAcpiTimerLib.c
 create mode 100644 TestPkg/Library/AcpiTimerLib/BaseRomAcpiTimerLib.inf
 create mode 100644 TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.c
 create mode 100644 TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.inf
 create mode 100644 TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.c
 create mode 100644 TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.inf
 create mode 100644 TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.uni
 create mode 100644 TestPkg/Library/BaseFakeLibraryLib/Extra.uni
 create mode 100644 TestPkg/Library/BaseFakeLibraryLib/UniIncluded.uni
 create mode 100644 TestPkg/Library/DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf
 create mode 100644 TestPkg/Library/DxePciLibI440FxQ35/PciLib.c
 create mode 100644 TestPkg/Library/NvVarsFileLib/FsAccess.c
 create mode 100644 TestPkg/Library/NvVarsFileLib/NvVarsFileLib.c
 create mode 100644 TestPkg/Library/NvVarsFileLib/NvVarsFileLib.h
 create mode 100644 TestPkg/Library/NvVarsFileLib/NvVarsFileLib.inf
 create mode 100644 TestPkg/Library/PlatformDebugLibIoPort/DebugIoPortNocheck.c
 create mode 100644 TestPkg/Library/PlatformDebugLibIoPort/DebugIoPortQemu.c
 create mode 100644 TestPkg/Library/PlatformDebugLibIoPort/DebugLib.c
 create mode 100644 TestPkg/Library/PlatformDebugLibIoPort/DebugLibDetect.c
 create mode 100644 TestPkg/Library/PlatformDebugLibIoPort/DebugLibDetect.h
 create mode 100644 TestPkg/Library/PlatformDebugLibIoPort/DebugLibDetectRom.c
 create mode 100644 TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
 create mode 100644 TestPkg/Library/PlatformDebugLibIoPort/PlatformRomDebugLibIoPort.inf
 create mode 100644 TestPkg/Library/PlatformDebugLibIoPort/PlatformRomDebugLibIoPortNocheck.inf
 create mode 100644 TestPkg/Library/ResetSystemLib/BaseResetShutdown.c
 create mode 100644 TestPkg/Library/ResetSystemLib/BaseResetShutdownBhyve.c
 create mode 100644 TestPkg/Library/ResetSystemLib/BaseResetSystemLib.inf
 create mode 100644 TestPkg/Library/ResetSystemLib/BaseResetSystemLibBhyve.inf
 create mode 100644 TestPkg/Library/ResetSystemLib/DxeResetShutdown.c
 create mode 100644 TestPkg/Library/ResetSystemLib/DxeResetSystemLib.inf
 create mode 100644 TestPkg/Library/ResetSystemLib/ResetSystemLib.c
 create mode 100644 TestPkg/LibraryClass.dsc
 create mode 100644 TestPkg/License.txt
 create mode 100644 TestPkg/NetworkLibs.dsc
 create mode 100644 TestPkg/OvmfPkg.ci.yaml
 create mode 100644 TestPkg/PcdSettings.dsc
 create mode 100644 TestPkg/PlatformBuild.py
 create mode 100644 TestPkg/PlatformDxe/FirstTestFile.h
 create mode 100644 TestPkg/PlatformDxe/ForAddTest.hfr
 create mode 100644 TestPkg/PlatformDxe/JustATest.uni
 create mode 100644 TestPkg/PlatformDxe/Platform.c
 create mode 100644 TestPkg/PlatformDxe/Platform.h
 create mode 100644 TestPkg/PlatformDxe/Platform.inf
 create mode 100644 TestPkg/PlatformDxe/Platform.uni
 create mode 100644 TestPkg/PlatformDxe/PlatformConfig.c
 create mode 100644 TestPkg/PlatformDxe/PlatformConfig.h
 create mode 100644 TestPkg/PlatformDxe/PlatformForms.vfr
 create mode 100644 TestPkg/PlatformDxe/SecondTestFile.h
 create mode 100644 TestPkg/PlatformDxe/ThirdTestFile.uni
 create mode 100644 TestPkg/README
 create mode 100644 TestPkg/ResetVector/Ia32/PageTables64.asm
 create mode 100644 TestPkg/ResetVector/ResetVector.inf
 create mode 100644 TestPkg/ResetVector/ResetVector.nasmb
 create mode 100644 TestPkg/Sec/Ia32/ForHAddTest.h
 create mode 100644 TestPkg/Sec/Ia32/ForHAddTest.inc
 create mode 100644 TestPkg/Sec/Ia32/ForNASMIncludeH.h
 create mode 100644 TestPkg/Sec/Ia32/SecEntry.nasm
 create mode 100644 TestPkg/Sec/SecMain.c
 create mode 100644 TestPkg/Sec/SecMain.inf
 create mode 100644 TestPkg/Sec/X64/SecEntry.nasm
 create mode 100644 TestPkg/TestIa32X64.fdf
 create mode 100644 TestPkg/TestPkg.dec
 create mode 100644 TestPkg/TestPkgDefines.fdf.inc
 create mode 100644 TestPkg/TestPkgIA32X64.dsc
 create mode 100644 TestPkg/VarStore.fdf.inc
 create mode 100644 TestPkg/buildoptions.dsc
 create mode 100644 TestPkg/iasl_ext_dep.yaml
 create mode 100644 TestPkg/modulelist.txt

diff --git a/CryptoPkg/Library/OpensslLib/openssl b/CryptoPkg/Library/OpensslLib/openssl
index e2e09d9fba..c3656cc594 160000
--- a/CryptoPkg/Library/OpensslLib/openssl
+++ b/CryptoPkg/Library/OpensslLib/openssl
@@ -1 +1 @@
-Subproject commit e2e09d9fba1187f8d6aafaa34d4172f56f1ffb72
+Subproject commit c3656cc594daac8167721dde7220f0e59ae146fc
diff --git a/TestPkg/AcpiTables/AcpiTables.inf b/TestPkg/AcpiTables/AcpiTables.inf
new file mode 100644
index 0000000000..ec5d9ec9f9
--- /dev/null
+++ b/TestPkg/AcpiTables/AcpiTables.inf
@@ -0,0 +1,40 @@
+## @file
+#  Component description file for PlatformAcpiTables module.
+#
+#  ACPI table data and ASL sources required to boot the platform.
+#
+#  Copyright (c) 2008 - 2018, Intel Corporation. All rights reserved.<BR>
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformAcpiTables
+  FILE_GUID                      = 7E374E25-8E01-4FEE-87F2-390C23C606CD
+  MODULE_TYPE                    = USER_DEFINED
+  VERSION_STRING                 = 1.0
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 EBC
+#
+
+[Sources]
+  Platform.h
+  TestPlatform.asl
+  Madt.aslc
+  Facp.aslc
+  Facs.aslc
+  Dsdt.asl
+  Ssdt.asl
+  test.asi
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[Pcd]
+  gUefiOvmfPkgTokenSpaceGuid.PcdDebugIoPort
+
diff --git a/TestPkg/AcpiTables/Dsdt.asl b/TestPkg/AcpiTables/Dsdt.asl
new file mode 100644
index 0000000000..383d72af54
--- /dev/null
+++ b/TestPkg/AcpiTables/Dsdt.asl
@@ -0,0 +1,692 @@
+/** @file
+  Contains root level name space objects for the platform
+
+  Copyright (c) 2008, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+#include "Platform.h"
+#include "test.asi"
+DefinitionBlock ("Dsdt.aml", "DSDT", 1, "INTEL ", "OVMF    ", 4) {
+  //
+  // System Sleep States
+  //
+  // We build S3 and S4 with GetSuspendStates() in
+  // "OvmfPkg/AcpiPlatformDxe/Qemu.c".
+  //
+  Name (\_S0, Package () {5, 0, 0, 0}) // Working
+  Name (\_S5, Package () {0, 0, 0, 0}) // Soft Off
+  //
+  //  System Bus
+  //
+  Scope (\_SB) {
+    //
+    // PCI Root Bridge
+    //
+    Device (PCI0) {
+      Name (_HID, EISAID ("PNP0A03"))
+      Name (_ADR, 0x00000000)
+      Name (_BBN, 0x00)
+      Name (_UID, 0x00)
+
+      //
+      // BUS, I/O, and MMIO resources
+      //
+      Name (CRES, ResourceTemplate () {
+        WORDBusNumber (          // Bus number resource (0); the bridge produces bus numbers for its subsequent buses
+          ResourceProducer,      // bit 0 of general flags is 1
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is fixed
+          PosDecode,             // PosDecode
+          0x0000,                // Granularity
+          0x0000,                // Min
+          0x00FF,                // Max
+          0x0000,                // Translation
+          0x0100                 // Range Length = Max-Min+1
+          )
+
+        IO (Decode16, 0xCF8, 0xCF8, 0x01, 0x08)       //Consumed resource (0xCF8-0xCFF)
+
+        WORDIO (                 // Consumed-and-produced resource (all I/O below CF8)
+          ResourceProducer,      // bit 0 of general flags is 0
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is fixed
+          PosDecode,
+          EntireRange,
+          0x0000,                // Granularity
+          0x0000,                // Min
+          0x0CF7,                // Max
+          0x0000,                // Translation
+          0x0CF8                 // Range Length
+          )
+
+        WORDIO (                 // Consumed-and-produced resource (all I/O above CFF)
+          ResourceProducer,      // bit 0 of general flags is 0
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is fixed
+          PosDecode,
+          EntireRange,
+          0x0000,                // Granularity
+          0x0D00,                // Min
+          0xFFFF,                // Max
+          0x0000,                // Translation
+          0xF300                 // Range Length
+          )
+
+        DWORDMEMORY (            // Descriptor for legacy VGA video RAM
+          ResourceProducer,      // bit 0 of general flags is 0
+          PosDecode,
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is Fixed
+          Cacheable,
+          ReadWrite,
+          0x00000000,            // Granularity
+          0x000A0000,            // Min
+          MAX_DWORDMEMORY,       // Max
+          0x00000000,            // Translation
+          0x00020000             // Range Length
+          )
+
+        DWORDMEMORY (            // Descriptor for 32-bit MMIO
+          ResourceProducer,      // bit 0 of general flags is 0
+          PosDecode,
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is Fixed
+          NonCacheable,
+          ReadWrite,
+          0x00000000,            // Granularity
+          0xF8000000,            // Min
+          0xFFFBFFFF,            // Max
+          0x00000000,            // Translation
+          0x07FC0000,            // Range Length
+          ,                      // ResourceSourceIndex
+          ,                      // ResourceSource
+          PW32                   // DescriptorName
+          )
+      })
+
+      Name (CR64, ResourceTemplate () {
+        QWordMemory (            // Descriptor for 64-bit MMIO
+            ResourceProducer,    // bit 0 of general flags is 0
+            PosDecode,
+            MinFixed,            // Range is fixed
+            MaxFixed,            // Range is Fixed
+            Cacheable,
+            ReadWrite,
+            0x00000000,          // Granularity
+            0x8000000000,        // Min
+            MAX_QWordMemory,     // Max
+            0x00000000,          // Translation
+            0x8000000000,        // Range Length
+            ,                    // ResourceSourceIndex
+            ,                    // ResourceSource
+            PW64                 // DescriptorName
+            )
+      })
+
+      Method (_CRS, 0, Serialized) {
+        //
+        // see the FIRMWARE_DATA structure in "OvmfPkg/AcpiPlatformDxe/Qemu.c"
+        //
+        External (FWDT, OpRegionObj)
+        Field(FWDT, QWordAcc, NoLock, Preserve) {
+          P0S, 64,               // PciWindow32.Base
+          P0E, 64,               // PciWindow32.End
+          P0L, 64,               // PciWindow32.Length
+          P1S, 64,               // PciWindow64.Base
+          P1E, 64,               // PciWindow64.End
+          P1L, 64                // PciWindow64.Length
+        }
+        Field(FWDT, DWordAcc, NoLock, Preserve) {
+          P0SL, 32,              // PciWindow32.Base,   low  32 bits
+          P0SH, 32,              // PciWindow32.Base,   high 32 bits
+          P0EL, 32,              // PciWindow32.End,    low  32 bits
+          P0EH, 32,              // PciWindow32.End,    high 32 bits
+          P0LL, 32,              // PciWindow32.Length, low  32 bits
+          P0LH, 32,              // PciWindow32.Length, high 32 bits
+          P1SL, 32,              // PciWindow64.Base,   low  32 bits
+          P1SH, 32,              // PciWindow64.Base,   high 32 bits
+          P1EL, 32,              // PciWindow64.End,    low  32 bits
+          P1EH, 32,              // PciWindow64.End,    high 32 bits
+          P1LL, 32,              // PciWindow64.Length, low  32 bits
+          P1LH, 32               // PciWindow64.Length, high 32 bits
+        }
+
+        //
+        // fixup 32-bit PCI IO window
+        //
+        CreateDWordField (CRES, \_SB.PCI0.PW32._MIN, PS32)
+        CreateDWordField (CRES, \_SB.PCI0.PW32._MAX, PE32)
+        CreateDWordField (CRES, \_SB.PCI0.PW32._LEN, PL32)
+        Store (P0SL, PS32)
+        Store (P0EL, PE32)
+        Store (P0LL, PL32)
+
+        If (LAnd (LEqual (P1SL, 0x00), LEqual (P1SH, 0x00))) {
+          Return (CRES)
+        } Else {
+          //
+          // fixup 64-bit PCI IO window
+          //
+          CreateQWordField (CR64, \_SB.PCI0.PW64._MIN, PS64)
+          CreateQWordField (CR64, \_SB.PCI0.PW64._MAX, PE64)
+          CreateQWordField (CR64, \_SB.PCI0.PW64._LEN, PL64)
+          Store (P1S, PS64)
+          Store (P1E, PE64)
+          Store (P1L, PL64)
+
+          //
+          // add window and return result
+          //
+          ConcatenateResTemplate (CRES, CR64, Local0)
+          Return (Local0)
+        }
+      }
+
+      //
+      // PCI Interrupt Routing Table - PIC Mode Only
+      //
+      Method (_PRT, 0, NotSerialized) {
+        Return (
+          Package () {
+            //
+            // Bus 0; Devices 0 to 15
+            //
+            Package () {0x0000FFFF, 0x00, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0000FFFF, 0x01, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0000FFFF, 0x02, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0000FFFF, 0x03, \_SB.PCI0.LPC.LNKC, 0x00},
+
+            //
+            // Bus 0, Device 1, Pin 0 (INTA) is special; it corresponds to the
+            // internally generated SCI (System Control Interrupt), which is
+            // always routed to GSI 9. By setting the third (= Source) field to
+            // zero, we could use the fourth (= Source Index) field to hardwire
+            // the pin to GSI 9 directly.
+            //
+            // That way however, in accordance with the ACPI spec's description
+            // of SCI, the interrupt would be treated as "active low,
+            // shareable, level", and that doesn't match qemu.
+            //
+            // In QemuInstallAcpiMadtTable() [OvmfPkg/AcpiPlatformDxe/Qemu.c]
+            // we install an Interrupt Override Structure for the identity
+            // mapped IRQ#9 / GSI 9 (the corresponding bit being set in
+            // Pcd8259LegacyModeEdgeLevel), which describes the correct
+            // polarity (active high). As a consequence, some OS'en (eg. Linux)
+            // override the default (active low) polarity originating from the
+            // _PRT; others (eg. FreeBSD) don't. Therefore we need a separate
+            // link device just to specify a polarity that matches the MADT.
+            //
+            Package () {0x0001FFFF, 0x00, \_SB.PCI0.LPC.LNKS, 0x00},
+
+            Package () {0x0001FFFF, 0x01, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0001FFFF, 0x02, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0001FFFF, 0x03, \_SB.PCI0.LPC.LNKD, 0x00},
+
+            Package () {0x0002FFFF, 0x00, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0002FFFF, 0x01, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0002FFFF, 0x02, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0002FFFF, 0x03, \_SB.PCI0.LPC.LNKA, 0x00},
+
+            Package () {0x0003FFFF, 0x00, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0003FFFF, 0x01, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0003FFFF, 0x02, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0003FFFF, 0x03, \_SB.PCI0.LPC.LNKB, 0x00},
+
+            Package () {0x0004FFFF, 0x00, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0004FFFF, 0x01, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0004FFFF, 0x02, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0004FFFF, 0x03, \_SB.PCI0.LPC.LNKC, 0x00},
+
+            Package () {0x0005FFFF, 0x00, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0005FFFF, 0x01, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0005FFFF, 0x02, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0005FFFF, 0x03, \_SB.PCI0.LPC.LNKD, 0x00},
+
+            Package () {0x0006FFFF, 0x00, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0006FFFF, 0x01, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0006FFFF, 0x02, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0006FFFF, 0x03, \_SB.PCI0.LPC.LNKA, 0x00},
+
+            Package () {0x0007FFFF, 0x00, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0007FFFF, 0x01, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0007FFFF, 0x02, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0007FFFF, 0x03, \_SB.PCI0.LPC.LNKB, 0x00},
+
+            Package () {0x0008FFFF, 0x00, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0008FFFF, 0x01, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0008FFFF, 0x02, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0008FFFF, 0x03, \_SB.PCI0.LPC.LNKC, 0x00},
+
+            Package () {0x0009FFFF, 0x00, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0009FFFF, 0x01, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0009FFFF, 0x02, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0009FFFF, 0x03, \_SB.PCI0.LPC.LNKD, 0x00},
+
+            Package () {0x000AFFFF, 0x00, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x000AFFFF, 0x01, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000AFFFF, 0x02, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000AFFFF, 0x03, \_SB.PCI0.LPC.LNKA, 0x00},
+
+            Package () {0x000BFFFF, 0x00, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000BFFFF, 0x01, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000BFFFF, 0x02, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x000BFFFF, 0x03, \_SB.PCI0.LPC.LNKB, 0x00},
+
+            Package () {0x000CFFFF, 0x00, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000CFFFF, 0x01, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x000CFFFF, 0x02, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x000CFFFF, 0x03, \_SB.PCI0.LPC.LNKC, 0x00},
+
+            Package () {0x000DFFFF, 0x00, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x000DFFFF, 0x01, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x000DFFFF, 0x02, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000DFFFF, 0x03, \_SB.PCI0.LPC.LNKD, 0x00},
+
+            Package () {0x000EFFFF, 0x00, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x000EFFFF, 0x01, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000EFFFF, 0x02, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000EFFFF, 0x03, \_SB.PCI0.LPC.LNKA, 0x00},
+
+            Package () {0x000FFFFF, 0x00, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000FFFFF, 0x01, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000FFFFF, 0x02, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x000FFFFF, 0x03, \_SB.PCI0.LPC.LNKB, 0x00}
+          }
+        )
+      }
+
+      //
+      // PCI to ISA Bridge (Bus 0, Device 1, Function 0)
+      // "Low Pin Count"
+      //
+      Device (LPC) {
+        Name (_ADR, 0x00010000)
+
+        //
+        // The SCI cannot be rerouted or disabled with PIRQRC[A:D]; we only
+        // need this link device in order to specify the polarity.
+        //
+        Device (LNKS) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 0)
+
+          Name (_STA, 0xB) // 0x1: device present
+                           // 0x2: enabled and decoding resources
+                           // 0x8: functioning properly
+
+          Method (_SRS, 1, NotSerialized) { /* no-op */ }
+          Method (_DIS, 0, NotSerialized) { /* no-op */ }
+
+          Name (_PRS, ResourceTemplate () {
+            Interrupt (ResourceConsumer, Level, ActiveHigh, Shared) { 9 }
+            //
+            // list of IRQs occupied thus far: 9
+            //
+          })
+          Method (_CRS, 0, NotSerialized) { Return (_PRS) }
+        }
+
+        //
+        // PCI Interrupt Routing Configuration Registers, PIRQRC[A:D]
+        //
+        OperationRegion (PRR0, PCI_Config, 0x60, 0x04)
+        Field (PRR0, ANYACC, NOLOCK, PRESERVE) {
+          PIRA, 8,
+          PIRB, 8,
+          PIRC, 8,
+          PIRD, 8
+        }
+
+        //
+        // _STA method for LNKA, LNKB, LNKC, LNKD
+        // Arg0[in]: value of PIRA / PIRB / PIRC / PIRD
+        //
+        Method (PSTA, 1, NotSerialized) {
+          If (And (Arg0, 0x80)) { // disable-bit set?
+            Return (0x9)          // "device present" | "functioning properly"
+          } Else {
+            Return (0xB)          // same | "enabled and decoding resources"
+          }
+        }
+
+        //
+        // _CRS method for LNKA, LNKB, LNKC, LNKD
+        // Arg0[in]: value of PIRA / PIRB / PIRC / PIRD
+        //
+        Method (PCRS, 1, Serialized) {
+          //
+          // create temporary buffer with an Extended Interrupt Descriptor
+          // whose single vector defaults to zero
+          //
+          Name (BUF0, ResourceTemplate () {
+              Interrupt (ResourceConsumer, Level, ActiveHigh, Shared){0}
+            }
+          )
+
+          //
+          // define reference to first interrupt vector in buffer
+          //
+          CreateDWordField (BUF0, 0x05, IRQW)
+
+          //
+          // If the disable-bit is clear, overwrite the default zero vector
+          // with the value in Arg0 (ie. PIRQRC[A:D]). Reserved bits are read
+          // as 0.
+          //
+          If (LNot (And (Arg0, 0x80))) {
+            Store (Arg0, IRQW)
+          }
+          Return (BUF0)
+        }
+
+        //
+        // _PRS resource for LNKA, LNKB, LNKC, LNKD
+        //
+        Name (PPRS, ResourceTemplate () {
+          Interrupt (ResourceConsumer, Level, ActiveHigh, Shared) {5, 10, 11}
+          //
+          // list of IRQs occupied thus far: 9, 5, 10, 11
+          //
+        })
+
+        //
+        // PCI IRQ Link A
+        //
+        Device (LNKA) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 1)
+
+          Method (_STA, 0, NotSerialized) { Return (PSTA (PIRA)) }
+          Method (_DIS, 0, NotSerialized) {
+            Or (PIRA, 0x80, PIRA) // set disable-bit
+          }
+          Method (_CRS, 0, NotSerialized) { Return (PCRS (PIRA)) }
+          Method (_PRS, 0, NotSerialized) { Return (PPRS) }
+          Method (_SRS, 1, NotSerialized) {
+            CreateDWordField (Arg0, 0x05, IRQW)
+            Store (IRQW, PIRA)
+          }
+        }
+
+        //
+        // PCI IRQ Link B
+        //
+        Device (LNKB) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 2)
+
+          Method (_STA, 0, NotSerialized) { Return (PSTA (PIRB)) }
+          Method (_DIS, 0, NotSerialized) {
+            Or (PIRB, 0x80, PIRB) // set disable-bit
+          }
+          Method (_CRS, 0, NotSerialized) { Return (PCRS (PIRB)) }
+          Method (_PRS, 0, NotSerialized) { Return (PPRS) }
+          Method (_SRS, 1, NotSerialized) {
+            CreateDWordField (Arg0, 0x05, IRQW)
+            Store (IRQW, PIRB)
+          }
+        }
+
+        //
+        // PCI IRQ Link C
+        //
+        Device (LNKC) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 3)
+
+          Method (_STA, 0, NotSerialized) { Return (PSTA (PIRC)) }
+          Method (_DIS, 0, NotSerialized) {
+            Or (PIRC, 0x80, PIRC) // set disable-bit
+          }
+          Method (_CRS, 0, NotSerialized) { Return (PCRS (PIRC)) }
+          Method (_PRS, 0, NotSerialized) { Return (PPRS) }
+          Method (_SRS, 1, NotSerialized) {
+            CreateDWordField (Arg0, 0x05, IRQW)
+            Store (IRQW, PIRC)
+          }
+        }
+
+        //
+        // PCI IRQ Link D
+        //
+        Device (LNKD) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 4)
+
+          Method (_STA, 0, NotSerialized) { Return (PSTA (PIRD)) }
+          Method (_DIS, 0, NotSerialized) {
+            Or (PIRD, 0x80, PIRD) // set disable-bit
+          }
+          Method (_CRS, 0, NotSerialized) { Return (PCRS (PIRD)) }
+          Method (_PRS, 0, NotSerialized) { Return (PPRS) }
+          Method (_SRS, 1, NotSerialized) {
+            CreateDWordField (Arg0, 0x05, IRQW)
+            Store (IRQW, PIRD)
+          }
+        }
+
+        //
+        // Programmable Interrupt Controller (PIC)
+        //
+        Device(PIC) {
+          Name (_HID, EISAID ("PNP0000"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x020, 0x020, 0x00, 0x02)
+            IO (Decode16, 0x0A0, 0x0A0, 0x00, 0x02)
+            IO (Decode16, 0x4D0, 0x4D0, 0x00, 0x02)
+            IRQNoFlags () {2}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2
+            //
+          })
+        }
+
+        //
+        // ISA DMA
+        //
+        Device (DMAC) {
+          Name (_HID, EISAID ("PNP0200"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x00, 0x00, 0, 0x10)
+            IO (Decode16, 0x81, 0x81, 0, 0x03)
+            IO (Decode16, 0x87, 0x87, 0, 0x01)
+            IO (Decode16, 0x89, 0x89, 0, 0x03)
+            IO (Decode16, 0x8f, 0x8f, 0, 0x01)
+            IO (Decode16, 0xc0, 0xc0, 0, 0x20)
+            DMA (Compatibility, NotBusMaster, Transfer8) {4}
+          })
+        }
+
+        //
+        // 8254 Timer
+        //
+        Device(TMR) {
+          Name(_HID,EISAID("PNP0100"))
+          Name(_CRS, ResourceTemplate () {
+            IO (Decode16, 0x40, 0x40, 0x00, 0x04)
+            IRQNoFlags () {0}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2, 0
+            //
+          })
+        }
+
+        //
+        // Real Time Clock
+        //
+        Device (RTC) {
+          Name (_HID, EISAID ("PNP0B00"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x70, 0x70, 0x00, 0x02)
+            IRQNoFlags () {8}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2, 0, 8
+            //
+          })
+        }
+
+        //
+        // PCAT Speaker
+        //
+        Device(SPKR) {
+          Name (_HID, EISAID("PNP0800"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x61, 0x61, 0x01, 0x01)
+          })
+        }
+
+        //
+        // Floating Point Coprocessor
+        //
+        Device(FPU) {
+          Name (_HID, EISAID("PNP0C04"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0xF0, 0xF0, 0x00, 0x10)
+            IRQNoFlags () {13}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2, 0, 8, 13
+            //
+          })
+        }
+
+        //
+        // Generic motherboard devices and pieces that don't fit anywhere else
+        //
+        Device(XTRA) {
+          Name (_HID, EISAID ("PNP0C02"))
+          Name (_UID, 0x01)
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x010, 0x010, 0x00, 0x10)
+            IO (Decode16, 0x022, 0x022, 0x00, 0x1E)
+            IO (Decode16, 0x044, 0x044, 0x00, 0x1C)
+            IO (Decode16, 0x062, 0x062, 0x00, 0x02)
+            IO (Decode16, 0x065, 0x065, 0x00, 0x0B)
+            IO (Decode16, 0x072, 0x072, 0x00, 0x0E)
+            IO (Decode16, 0x080, 0x080, 0x00, 0x01)
+            IO (Decode16, 0x084, 0x084, 0x00, 0x03)
+            IO (Decode16, 0x088, 0x088, 0x00, 0x01)
+            IO (Decode16, 0x08c, 0x08c, 0x00, 0x03)
+            IO (Decode16, 0x090, 0x090, 0x00, 0x10)
+            IO (Decode16, 0x0A2, 0x0A2, 0x00, 0x1E)
+            IO (Decode16, 0x0E0, 0x0E0, 0x00, 0x10)
+            IO (Decode16, 0x1E0, 0x1E0, 0x00, 0x10)
+            IO (Decode16, 0x160, 0x160, 0x00, 0x10)
+            IO (Decode16, 0x278, 0x278, 0x00, 0x08)
+            IO (Decode16, 0x370, 0x370, 0x00, 0x02)
+            IO (Decode16, 0x378, 0x378, 0x00, 0x08)
+            IO (Decode16, FixedPcdGet16 (PcdDebugIoPort), FixedPcdGet16 (PcdDebugIoPort), 0x00, 0x01)
+            IO (Decode16, 0x440, 0x440, 0x00, 0x10)
+            IO (Decode16, 0x678, 0x678, 0x00, 0x08)
+            IO (Decode16, 0x778, 0x778, 0x00, 0x08)
+            IO (Decode16, 0xafe0, 0xafe0, 0x00, 0x04)      // QEMU GPE0 BLK
+            IO (Decode16, 0xb000, 0xb000, 0x00, 0x40)      // PMBLK1
+            Memory32Fixed (ReadOnly, 0xFEC00000, 0x1000)   // IO APIC
+            Memory32Fixed (ReadOnly, 0xFEE00000, 0x100000) // LAPIC
+          })
+        }
+
+        //
+        // PS/2 Keyboard and PC/AT Enhanced Keyboard 101/102
+        //
+        Device (PS2K) {
+          Name (_HID, EISAID ("PNP0303"))
+          Name (_CID, EISAID ("PNP030B"))
+          Name(_CRS,ResourceTemplate() {
+            IO (Decode16, 0x60, 0x60, 0x00, 0x01)
+            IO (Decode16, 0x64, 0x64, 0x00, 0x01)
+            IRQNoFlags () {1}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2, 0, 8, 13, 1
+            //
+          })
+        }
+
+        //
+        // PS/2 Mouse and Microsoft Mouse
+        //
+        Device (PS2M) {  // PS/2 stype mouse port
+          Name (_HID, EISAID ("PNP0F03"))
+          Name (_CID, EISAID ("PNP0F13"))
+          Name (_CRS, ResourceTemplate() {
+            IRQNoFlags () {12}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12
+            //
+          })
+        }
+
+        //
+        // UART Serial Port - COM1
+        //
+        Device (UAR1) {
+          Name (_HID, EISAID ("PNP0501"))
+          Name (_DDN, "COM1")
+          Name (_UID, 0x01)
+          Name(_CRS,ResourceTemplate() {
+            IO (Decode16, 0x3F8, 0x3F8, 0x01, 0x08)
+            IRQ (Edge, ActiveHigh, Exclusive, ) {4}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12, 4
+            //
+          })
+        }
+
+        //
+        // UART Serial Port - COM2
+        //
+        Device (UAR2) {
+          Name (_HID, EISAID ("PNP0501"))
+          Name (_DDN, "COM2")
+          Name (_UID, 0x02)
+          Name(_CRS,ResourceTemplate() {
+            IO (Decode16, 0x2F8, 0x2F8, 0x01, 0x08)
+            IRQ (Edge, ActiveHigh, Exclusive, ) {3}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12, 4, 3
+            //
+          })
+        }
+
+        //
+        // Floppy Disk Controller
+        //
+        Device (FDC) {
+          Name (_HID, EISAID ("PNP0700"))
+          Name (_CRS,ResourceTemplate() {
+            IO (Decode16, 0x3F0, 0x3F0, 0x01, 0x06)
+            IO (Decode16, 0x3F7, 0x3F7, 0x01, 0x01)
+            IRQNoFlags () {6}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12, 4, 3, 6
+            //
+            DMA (Compatibility, NotBusMaster, Transfer8) {2}
+          })
+        }
+
+        //
+        // parallel port -- no DMA for now
+        //
+        Device (PAR1) {
+          Name (_HID, EISAID ("PNP0400"))
+          Name (_DDN, "LPT1")
+          Name (_UID, 0x01)
+          Name(_CRS, ResourceTemplate() {
+            IO (Decode16, 0x0378, 0x0378, 0x00, 0x08)
+            IRQNoFlags () {7}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12, 4, 3, 6, 7
+            // in order:
+            // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
+            //
+          })
+        }
+      }
+    }
+  }
+}
diff --git a/TestPkg/AcpiTables/Facp.aslc b/TestPkg/AcpiTables/Facp.aslc
new file mode 100644
index 0000000000..f5ed552f4c
--- /dev/null
+++ b/TestPkg/AcpiTables/Facp.aslc
@@ -0,0 +1,89 @@
+/** @file
+  FACP Table
+
+  Copyright (c) 2013, Red Hat, Inc.
+  Copyright (c) 2008 - 2012, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include "Platform.h"
+
+EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE FACP = {
+  {
+    EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE,
+    sizeof (EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE),
+    EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION,
+    0,                          // to make sum of entire table == 0
+    {EFI_ACPI_OEM_ID},          // OEMID is a 6 bytes long field
+    EFI_ACPI_OEM_TABLE_ID,      // OEM table identification(8 bytes long)
+    EFI_ACPI_OEM_REVISION,      // OEM revision number
+    EFI_ACPI_CREATOR_ID,        // ASL compiler vendor ID
+    EFI_ACPI_CREATOR_REVISION   // ASL compiler revision number
+  },
+  0,                // Physical address of FACS
+  0,                // Physical address of DSDT
+  RESERVED,         // System Interrupt Model in ACPI 1.0, eliminated in 2.0
+  EFI_ACPI_2_0_PM_PROFILE_UNSPECIFIED, // Preferred PM profile
+  SCI_INT_VECTOR,   // System vector of SCI interrupt
+  SMI_CMD_IO_PORT,  // Port address of SMI command port
+  ACPI_ENABLE,      // value to write to port smi_cmd to enable ACPI
+  ACPI_DISABLE,     // value to write to port smi_cmd to disable ACPI
+  S4BIOS_REQ,       // Value to write to SMI CMD port to enter the S4BIOS state
+  0,                // PState control
+  PM1a_EVT_BLK,     // Port address of Power Mgt 1a Event Reg Blk
+  0,                // Power Mgt 1b Event Reg Blk unsupported
+  PM1a_CNT_BLK,     // Port address of Power Mgt 1a Ctrl Reg Blk
+  0,                // Power Mgt 1b Ctrl Reg Blk unsupported
+  0,                // Power Mgt 2  Ctrl Reg Blk unsupported
+  PM_TMR_BLK,       // Port address of Power Mgt Timer Ctrl Reg Blk
+  GPE0_BLK,         // Port addr of General Purpose Event 0 Reg Blk
+  0,                // General Purpose Event 1 Reg Blk unsupported
+  PM1_EVT_LEN,      // Byte Length of ports at pm1X_evt_blk
+  PM1_CNT_LEN,      // Byte Length of ports at pm1X_cnt_blk
+  0,                // Power Mgt 2 Ctrl Reg Blk unsupported
+  PM_TM_LEN,        // Byte Length of ports at pm_tm_blk
+  GPE0_BLK_LEN,     // Byte Length of ports at gpe0_blk
+  0,                // General Purpose Event 1 Reg Blk unsupported
+  0,                // General Purpose Event 1 Reg Blk unsupported
+  0,                // _CST support
+  P_LVL2_LAT,       // worst case HW latency to enter/exit C2 state
+  P_LVL3_LAT,       // worst case HW latency to enter/exit C3 state
+  FLUSH_SIZE,       // Size of area read to flush caches
+  FLUSH_STRIDE,     // Stride used in flushing caches
+  DUTY_OFFSET,      // bit location of duty cycle field in p_cnt reg
+  DUTY_WIDTH,       // bit width of duty cycle field in p_cnt reg
+  DAY_ALRM,         // index to day-of-month alarm in RTC CMOS RAM
+  MON_ALRM,         // index to month-of-year alarm in RTC CMOS RAM
+  CENTURY,          // index to century in RTC CMOS RAM
+  0x0000,           // Boot architecture flag (16-bit)
+  RESERVED,         // reserved
+  FLAG,             // Fixed feature flags
+  GAS2_IO(RESET_REG, 1), // Extended address of the Reset Register
+  RESET_VALUE,           // Value for the Reset Register to reset the system
+  { RESERVED },     // reserved[3]
+  0,                // 64-bit physical address of FACS, set at installation
+  0,                // 64-bit physical address of DSDT, set at installation
+
+  GAS2_IO(PM1a_EVT_BLK, PM1_EVT_LEN), // Ext. addr. of PM 1a Event Reg Blk
+  { 0 },                              // PM 1b Event Reg Blk unsupported
+  GAS2_IO(PM1a_CNT_BLK, PM1_CNT_LEN), // Ext. addr. of PM 1a Ctrl Reg Blk
+  { 0 },                              // PM 1b Ctrl Reg Blk unsupported
+  { 0 },                              // PM 2  Ctrl Reg Blk unsupported
+  GAS2_IO(PM_TMR_BLK, PM_TM_LEN),     // Ext. addr. of PM Timer Ctrl Reg Blk
+  GAS2_IO(GPE0_BLK, GPE0_BLK_LEN),    // Ext. addr. of GPE 0 Reg Blk
+  { 0 }                               // GPE 1 Reg Blk unsupported
+};
+
+
+VOID*
+ReferenceAcpiTable (
+  VOID
+  )
+{
+  //
+  // Reference the table being generated to prevent the optimizer from removing the
+  // data structure from the executable
+  //
+  return (VOID*)&FACP;
+}
diff --git a/TestPkg/AcpiTables/Facs.aslc b/TestPkg/AcpiTables/Facs.aslc
new file mode 100644
index 0000000000..ce3f23b9aa
--- /dev/null
+++ b/TestPkg/AcpiTables/Facs.aslc
@@ -0,0 +1,78 @@
+/** @file
+  FACS Table
+
+  Copyright (c) 2008 - 2012, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <IndustryStandard/Acpi.h>
+
+EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE FACS = {
+  EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE,
+  sizeof (EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE),
+
+  //
+  // Hardware Signature will be updated at runtime
+  //
+  0x00000000,
+  0x00,
+  0x00,
+  0x00,
+  {
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE,
+    EFI_ACPI_RESERVED_BYTE
+  }
+};
+
+
+VOID*
+ReferenceAcpiTable (
+  VOID
+  )
+{
+  //
+  // Reference the table being generated to prevent the optimizer from removing the
+  // data structure from the executable
+  //
+  return (VOID*)&FACS;
+}
+
diff --git a/TestPkg/AcpiTables/ForAddTest.asi b/TestPkg/AcpiTables/ForAddTest.asi
new file mode 100644
index 0000000000..c8cf29fae0
--- /dev/null
+++ b/TestPkg/AcpiTables/ForAddTest.asi
@@ -0,0 +1,33 @@
+/** @file
+
+  @copyright
+  INTEL CONFIDENTIAL
+  Copyright 2018 - 2019 Intel Corporation. <BR>
+
+  The source code contained or described herein and all documents related to the
+  source code ("Material") are owned by Intel Corporation or its suppliers or
+  licensors. Title to the Material remains with Intel Corporation or its suppliers
+  and licensors. The Material may contain trade secrets and proprietary    and
+  confidential information of Intel Corporation and its suppliers and licensors,
+  and is protected by worldwide copyright and trade secret laws and treaty
+  provisions. No part of the Material may be used, copied, reproduced, modified,
+  published, uploaded, posted, transmitted, distributed, or disclosed in any way
+  without Intel's prior express written permission.
+
+  No license under any patent, copyright, trade secret or other intellectual
+  property right is granted to or conferred upon you by disclosure or delivery
+  of the Materials, either expressly, by implication, inducement, estoppel or
+  otherwise. Any license under such intellectual property rights must be
+  express and approved by Intel in writing.
+
+  Unless otherwise agreed by Intel in writing, you may not remove or alter
+  this notice or any other notice embedded in Materials by Intel or
+  Intel's suppliers or licensors in any way.
+**/
+
+
+#define MaxRangeForAddTest 0xFEFF
+#define RangeLengthForAddTest 0xF200
+
+
+
diff --git a/TestPkg/AcpiTables/ForAddTest.asl b/TestPkg/AcpiTables/ForAddTest.asl
new file mode 100644
index 0000000000..4dbb5f40b2
--- /dev/null
+++ b/TestPkg/AcpiTables/ForAddTest.asl
@@ -0,0 +1,704 @@
+/** @file
+  ACPI DSDT table
+
+  @copyright
+  INTEL CONFIDENTIAL
+  Copyright 2011 - 2014 Intel Corporation. <BR>
+
+  The source code contained or described herein and all documents related to the
+  source code ("Material") are owned by Intel Corporation or its suppliers or
+  licensors. Title to the Material remains with Intel Corporation or its suppliers
+  and licensors. The Material may contain trade secrets and proprietary    and
+  confidential information of Intel Corporation and its suppliers and licensors,
+  and is protected by worldwide copyright and trade secret laws and treaty
+  provisions. No part of the Material may be used, copied, reproduced, modified,
+  published, uploaded, posted, transmitted, distributed, or disclosed in any way
+  without Intel's prior express written permission.
+
+  No license under any patent, copyright, trade secret or other intellectual
+  property right is granted to or conferred upon you by disclosure or delivery
+  of the Materials, either expressly, by implication, inducement, estoppel or
+  otherwise. Any license under such intellectual property rights must be
+  express and approved by Intel in writing.
+
+  Unless otherwise agreed by Intel in writing, you may not remove or alter
+  this notice or any other notice embedded in Materials by Intel or
+  Intel's suppliers or licensors in any way.
+**/
+
+//
+// PCI IRQ Link D
+//
+//
+  //  System Bus
+  //
+  Scope (\_SB) {
+    //
+    // PCI Root Bridge
+    //
+    Device (PCI0) {
+      Name (_HID, EISAID ("PNP0A03"))
+      Name (_ADR, 0x00000000)
+      Name (_BBN, 0x00)
+      Name (_UID, 0x00)
+
+      //
+      // BUS, I/O, and MMIO resources
+      //
+      Name (CRES, ResourceTemplate () {
+        WORDBusNumber (          // Bus number resource (0); the bridge produces bus numbers for its subsequent buses
+          ResourceProducer,      // bit 0 of general flags is 1
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is fixed
+          PosDecode,             // PosDecode
+          0x0000,                // Granularity
+          0x0000,                // Min
+          0x00FF,                // Max
+          0x0000,                // Translation
+          0x0100                 // Range Length = Max-Min+1
+          )
+
+        IO (Decode16, 0xCF8, 0xCF8, 0x01, 0x08)       //Consumed resource (0xCF8-0xCFF)
+
+        WORDIO (                 // Consumed-and-produced resource (all I/O below CF8)
+          ResourceProducer,      // bit 0 of general flags is 0
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is fixed
+          PosDecode,
+          EntireRange,
+          0x0000,                // Granularity
+          0x0000,                // Min
+          0x0CF7,                // Max
+          0x0000,                // Translation
+          0x0CF8                 // Range Length
+          )
+
+        WORDIO (                 // Consumed-and-produced resource (all I/O above CFF)
+          ResourceProducer,      // bit 0 of general flags is 0
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is fixed
+          PosDecode,
+          EntireRange,
+          0x0000,                // Granularity
+          0x0D00,                // Min
+          0xFFFF,                // Max
+          0x0000,                // Translation
+          0xF300                 // Range Length
+          )
+
+        DWORDMEMORY (            // Descriptor for legacy VGA video RAM
+          ResourceProducer,      // bit 0 of general flags is 0
+          PosDecode,
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is Fixed
+          Cacheable,
+          ReadWrite,
+          0x00000000,            // Granularity
+          0x000A0000,            // Min
+          MAX_DWORDMEMORY,       // Max
+          0x00000000,            // Translation
+          0x00020000             // Range Length
+          )
+
+        DWORDMEMORY (            // Descriptor for 32-bit MMIO
+          ResourceProducer,      // bit 0 of general flags is 0
+          PosDecode,
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is Fixed
+          NonCacheable,
+          ReadWrite,
+          0x00000000,            // Granularity
+          0xF8000000,            // Min
+          0xFFFBFFFF,            // Max
+          0x00000000,            // Translation
+          0x07FC0000,            // Range Length
+          ,                      // ResourceSourceIndex
+          ,                      // ResourceSource
+          PW32                   // DescriptorName
+          )
+      })
+
+      Name (CR64, ResourceTemplate () {
+        QWordMemory (            // Descriptor for 64-bit MMIO
+            ResourceProducer,    // bit 0 of general flags is 0
+            PosDecode,
+            MinFixed,            // Range is fixed
+            MaxFixed,            // Range is Fixed
+            Cacheable,
+            ReadWrite,
+            0x00000000,          // Granularity
+            0x8000000000,        // Min
+            MAX_QWordMemory,     // Max
+            0x00000000,          // Translation
+            0x8000000000,        // Range Length
+            ,                    // ResourceSourceIndex
+            ,                    // ResourceSource
+            PW64                 // DescriptorName
+            )
+      })
+
+      Method (_CRS, 0, Serialized) {
+        //
+        // see the FIRMWARE_DATA structure in "OvmfPkg/AcpiPlatformDxe/Qemu.c"
+        //
+        External (FWDT, OpRegionObj)
+        Field(FWDT, QWordAcc, NoLock, Preserve) {
+          P0S, 64,               // PciWindow32.Base
+          P0E, 64,               // PciWindow32.End
+          P0L, 64,               // PciWindow32.Length
+          P1S, 64,               // PciWindow64.Base
+          P1E, 64,               // PciWindow64.End
+          P1L, 64                // PciWindow64.Length
+        }
+        Field(FWDT, DWordAcc, NoLock, Preserve) {
+          P0SL, 32,              // PciWindow32.Base,   low  32 bits
+          P0SH, 32,              // PciWindow32.Base,   high 32 bits
+          P0EL, 32,              // PciWindow32.End,    low  32 bits
+          P0EH, 32,              // PciWindow32.End,    high 32 bits
+          P0LL, 32,              // PciWindow32.Length, low  32 bits
+          P0LH, 32,              // PciWindow32.Length, high 32 bits
+          P1SL, 32,              // PciWindow64.Base,   low  32 bits
+          P1SH, 32,              // PciWindow64.Base,   high 32 bits
+          P1EL, 32,              // PciWindow64.End,    low  32 bits
+          P1EH, 32,              // PciWindow64.End,    high 32 bits
+          P1LL, 32,              // PciWindow64.Length, low  32 bits
+          P1LH, 32               // PciWindow64.Length, high 32 bits
+        }
+
+        //
+        // fixup 32-bit PCI IO window
+        //
+        CreateDWordField (CRES, \_SB.PCI0.PW32._MIN, PS32)
+        CreateDWordField (CRES, \_SB.PCI0.PW32._MAX, PE32)
+        CreateDWordField (CRES, \_SB.PCI0.PW32._LEN, PL32)
+        Store (P0SL, PS32)
+        Store (P0EL, PE32)
+        Store (P0LL, PL32)
+
+        If (LAnd (LEqual (P1SL, 0x00), LEqual (P1SH, 0x00))) {
+          Return (CRES)
+        } Else {
+          //
+          // fixup 64-bit PCI IO window
+          //
+          CreateQWordField (CR64, \_SB.PCI0.PW64._MIN, PS64)
+          CreateQWordField (CR64, \_SB.PCI0.PW64._MAX, PE64)
+          CreateQWordField (CR64, \_SB.PCI0.PW64._LEN, PL64)
+          Store (P1S, PS64)
+          Store (P1E, PE64)
+          Store (P1L, PL64)
+
+          //
+          // add window and return result
+          //
+          ConcatenateResTemplate (CRES, CR64, Local0)
+          Return (Local0)
+        }
+      }
+
+      //
+      // PCI Interrupt Routing Table - PIC Mode Only
+      //
+      Method (_PRT, 0, NotSerialized) {
+        Return (
+          Package () {
+            //
+            // Bus 0; Devices 0 to 15
+            //
+            Package () {0x0000FFFF, 0x00, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0000FFFF, 0x01, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0000FFFF, 0x02, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0000FFFF, 0x03, \_SB.PCI0.LPC.LNKC, 0x00},
+
+            //
+            // Bus 0, Device 1, Pin 0 (INTA) is special; it corresponds to the
+            // internally generated SCI (System Control Interrupt), which is
+            // always routed to GSI 9. By setting the third (= Source) field to
+            // zero, we could use the fourth (= Source Index) field to hardwire
+            // the pin to GSI 9 directly.
+            //
+            // That way however, in accordance with the ACPI spec's description
+            // of SCI, the interrupt would be treated as "active low,
+            // shareable, level", and that doesn't match qemu.
+            //
+            // In QemuInstallAcpiMadtTable() [OvmfPkg/AcpiPlatformDxe/Qemu.c]
+            // we install an Interrupt Override Structure for the identity
+            // mapped IRQ#9 / GSI 9 (the corresponding bit being set in
+            // Pcd8259LegacyModeEdgeLevel), which describes the correct
+            // polarity (active high). As a consequence, some OS'en (eg. Linux)
+            // override the default (active low) polarity originating from the
+            // _PRT; others (eg. FreeBSD) don't. Therefore we need a separate
+            // link device just to specify a polarity that matches the MADT.
+            //
+            Package () {0x0001FFFF, 0x00, \_SB.PCI0.LPC.LNKS, 0x00},
+
+            Package () {0x0001FFFF, 0x01, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0001FFFF, 0x02, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0001FFFF, 0x03, \_SB.PCI0.LPC.LNKD, 0x00},
+
+            Package () {0x0002FFFF, 0x00, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0002FFFF, 0x01, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0002FFFF, 0x02, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0002FFFF, 0x03, \_SB.PCI0.LPC.LNKA, 0x00},
+
+            Package () {0x0003FFFF, 0x00, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0003FFFF, 0x01, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0003FFFF, 0x02, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0003FFFF, 0x03, \_SB.PCI0.LPC.LNKB, 0x00},
+
+            Package () {0x0004FFFF, 0x00, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0004FFFF, 0x01, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0004FFFF, 0x02, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0004FFFF, 0x03, \_SB.PCI0.LPC.LNKC, 0x00},
+
+            Package () {0x0005FFFF, 0x00, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0005FFFF, 0x01, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0005FFFF, 0x02, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0005FFFF, 0x03, \_SB.PCI0.LPC.LNKD, 0x00},
+
+            Package () {0x0006FFFF, 0x00, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0006FFFF, 0x01, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0006FFFF, 0x02, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0006FFFF, 0x03, \_SB.PCI0.LPC.LNKA, 0x00},
+
+            Package () {0x0007FFFF, 0x00, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0007FFFF, 0x01, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0007FFFF, 0x02, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0007FFFF, 0x03, \_SB.PCI0.LPC.LNKB, 0x00},
+
+            Package () {0x0008FFFF, 0x00, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0008FFFF, 0x01, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0008FFFF, 0x02, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0008FFFF, 0x03, \_SB.PCI0.LPC.LNKC, 0x00},
+
+            Package () {0x0009FFFF, 0x00, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0009FFFF, 0x01, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0009FFFF, 0x02, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0009FFFF, 0x03, \_SB.PCI0.LPC.LNKD, 0x00},
+
+            Package () {0x000AFFFF, 0x00, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x000AFFFF, 0x01, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000AFFFF, 0x02, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000AFFFF, 0x03, \_SB.PCI0.LPC.LNKA, 0x00},
+
+            Package () {0x000BFFFF, 0x00, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000BFFFF, 0x01, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000BFFFF, 0x02, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x000BFFFF, 0x03, \_SB.PCI0.LPC.LNKB, 0x00},
+
+            Package () {0x000CFFFF, 0x00, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000CFFFF, 0x01, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x000CFFFF, 0x02, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x000CFFFF, 0x03, \_SB.PCI0.LPC.LNKC, 0x00},
+
+            Package () {0x000DFFFF, 0x00, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x000DFFFF, 0x01, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x000DFFFF, 0x02, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000DFFFF, 0x03, \_SB.PCI0.LPC.LNKD, 0x00},
+
+            Package () {0x000EFFFF, 0x00, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x000EFFFF, 0x01, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000EFFFF, 0x02, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000EFFFF, 0x03, \_SB.PCI0.LPC.LNKA, 0x00},
+
+            Package () {0x000FFFFF, 0x00, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000FFFFF, 0x01, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000FFFFF, 0x02, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x000FFFFF, 0x03, \_SB.PCI0.LPC.LNKB, 0x00}
+          }
+        )
+      }
+
+      //
+      // PCI to ISA Bridge (Bus 0, Device 1, Function 0)
+      // "Low Pin Count"
+      //
+      Device (LPC) {
+        Name (_ADR, 0x00010000)
+
+        //
+        // The SCI cannot be rerouted or disabled with PIRQRC[A:D]; we only
+        // need this link device in order to specify the polarity.
+        //
+        Device (LNKS) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 0)
+
+          Name (_STA, 0xB) // 0x1: device present
+                           // 0x2: enabled and decoding resources
+                           // 0x8: functioning properly
+
+          Method (_SRS, 1, NotSerialized) { /* no-op */ }
+          Method (_DIS, 0, NotSerialized) { /* no-op */ }
+
+          Name (_PRS, ResourceTemplate () {
+            Interrupt (ResourceConsumer, Level, ActiveHigh, Shared) { 9 }
+            //
+            // list of IRQs occupied thus far: 9
+            //
+          })
+          Method (_CRS, 0, NotSerialized) { Return (_PRS) }
+        }
+
+        //
+        // PCI Interrupt Routing Configuration Registers, PIRQRC[A:D]
+        //
+        OperationRegion (PRR0, PCI_Config, 0x60, 0x04)
+        Field (PRR0, ANYACC, NOLOCK, PRESERVE) {
+          PIRA, 8,
+          PIRB, 8,
+          PIRC, 8,
+          PIRD, 8
+        }
+
+        //
+        // _STA method for LNKA, LNKB, LNKC, LNKD
+        // Arg0[in]: value of PIRA / PIRB / PIRC / PIRD
+        //
+        Method (PSTA, 1, NotSerialized) {
+          If (And (Arg0, 0x80)) { // disable-bit set?
+            Return (0x9)          // "device present" | "functioning properly"
+          } Else {
+            Return (0xB)          // same | "enabled and decoding resources"
+          }
+        }
+
+        //
+        // _CRS method for LNKA, LNKB, LNKC, LNKD
+        // Arg0[in]: value of PIRA / PIRB / PIRC / PIRD
+        //
+        Method (PCRS, 1, Serialized) {
+          //
+          // create temporary buffer with an Extended Interrupt Descriptor
+          // whose single vector defaults to zero
+          //
+          Name (BUF0, ResourceTemplate () {
+              Interrupt (ResourceConsumer, Level, ActiveHigh, Shared){0}
+            }
+          )
+
+          //
+          // define reference to first interrupt vector in buffer
+          //
+          CreateDWordField (BUF0, 0x05, IRQW)
+
+          //
+          // If the disable-bit is clear, overwrite the default zero vector
+          // with the value in Arg0 (ie. PIRQRC[A:D]). Reserved bits are read
+          // as 0.
+          //
+          If (LNot (And (Arg0, 0x80))) {
+            Store (Arg0, IRQW)
+          }
+          Return (BUF0)
+        }
+
+        //
+        // _PRS resource for LNKA, LNKB, LNKC, LNKD
+        //
+        Name (PPRS, ResourceTemplate () {
+          Interrupt (ResourceConsumer, Level, ActiveHigh, Shared) {5, 10, 11}
+          //
+          // list of IRQs occupied thus far: 9, 5, 10, 11
+          //
+        })
+
+        //
+        // PCI IRQ Link A
+        //
+        Device (LNKA) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 1)
+
+          Method (_STA, 0, NotSerialized) { Return (PSTA (PIRA)) }
+          Method (_DIS, 0, NotSerialized) {
+            Or (PIRA, 0x80, PIRA) // set disable-bit
+          }
+          Method (_CRS, 0, NotSerialized) { Return (PCRS (PIRA)) }
+          Method (_PRS, 0, NotSerialized) { Return (PPRS) }
+          Method (_SRS, 1, NotSerialized) {
+            CreateDWordField (Arg0, 0x05, IRQW)
+            Store (IRQW, PIRA)
+          }
+        }
+
+        //
+        // PCI IRQ Link B
+        //
+        Device (LNKB) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 2)
+
+          Method (_STA, 0, NotSerialized) { Return (PSTA (PIRB)) }
+          Method (_DIS, 0, NotSerialized) {
+            Or (PIRB, 0x80, PIRB) // set disable-bit
+          }
+          Method (_CRS, 0, NotSerialized) { Return (PCRS (PIRB)) }
+          Method (_PRS, 0, NotSerialized) { Return (PPRS) }
+          Method (_SRS, 1, NotSerialized) {
+            CreateDWordField (Arg0, 0x05, IRQW)
+            Store (IRQW, PIRB)
+          }
+        }
+
+        //
+        // PCI IRQ Link C
+        //
+        Device (LNKC) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 3)
+
+          Method (_STA, 0, NotSerialized) { Return (PSTA (PIRC)) }
+          Method (_DIS, 0, NotSerialized) {
+            Or (PIRC, 0x80, PIRC) // set disable-bit
+          }
+          Method (_CRS, 0, NotSerialized) { Return (PCRS (PIRC)) }
+          Method (_PRS, 0, NotSerialized) { Return (PPRS) }
+          Method (_SRS, 1, NotSerialized) {
+            CreateDWordField (Arg0, 0x05, IRQW)
+            Store (IRQW, PIRC)
+          }
+        }
+
+        //
+        // PCI IRQ Link D
+        //
+        Device (LNKD) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 4)
+
+          Method (_STA, 0, NotSerialized) { Return (PSTA (PIRD)) }
+          Method (_DIS, 0, NotSerialized) {
+            Or (PIRD, 0x80, PIRD) // set disable-bit
+          }
+          Method (_CRS, 0, NotSerialized) { Return (PCRS (PIRD)) }
+          Method (_PRS, 0, NotSerialized) { Return (PPRS) }
+          Method (_SRS, 1, NotSerialized) {
+            CreateDWordField (Arg0, 0x05, IRQW)
+            Store (IRQW, PIRD)
+          }
+        }
+
+        //
+        // Programmable Interrupt Controller (PIC)
+        //
+        Device(PIC) {
+          Name (_HID, EISAID ("PNP0000"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x020, 0x020, 0x00, 0x02)
+            IO (Decode16, 0x0A0, 0x0A0, 0x00, 0x02)
+            IO (Decode16, 0x4D0, 0x4D0, 0x00, 0x02)
+            IRQNoFlags () {2}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2
+            //
+          })
+        }
+
+        //
+        // ISA DMA
+        //
+        Device (DMAC) {
+          Name (_HID, EISAID ("PNP0200"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x00, 0x00, 0, 0x10)
+            IO (Decode16, 0x81, 0x81, 0, 0x03)
+            IO (Decode16, 0x87, 0x87, 0, 0x01)
+            IO (Decode16, 0x89, 0x89, 0, 0x03)
+            IO (Decode16, 0x8f, 0x8f, 0, 0x01)
+            IO (Decode16, 0xc0, 0xc0, 0, 0x20)
+            DMA (Compatibility, NotBusMaster, Transfer8) {4}
+          })
+        }
+
+        //
+        // 8254 Timer
+        //
+        Device(TMR) {
+          Name(_HID,EISAID("PNP0100"))
+          Name(_CRS, ResourceTemplate () {
+            IO (Decode16, 0x40, 0x40, 0x00, 0x04)
+            IRQNoFlags () {0}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2, 0
+            //
+          })
+        }
+
+        //
+        // Real Time Clock
+        //
+        Device (RTC) {
+          Name (_HID, EISAID ("PNP0B00"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x70, 0x70, 0x00, 0x02)
+            IRQNoFlags () {8}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2, 0, 8
+            //
+          })
+        }
+
+        //
+        // PCAT Speaker
+        //
+        Device(SPKR) {
+          Name (_HID, EISAID("PNP0800"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x61, 0x61, 0x01, 0x01)
+          })
+        }
+
+        //
+        // Floating Point Coprocessor
+        //
+        Device(FPU) {
+          Name (_HID, EISAID("PNP0C04"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0xF0, 0xF0, 0x00, 0x10)
+            IRQNoFlags () {13}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2, 0, 8, 13
+            //
+          })
+        }
+
+        //
+        // Generic motherboard devices and pieces that don't fit anywhere else
+        //
+        Device(XTRA) {
+          Name (_HID, EISAID ("PNP0C02"))
+          Name (_UID, 0x01)
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x010, 0x010, 0x00, 0x10)
+            IO (Decode16, 0x022, 0x022, 0x00, 0x1E)
+            IO (Decode16, 0x044, 0x044, 0x00, 0x1C)
+            IO (Decode16, 0x062, 0x062, 0x00, 0x02)
+            IO (Decode16, 0x065, 0x065, 0x00, 0x0B)
+            IO (Decode16, 0x072, 0x072, 0x00, 0x0E)
+            IO (Decode16, 0x080, 0x080, 0x00, 0x01)
+            IO (Decode16, 0x084, 0x084, 0x00, 0x03)
+            IO (Decode16, 0x088, 0x088, 0x00, 0x01)
+            IO (Decode16, 0x08c, 0x08c, 0x00, 0x03)
+            IO (Decode16, 0x090, 0x090, 0x00, 0x10)
+            IO (Decode16, 0x0A2, 0x0A2, 0x00, 0x1E)
+            IO (Decode16, 0x0E0, 0x0E0, 0x00, 0x10)
+            IO (Decode16, 0x1E0, 0x1E0, 0x00, 0x10)
+            IO (Decode16, 0x160, 0x160, 0x00, 0x10)
+            IO (Decode16, 0x278, 0x278, 0x00, 0x08)
+            IO (Decode16, 0x370, 0x370, 0x00, 0x02)
+            IO (Decode16, 0x378, 0x378, 0x00, 0x08)
+            IO (Decode16, FixedPcdGet16 (PcdDebugIoPort), FixedPcdGet16 (PcdDebugIoPort), 0x00, 0x01)
+            IO (Decode16, 0x440, 0x440, 0x00, 0x10)
+            IO (Decode16, 0x678, 0x678, 0x00, 0x08)
+            IO (Decode16, 0x778, 0x778, 0x00, 0x08)
+            IO (Decode16, 0xafe0, 0xafe0, 0x00, 0x04)      // QEMU GPE0 BLK
+            IO (Decode16, 0xb000, 0xb000, 0x00, 0x40)      // PMBLK1
+            Memory32Fixed (ReadOnly, 0xFEC00000, 0x1000)   // IO APIC
+            Memory32Fixed (ReadOnly, 0xFEE00000, 0x100000) // LAPIC
+          })
+        }
+
+        //
+        // PS/2 Keyboard and PC/AT Enhanced Keyboard 101/102
+        //
+        Device (PS2K) {
+          Name (_HID, EISAID ("PNP0303"))
+          Name (_CID, EISAID ("PNP030B"))
+          Name(_CRS,ResourceTemplate() {
+            IO (Decode16, 0x60, 0x60, 0x00, 0x01)
+            IO (Decode16, 0x64, 0x64, 0x00, 0x01)
+            IRQNoFlags () {1}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2, 0, 8, 13, 1
+            //
+          })
+        }
+
+        //
+        // PS/2 Mouse and Microsoft Mouse
+        //
+        Device (PS2M) {  // PS/2 stype mouse port
+          Name (_HID, EISAID ("PNP0F03"))
+          Name (_CID, EISAID ("PNP0F13"))
+          Name (_CRS, ResourceTemplate() {
+            IRQNoFlags () {12}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12
+            //
+          })
+        }
+
+        //
+        // UART Serial Port - COM1
+        //
+        Device (UAR1) {
+          Name (_HID, EISAID ("PNP0501"))
+          Name (_DDN, "COM1")
+          Name (_UID, 0x01)
+          Name(_CRS,ResourceTemplate() {
+            IO (Decode16, 0x3F8, 0x3F8, 0x01, 0x08)
+            IRQ (Edge, ActiveHigh, Exclusive, ) {4}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12, 4
+            //
+          })
+        }
+
+        //
+        // UART Serial Port - COM2
+        //
+        Device (UAR2) {
+          Name (_HID, EISAID ("PNP0501"))
+          Name (_DDN, "COM2")
+          Name (_UID, 0x02)
+          Name(_CRS,ResourceTemplate() {
+            IO (Decode16, 0x2F8, 0x2F8, 0x01, 0x08)
+            IRQ (Edge, ActiveHigh, Exclusive, ) {3}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12, 4, 3
+            //
+          })
+        }
+
+        //
+        // Floppy Disk Controller
+        //
+        Device (FDC) {
+          Name (_HID, EISAID ("PNP0700"))
+          Name (_CRS,ResourceTemplate() {
+            IO (Decode16, 0x3F0, 0x3F0, 0x01, 0x06)
+            IO (Decode16, 0x3F7, 0x3F7, 0x01, 0x01)
+            IRQNoFlags () {6}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12, 4, 3, 6
+            //
+            DMA (Compatibility, NotBusMaster, Transfer8) {2}
+          })
+        }
+
+        //
+        // parallel port -- no DMA for now
+        //
+        Device (PAR1) {
+          Name (_HID, EISAID ("PNP0400"))
+          Name (_DDN, "LPT1")
+          Name (_UID, 0x01)
+          Name(_CRS, ResourceTemplate() {
+            IO (Decode16, 0x0378, 0x0378, 0x00, 0x08)
+            IRQNoFlags () {7}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12, 4, 3, 6, 7
+            // in order:
+            // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
+            //
+          })
+        }
+      }
+    }
+  }
\ No newline at end of file
diff --git a/TestPkg/AcpiTables/ForAddTest.h b/TestPkg/AcpiTables/ForAddTest.h
new file mode 100644
index 0000000000..a3a45d65e3
--- /dev/null
+++ b/TestPkg/AcpiTables/ForAddTest.h
@@ -0,0 +1,11 @@
+/** @file
+  Platform specific defines for constructing ACPI tables
+
+  Copyright (c) 2012, 2013, Red Hat, Inc.
+  Copyright (c) 2008, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define MaxRangeForAddTest 0x00FA
+#define RangeLengthForAddTest 0x00FB
\ No newline at end of file
diff --git a/TestPkg/AcpiTables/ForHIncludedH.h b/TestPkg/AcpiTables/ForHIncludedH.h
new file mode 100644
index 0000000000..ee74452f3d
--- /dev/null
+++ b/TestPkg/AcpiTables/ForHIncludedH.h
@@ -0,0 +1,10 @@
+/** @file
+  Platform specific defines for constructing ACPI tables
+
+  Copyright (c) 2012, 2013, Red Hat, Inc.
+  Copyright (c) 2008, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define ATestAddrH 0x0000b004
\ No newline at end of file
diff --git a/TestPkg/AcpiTables/Madt.aslc b/TestPkg/AcpiTables/Madt.aslc
new file mode 100644
index 0000000000..0f73690f19
--- /dev/null
+++ b/TestPkg/AcpiTables/Madt.aslc
@@ -0,0 +1,153 @@
+/** @file
+  MADT Table
+
+  This file contains a structure definition for the ACPI 1.0 Multiple APIC
+  Description Table (MADT).
+
+  Copyright (c) 2008 - 2012, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <IndustryStandard/Acpi.h>
+#include <Platform.h>
+
+//
+// Local APIC address
+//
+#define EFI_ACPI_LOCAL_APIC_ADDRESS 0xFEE00000 // TBD
+
+//
+// Multiple APIC Flags are defined in AcpiX.0.h
+//
+#define EFI_ACPI_1_0_MULTIPLE_APIC_FLAGS (EFI_ACPI_1_0_PCAT_COMPAT)
+
+//
+// Define the number of each table type.
+// This is where the table layout is modified.
+//
+#define EFI_ACPI_PROCESSOR_LOCAL_APIC_COUNT           1
+#define EFI_ACPI_INTERRUPT_SOURCE_OVERRIDE_COUNT      2
+#define EFI_ACPI_IO_APIC_COUNT                        1
+
+//
+// Ensure proper structure formats
+//
+#pragma pack (1)
+
+//
+// ACPI 1.0 MADT structure
+//
+typedef struct {
+  EFI_ACPI_1_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER   Header;
+
+#if EFI_ACPI_PROCESSOR_LOCAL_APIC_COUNT > 0
+  EFI_ACPI_1_0_PROCESSOR_LOCAL_APIC_STRUCTURE           LocalApic[EFI_ACPI_PROCESSOR_LOCAL_APIC_COUNT];
+#endif
+
+#if EFI_ACPI_INTERRUPT_SOURCE_OVERRIDE_COUNT > 0
+  EFI_ACPI_1_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE      Iso[EFI_ACPI_INTERRUPT_SOURCE_OVERRIDE_COUNT];
+#endif
+
+#if EFI_ACPI_IO_APIC_COUNT > 0
+  EFI_ACPI_1_0_IO_APIC_STRUCTURE                        IoApic[EFI_ACPI_IO_APIC_COUNT];
+#endif
+
+} EFI_ACPI_1_0_MULTIPLE_APIC_DESCRIPTION_TABLE;
+
+#pragma pack ()
+
+//
+// Multiple APIC Description Table
+//
+EFI_ACPI_1_0_MULTIPLE_APIC_DESCRIPTION_TABLE Madt = {
+  {
+    {
+      EFI_ACPI_1_0_APIC_SIGNATURE,
+      sizeof (EFI_ACPI_1_0_MULTIPLE_APIC_DESCRIPTION_TABLE),
+      EFI_ACPI_1_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION,
+      0x00,                                                     // Checksum will be updated at runtime
+      {EFI_ACPI_OEM_ID},
+      EFI_ACPI_OEM_TABLE_ID,
+      EFI_ACPI_OEM_REVISION,
+      EFI_ACPI_CREATOR_ID,
+      EFI_ACPI_CREATOR_REVISION
+    },
+
+    //
+    // MADT specific fields
+    //
+    EFI_ACPI_LOCAL_APIC_ADDRESS,
+    EFI_ACPI_1_0_MULTIPLE_APIC_FLAGS,
+  },
+
+  //
+  // Processor Local APIC Structure
+  //
+  {
+    {
+      EFI_ACPI_1_0_PROCESSOR_LOCAL_APIC,                        // Type
+      sizeof (EFI_ACPI_1_0_PROCESSOR_LOCAL_APIC_STRUCTURE),     // Length
+      0x00,                                                     // Processor ID
+      0x00,                                                     // Local APIC ID
+      0x00000001                                                // Flags - Enabled by default
+    }
+  },
+
+  //
+  // Interrupt Source Override Structure
+  //
+
+  {
+    {
+      //
+      // IRQ0=>IRQ2 Interrupt Source Override Structure
+      //
+      EFI_ACPI_1_0_INTERRUPT_SOURCE_OVERRIDE,                   // Type
+      sizeof (EFI_ACPI_1_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE),// Length
+      0x00,                                                     // Bus - ISA
+      0x00,                                                     // Source - IRQ0
+      0x00000002,                                               // Global System Interrupt - IRQ2
+      0x0000                                                    // Flags - Conforms to specifications of the bus
+    },
+
+    {
+      //
+      // ISO (SCI Active High) Interrupt Source Override Structure
+      //
+      EFI_ACPI_1_0_INTERRUPT_SOURCE_OVERRIDE,                   // Type
+      sizeof (EFI_ACPI_1_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE),// Length
+      0x00,                                                     // Bus - ISA
+      0x09,                                                     // Source - IRQ0
+      0x00000009,                                               // Global System Interrupt - IRQ2
+      0x000D                                                    // Flags - Level-tiggered, Active High
+    }
+  },
+
+  //
+  // IO APIC Structure
+  //
+  {
+    {
+      EFI_ACPI_1_0_IO_APIC,                                     // Type
+      sizeof (EFI_ACPI_1_0_IO_APIC_STRUCTURE),                  // Length
+      0x02,                                                     // IO APIC ID
+      EFI_ACPI_RESERVED_BYTE,                                   // Reserved
+      0xFEC00000,                                               // IO APIC Address (physical)
+      0x00000000                                                // Global System Interrupt Base
+    }
+  },
+};
+
+
+VOID*
+ReferenceAcpiTable (
+  VOID
+  )
+{
+  //
+  // Reference the table being generated to prevent the optimizer from removing the
+  // data structure from the executable
+  //
+  return (VOID*)&Madt;
+}
diff --git a/TestPkg/AcpiTables/Platform.h b/TestPkg/AcpiTables/Platform.h
new file mode 100644
index 0000000000..b1341ee2a4
--- /dev/null
+++ b/TestPkg/AcpiTables/Platform.h
@@ -0,0 +1,69 @@
+/** @file
+  Platform specific defines for constructing ACPI tables
+
+  Copyright (c) 2012, 2013, Red Hat, Inc.
+  Copyright (c) 2008, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _Platform_h_INCLUDED_
+#define _Platform_h_INCLUDED_
+
+#include <PiDxe.h>
+#include <IndustryStandard/Acpi.h>
+
+//
+// ACPI table information used to initialize tables.
+//
+#define EFI_ACPI_OEM_ID           'O','V','M','F',' ',' '   // OEMID 6 bytes long
+#define EFI_ACPI_OEM_TABLE_ID     SIGNATURE_64('O','V','M','F','E','D','K','2') // OEM table id 8 bytes long
+#define EFI_ACPI_OEM_REVISION     0x20130221
+#define EFI_ACPI_CREATOR_ID       SIGNATURE_32('O','V','M','F')
+#define EFI_ACPI_CREATOR_REVISION 0x00000099
+
+#define SCI_INT_VECTOR  0x0009
+#define SMI_CMD_IO_PORT 0xB2
+#define ACPI_ENABLE     0xF1
+#define ACPI_DISABLE    0xF0
+#define S4BIOS_REQ      0x00
+#define PM1a_EVT_BLK    0x0000b000
+#define PM1a_CNT_BLK    0x0000b004
+#define PM_TMR_BLK      0x0000b008
+#define GPE0_BLK        0x0000afe0
+#define PM1_EVT_LEN     0x04
+#define PM1_CNT_LEN     0x02
+#define PM_TM_LEN       0x04
+#define GPE0_BLK_LEN    0x04
+#define RESERVED        0x00
+#define P_LVL2_LAT      0x0065
+#define P_LVL3_LAT      0x03E9
+#define FLUSH_SIZE      0x0000
+#define FLUSH_STRIDE    0x0000
+#define DUTY_OFFSET     0x00
+#define DUTY_WIDTH      0x00
+#define DAY_ALRM        0x00
+#define MON_ALRM        0x00
+#define CENTURY         0x00
+#define FLAG            (EFI_ACPI_2_0_WBINVD | \
+                         EFI_ACPI_2_0_PROC_C1 | \
+                         EFI_ACPI_2_0_SLP_BUTTON | \
+                         EFI_ACPI_2_0_RTC_S4 | \
+                         EFI_ACPI_2_0_RESET_REG_SUP)
+#define RESET_REG       0xCF9
+#define RESET_VALUE     (BIT2 | BIT1) // PIIX3 Reset CPU + System Reset
+#define MAX_DWORDMEMORY 0x000BFFFF
+
+//
+// Byte-aligned IO port register block initializer for
+// EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE
+//
+#define GAS2_IO(Base, Size) {                             \
+          EFI_ACPI_2_0_SYSTEM_IO, /* AddressSpaceId    */ \
+          (Size) * 8,             /* RegisterBitWidth  */ \
+          0,                      /* RegisterBitOffset */ \
+          0,                      /* Reserved          */ \
+          (Base)                  /* Address           */ \
+          }
+
+#endif
diff --git a/TestPkg/AcpiTables/Ssdt.asl b/TestPkg/AcpiTables/Ssdt.asl
new file mode 100644
index 0000000000..d1e362b673
--- /dev/null
+++ b/TestPkg/AcpiTables/Ssdt.asl
@@ -0,0 +1,13 @@
+/** @file
+  Placeholder for runtime-generated objects.
+
+  This empty table provides only a header for dynamic copying and extension,
+  and a trigger for QemuInstallAcpiSsdtTable().
+
+  Copyright (C) 2012 Red Hat, Inc.
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+DefinitionBlock ("Ssdt.aml", "SSDT", 1, "REDHAT", "OVMF    ", 1) {
+}
diff --git a/TestPkg/AcpiTables/TestPlatform.asl b/TestPkg/AcpiTables/TestPlatform.asl
new file mode 100644
index 0000000000..0f68ab8d3c
--- /dev/null
+++ b/TestPkg/AcpiTables/TestPlatform.asl
@@ -0,0 +1,10 @@
+/** @file
+  Contains root level name space objects for the platform
+
+  Copyright (c) 2008, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include "Dsdt.asl"
+
diff --git a/TestPkg/AcpiTables/test.asi b/TestPkg/AcpiTables/test.asi
new file mode 100644
index 0000000000..5afb6840b9
--- /dev/null
+++ b/TestPkg/AcpiTables/test.asi
@@ -0,0 +1,32 @@
+/** @file
+
+  @copyright
+  INTEL CONFIDENTIAL
+  Copyright 2018 - 2019 Intel Corporation. <BR>
+
+  The source code contained or described herein and all documents related to the
+  source code ("Material") are owned by Intel Corporation or its suppliers or
+  licensors. Title to the Material remains with Intel Corporation or its suppliers
+  and licensors. The Material may contain trade secrets and proprietary    and
+  confidential information of Intel Corporation and its suppliers and licensors,
+  and is protected by worldwide copyright and trade secret laws and treaty
+  provisions. No part of the Material may be used, copied, reproduced, modified,
+  published, uploaded, posted, transmitted, distributed, or disclosed in any way
+  without Intel's prior express written permission.
+
+  No license under any patent, copyright, trade secret or other intellectual
+  property right is granted to or conferred upon you by disclosure or delivery
+  of the Materials, either expressly, by implication, inducement, estoppel or
+  otherwise. Any license under such intellectual property rights must be
+  express and approved by Intel in writing.
+
+  Unless otherwise agreed by Intel in writing, you may not remove or alter
+  this notice or any other notice embedded in Materials by Intel or
+  Intel's suppliers or licensors in any way.
+**/
+
+
+#define MAX_QWordMemory  0xFFFFFFFFFF
+
+
+
diff --git a/TestPkg/FakeBinary/FakeBinary.inf b/TestPkg/FakeBinary/FakeBinary.inf
new file mode 100644
index 0000000000..fd6b499030
--- /dev/null
+++ b/TestPkg/FakeBinary/FakeBinary.inf
@@ -0,0 +1,29 @@
+## @file
+#  The default logo bitmap picture shown on setup screen, which is corresponding to gEfiDefaultBmpLogoGuid.
+#
+#  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+#  Copyright (c) 2020, Hewlett Packard Enterprise Development LP. All rights reserved.<BR>
+
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = FakeBinary
+  MODULE_UNI_FILE                = FakeBinary.uni
+  FILE_GUID                      = 7BB24689-61AB-11D5-9A5D-0090DE4CC14D
+  MODULE_TYPE                    = USER_DEFINED
+  VERSION_STRING                 = 1.0
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 EBC ARM AARCH64 RISCV64
+#
+
+[Binaries.X64]
+  BIN|FakeBinary.txt|*
+
diff --git a/TestPkg/FakeBinary/FakeBinary.txt b/TestPkg/FakeBinary/FakeBinary.txt
new file mode 100644
index 0000000000..fa13c1a8a7
--- /dev/null
+++ b/TestPkg/FakeBinary/FakeBinary.txt
@@ -0,0 +1 @@
+This is a fake binary file.
\ No newline at end of file
diff --git a/TestPkg/FakeBinary/FakeBinary.uni b/TestPkg/FakeBinary/FakeBinary.uni
new file mode 100644
index 0000000000..266c0d5d92
--- /dev/null
+++ b/TestPkg/FakeBinary/FakeBinary.uni
@@ -0,0 +1,16 @@
+// /** @file
+// The default logo bitmap picture shown on setup screen, which is corresponding to gEfiDefaultBmpLogoGuid.
+//
+// This module provides the default logo bitmap picture shown on setup screen, which corresponds to gEfiDefaultBmpLogoGuid.
+//
+// Copyright (c) 2006 - 2014, Intel Corporation. All rights reserved.<BR>
+//
+// SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+// **/
+
+
+#string STR_MODULE_ABSTRACT             #language en-US "Provides the default logo bitmap picture shown on setup screen, which corresponds to gEfiDefaultBmpLogoGuid"
+
+#string STR_MODULE_DESCRIPTION          #language en-US "This module provides the default logo bitmap picture shown on setup screen, which corresponds to gEfiDefaultBmpLogoGuid."
+
diff --git a/TestPkg/FakeEmuSec/Ia32/FakeTest.h b/TestPkg/FakeEmuSec/Ia32/FakeTest.h
new file mode 100644
index 0000000000..596dc52a3f
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Ia32/FakeTest.h
@@ -0,0 +1,10 @@
+/** @file
+
+For a test
+
+Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define testaddr1 12
\ No newline at end of file
diff --git a/TestPkg/FakeEmuSec/Ia32/FakeTest.i b/TestPkg/FakeEmuSec/Ia32/FakeTest.i
new file mode 100644
index 0000000000..a9b3481d7a
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Ia32/FakeTest.i
@@ -0,0 +1,10 @@
+/** @file
+
+For a test
+
+Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define testaddr2 16
\ No newline at end of file
diff --git a/TestPkg/FakeEmuSec/Ia32/FakeTest.inc b/TestPkg/FakeEmuSec/Ia32/FakeTest.inc
new file mode 100644
index 0000000000..b285a3bfcd
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Ia32/FakeTest.inc
@@ -0,0 +1,14 @@
+;%HEADER%
+;/** @file
+;  Macros to work around lack of Apple support for LDR register, =expr
+;
+;  Copyright (c) 2009, Apple Inc. All rights reserved.<BR>
+;  Copyright (c) 2011-2012, ARM Ltd. All rights reserved.<BR>
+;
+;  SPDX-License-Identifier: BSD-2-Clause-Patent
+;
+;**/
+
+#define testaddr0 8
+ 
+END
diff --git a/TestPkg/FakeEmuSec/Ia32/ForAddTest.asm b/TestPkg/FakeEmuSec/Ia32/ForAddTest.asm
new file mode 100644
index 0000000000..f936352247
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Ia32/ForAddTest.asm
@@ -0,0 +1,20 @@
+;------------------------------------------------------------------------------
+;
+; Copyright (c) 2007 - 2012, Intel Corporation. All rights reserved.<BR>
+; SPDX-License-Identifier: BSD-2-Clause-Patent
+;
+; Module Name:
+;
+;   Stack.asm
+;
+; Abstract:
+;
+;   Switch the stack from temporary memory to permanent memory.
+;
+;------------------------------------------------------------------------------
+
+    mov   eax, ebp
+    sub   eax, ebx
+    add   eax, ecx
+    mov   ebp, eax                ; From now, ebp is pointed to permanent memory
+
diff --git a/TestPkg/FakeEmuSec/Ia32/SwitchRam.S b/TestPkg/FakeEmuSec/Ia32/SwitchRam.S
new file mode 100644
index 0000000000..9fe58c7df1
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Ia32/SwitchRam.S
@@ -0,0 +1,89 @@
+#------------------------------------------------------------------------------
+#
+# Copyright (c) 2007, Intel Corporation. All rights reserved.<BR>
+# SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+# Module Name:
+#
+#   Stack.asm
+#
+# Abstract:
+#
+#   Switch the stack from temporary memory to permanent memory.
+#
+#------------------------------------------------------------------------------
+
+ .text
+
+
+//------------------------------------------------------------------------------
+// VOID
+// EFIAPI
+// SecSwitchStack (
+//   UINT32   TemporaryMemoryBase,
+//   UINT32   PermenentMemoryBase
+//   )//
+//------------------------------------------------------------------------------
+ASM_GLOBAL ASM_PFX(SecSwitchStack)
+ASM_PFX(SecSwitchStack):
+#
+# Save three register: eax, ebx, ecx
+#
+    push  %eax
+    push  %ebx
+    push  %ecx
+    push  %edx
+
+#
+# !!CAUTION!! this function address's is pushed into stack after
+# migration of whole temporary memory, so need save it to permanent
+# memory at first!
+#
+
+    movl  20(%esp), %ebx            # Save the first parameter
+    movl  24(%esp), %ecx            # Save the second parameter
+
+#
+# Save this function's return address into permanent memory at first.
+# Then, Fixup the esp point to permanent memory
+#
+
+    movl  %esp, %eax
+    subl  %ebx, %eax
+    addl  %ecx, %eax
+    movl  (%esp), %edx                 # copy pushed register's value to permanent memory
+    movl  %edx, (%eax)
+    movl  4(%esp), %edx
+    movl  %edx, 4(%eax)
+    movl  8(%esp), %edx
+    movl  %edx, 8(%eax)
+    movl  12(%esp), %edx
+    movl  %edx, 12(%eax)
+    movl  16(%esp), %edx
+    movl  %edx, 16(%eax)
+    movl  %eax, %esp                   # From now, esp is pointed to permanent memory
+
+#
+# Fixup the ebp point to permanent memory
+#
+#ifndef __APPLE__
+    movl   %ebp, %eax
+    subl   %ebx, %eax
+    addl   %ecx, %eax
+    movl   %eax, %ebp                  # From now, ebp is pointed to permanent memory
+
+#
+# Fixup callee's ebp point for PeiDispatch
+#
+    movl   (%ebp), %eax
+    subl   %ebx, %eax
+    addl   %ecx, %eax
+    movl   %eax, (%ebp)                # From now, Temporary's PPI caller's stack is in permanent memory
+#endif
+
+    pop   %edx
+    pop   %ecx
+    pop   %ebx
+    pop   %eax
+    ret
+
diff --git a/TestPkg/FakeEmuSec/Ia32/SwitchRam.asm b/TestPkg/FakeEmuSec/Ia32/SwitchRam.asm
new file mode 100644
index 0000000000..54936d9477
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Ia32/SwitchRam.asm
@@ -0,0 +1,88 @@
+;------------------------------------------------------------------------------
+;
+; Copyright (c) 2007 - 2012, Intel Corporation. All rights reserved.<BR>
+; SPDX-License-Identifier: BSD-2-Clause-Patent
+;
+; Module Name:
+;
+;   Stack.asm
+;
+; Abstract:
+;
+;   Switch the stack from temporary memory to permanent memory.
+;
+;------------------------------------------------------------------------------
+#include "FakeTest.h"
+#include "FakeTest.i"
+#include "FakeTest.inc"
+    .586p
+    .model  flat,C
+    .code
+;------------------------------------------------------------------------------
+; VOID
+; EFIAPI
+; SecSwitchStack (
+;   UINT32   TemporaryMemoryBase,
+;   UINT32   PermenentMemoryBase
+;   );
+;------------------------------------------------------------------------------
+SecSwitchStack   PROC
+    ;
+    ; Save three register: eax, ebx, ecx
+    ;
+    push  eax
+    push  ebx
+    push  ecx
+    push  edx
+    ;
+    ; !!CAUTION!! this function address's is pushed into stack after
+    ; migration of whole temporary memory, so need save it to permanent
+    ; memory at first!
+    ;
+
+    mov   ebx, [esp + 20]          ; Save the first parameter
+    mov   ecx, [esp + 24]          ; Save the second parameter
+
+    ;
+    ; Save this function's return address into permanent memory at first.
+    ; Then, Fixup the esp point to permanent memory
+    ;
+    mov   eax, esp
+    sub   eax, ebx
+    add   eax, ecx
+    mov   edx, dword ptr [esp]         ; copy pushed register's value to permanent memory
+    mov   dword ptr [eax], edx
+    mov   edx, dword ptr [esp + 4]
+    mov   dword ptr [eax + 4], edx
+    mov   edx, dword ptr [esp + testaddr0]
+    mov   dword ptr [eax + testaddr0], edx
+    mov   edx, dword ptr [esp + testaddr1]
+    mov   dword ptr [eax + testaddr1], edx
+    mov   edx, dword ptr [esp + testaddr2]    ; Update this function's return address into permanent memory
+    mov   dword ptr [eax + testaddr2], edx
+    mov   esp, eax                     ; From now, esp is pointed to permanent memory
+
+    ;
+    ; Fixup the ebp point to permanent memory
+    ;
+    mov   eax, ebp
+    sub   eax, ebx
+    add   eax, ecx
+    mov   ebp, eax                ; From now, ebp is pointed to permanent memory
+
+    ;
+    ; Fixup callee's ebp point for PeiDispatch
+    ;
+    mov   eax, dword ptr [ebp]
+    sub   eax, ebx
+    add   eax, ecx
+    mov   dword ptr [ebp], eax    ; From now, Temporary's PPI caller's stack is in permanent memory
+
+    pop   edx
+    pop   ecx
+    pop   ebx
+    pop   eax
+    ret
+SecSwitchStack   ENDP
+
+    END
diff --git a/TestPkg/FakeEmuSec/Ia32/TempRam.c b/TestPkg/FakeEmuSec/Ia32/TempRam.c
new file mode 100644
index 0000000000..d6621960e2
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Ia32/TempRam.c
@@ -0,0 +1,59 @@
+/*++ @file
+  Temp RAM PPI
+
+Copyright (c) 2011, Apple Inc. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <PiPei.h>
+#include <Library/DebugLib.h>
+#include <Library/BaseMemoryLib.h>
+
+#include <Ppi/TemporaryRamSupport.h>
+
+VOID
+EFIAPI
+SecSwitchStack (
+  UINT32   TemporaryMemoryBase,
+  UINT32   PermenentMemoryBase
+  );
+
+
+EFI_STATUS
+EFIAPI
+SecTemporaryRamSupport (
+  IN CONST EFI_PEI_SERVICES   **PeiServices,
+  IN EFI_PHYSICAL_ADDRESS     TemporaryMemoryBase,
+  IN EFI_PHYSICAL_ADDRESS     PermanentMemoryBase,
+  IN UINTN                    CopySize
+  )
+{
+  //
+  // Migrate the whole temporary memory to permanent memory.
+  //
+  CopyMem (
+    (VOID*)(UINTN)PermanentMemoryBase,
+    (VOID*)(UINTN)TemporaryMemoryBase,
+    CopySize
+    );
+
+  //
+  // SecSwitchStack function must be invoked after the memory migration
+  // immediately, also we need fixup the stack change caused by new call into
+  // permanent memory.
+  //
+  SecSwitchStack ((UINT32) TemporaryMemoryBase, (UINT32) PermanentMemoryBase);
+
+  //
+  // We need *not* fix the return address because currently,
+  // The PeiCore is executed in flash.
+  //
+
+  //
+  // Simulate to invalid temporary memory, terminate temporary memory
+  //
+  //ZeroMem ((VOID*)(UINTN)TemporaryMemoryBase, CopySize);
+
+  return EFI_SUCCESS;
+}
diff --git a/TestPkg/FakeEmuSec/Ia32/Test.asm b/TestPkg/FakeEmuSec/Ia32/Test.asm
new file mode 100644
index 0000000000..bb16a642fb
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Ia32/Test.asm
@@ -0,0 +1,18 @@
+;------------------------------------------------------------------------------
+;
+; Copyright (c) 2007 - 2012, Intel Corporation. All rights reserved.<BR>
+; SPDX-License-Identifier: BSD-2-Clause-Patent
+;
+; Module Name:
+;
+;   Stack.asm
+;
+; Abstract:
+;
+;   Switch the stack from temporary memory to permanent memory.
+;
+;------------------------------------------------------------------------------
+
+#include "SwitchRam.asm"
+
+END
\ No newline at end of file
diff --git a/TestPkg/FakeEmuSec/Ia32/Test_inf.h b/TestPkg/FakeEmuSec/Ia32/Test_inf.h
new file mode 100644
index 0000000000..596dc52a3f
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Ia32/Test_inf.h
@@ -0,0 +1,10 @@
+/** @file
+
+For a test
+
+Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define testaddr1 12
\ No newline at end of file
diff --git a/TestPkg/FakeEmuSec/Sec.c b/TestPkg/FakeEmuSec/Sec.c
new file mode 100644
index 0000000000..b5a4bd2e9b
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Sec.c
@@ -0,0 +1,140 @@
+/*++ @file
+  Stub SEC that is called from the OS application that is the root of the emulator.
+
+  The OS application will call the SEC with the PEI Entry Point API.
+
+Copyright (c) 2011, Apple Inc. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include "Sec.h"
+
+
+
+EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI mSecTemporaryRamSupportPpi = {
+  SecTemporaryRamSupport
+};
+
+
+EFI_PEI_PPI_DESCRIPTOR  gPrivateDispatchTable[] = {
+  {
+    EFI_PEI_PPI_DESCRIPTOR_PPI | EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST,
+    &gEfiTemporaryRamSupportPpiGuid,
+    &mSecTemporaryRamSupportPpi
+  }
+};
+
+
+
+/**
+  The entry point of PE/COFF Image for the PEI Core, that has been hijacked by this
+  SEC that sits on top of an OS application. So the entry and exit of this module
+  has the same API.
+
+  This function is the entry point for the PEI Foundation, which allows the SEC phase
+  to pass information about the stack, temporary RAM and the Boot Firmware Volume.
+  In addition, it also allows the SEC phase to pass services and data forward for use
+  during the PEI phase in the form of one or more PPIs.
+  There is no limit to the number of additional PPIs that can be passed from SEC into
+  the PEI Foundation. As part of its initialization phase, the PEI Foundation will add
+  these SEC-hosted PPIs to its PPI database such that both the PEI Foundation and any
+  modules can leverage the associated service calls and/or code in these early PPIs.
+  This function is required to call ProcessModuleEntryPointList() with the Context
+  parameter set to NULL.  ProcessModuleEntryPoint() is never expected to return.
+  The PEI Core is responsible for calling ProcessLibraryConstructorList() as soon as
+  the PEI Services Table and the file handle for the PEI Core itself have been established.
+  If ProcessModuleEntryPointList() returns, then ASSERT() and halt the system.
+
+  @param SecCoreData  Points to a data structure containing information about the PEI
+                      core's operating environment, such as the size and location of
+                      temporary RAM, the stack location and the BFV location.
+
+  @param PpiList      Points to a list of one or more PPI descriptors to be installed
+                      initially by the PEI core. An empty PPI list consists of a single
+                      descriptor with the end-tag EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST.
+                      As part of its initialization phase, the PEI Foundation will add
+                      these SEC-hosted PPIs to its PPI database such that both the PEI
+                      Foundation and any modules can leverage the associated service calls
+                      and/or code in these early PPIs.
+
+**/
+VOID
+EFIAPI
+_ModuleEntryPoint (
+  IN EFI_SEC_PEI_HAND_OFF   *SecCoreData,
+  IN EFI_PEI_PPI_DESCRIPTOR *PpiList
+  )
+{
+  EFI_STATUS                Status;
+  EFI_PEI_FV_HANDLE         VolumeHandle;
+  EFI_PEI_FILE_HANDLE       FileHandle;
+  VOID                      *PeCoffImage;
+  EFI_PEI_CORE_ENTRY_POINT  EntryPoint;
+  EFI_PEI_PPI_DESCRIPTOR    *Ppi;
+  EFI_PEI_PPI_DESCRIPTOR    *SecPpiList;
+  UINTN                     SecReseveredMemorySize;
+  UINTN                     Index;
+  EFI_PEI_PPI_DESCRIPTOR    PpiArray[10];
+
+  EMU_MAGIC_PAGE()->PpiList = PpiList;
+  ProcessLibraryConstructorList ();
+
+  DEBUG ((EFI_D_ERROR, "SEC Has Started\n"));
+
+  //
+  // Add Our PPIs to the list
+  //
+  SecReseveredMemorySize = sizeof (gPrivateDispatchTable);
+  for (Ppi = PpiList, Index = 1; ; Ppi++, Index++) {
+    SecReseveredMemorySize += sizeof (EFI_PEI_PPI_DESCRIPTOR);
+
+    if ((Ppi->Flags & EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST) == EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST) {
+      // Since we are appending, need to clear out previous list terminator.
+      Ppi->Flags &= ~EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST;
+      break;
+    }
+  }
+
+  // Keep everything on a good alignment
+  SecReseveredMemorySize = ALIGN_VALUE (SecReseveredMemorySize, CPU_STACK_ALIGNMENT);
+
+#if 0
+  // Tell the PEI Core to not use our buffer in temp RAM
+  SecPpiList = (EFI_PEI_PPI_DESCRIPTOR *)SecCoreData->PeiTemporaryRamBase;
+  SecCoreData->PeiTemporaryRamBase = (VOID *)((UINTN)SecCoreData->PeiTemporaryRamBase + SecReseveredMemorySize);
+  SecCoreData->PeiTemporaryRamSize -= SecReseveredMemorySize;
+#else
+  //
+  // When I subtrack from SecCoreData->PeiTemporaryRamBase PEI Core crashes? Either there is a bug
+  // or I don't understand temp RAM correctly?
+  //
+
+  SecPpiList = &PpiArray[0];
+  ASSERT (sizeof (PpiArray) >= SecReseveredMemorySize);
+#endif
+  // Copy existing list, and append our entries.
+  CopyMem (SecPpiList, PpiList, sizeof (EFI_PEI_PPI_DESCRIPTOR) * Index);
+  CopyMem (&SecPpiList[Index], gPrivateDispatchTable, sizeof (gPrivateDispatchTable));
+
+  // Find PEI Core and transfer control
+  VolumeHandle = (EFI_PEI_FV_HANDLE)(UINTN)SecCoreData->BootFirmwareVolumeBase;
+  FileHandle   = NULL;
+  Status = PeiServicesFfsFindNextFile (EFI_FV_FILETYPE_PEI_CORE, VolumeHandle, &FileHandle);
+  ASSERT_EFI_ERROR (Status);
+
+  Status = PeiServicesFfsFindSectionData (EFI_SECTION_PE32, FileHandle, &PeCoffImage);
+  ASSERT_EFI_ERROR (Status);
+
+  Status = PeCoffLoaderGetEntryPoint (PeCoffImage, (VOID **)&EntryPoint);
+  ASSERT_EFI_ERROR (Status);
+
+  // Transfer control to PEI Core
+  EntryPoint (SecCoreData, SecPpiList);
+
+  // PEI Core never returns
+  ASSERT (FALSE);
+  return;
+}
+
+
diff --git a/TestPkg/FakeEmuSec/Sec.h b/TestPkg/FakeEmuSec/Sec.h
new file mode 100644
index 0000000000..7a1ddacd86
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Sec.h
@@ -0,0 +1,45 @@
+/*++ @file
+  Stub SEC that is called from the OS application that is the root of the emulator.
+
+  The OS application will call the SEC with the PEI Entry Point API.
+
+Copyright (c) 2011, Apple Inc. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __SEC_H___
+#define __SEC_H___
+
+
+#include <PiPei.h>
+#include <Library/EmuMagicPageLib.h>
+#include <Library/DebugLib.h>
+#include <Library/PeiServicesLib.h>
+#include <Library/PeCoffGetEntryPointLib.h>
+#include <Library/BaseMemoryLib.h>
+
+#include <Ppi/TemporaryRamSupport.h>
+
+
+//
+// I think this should be defined in a MdePkg include file?
+//
+VOID
+EFIAPI
+ProcessLibraryConstructorList (
+  VOID
+  );
+
+EFI_STATUS
+EFIAPI
+SecTemporaryRamSupport (
+  IN CONST EFI_PEI_SERVICES   **PeiServices,
+  IN EFI_PHYSICAL_ADDRESS     TemporaryMemoryBase,
+  IN EFI_PHYSICAL_ADDRESS     PermanentMemoryBase,
+  IN UINTN                    CopySize
+  );
+
+
+#endif
+
diff --git a/TestPkg/FakeEmuSec/Sec.inf b/TestPkg/FakeEmuSec/Sec.inf
new file mode 100644
index 0000000000..fca34194ad
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Sec.inf
@@ -0,0 +1,52 @@
+## @file
+# Entry Point of Emu Emulator
+#
+# Main executable file of Unix Emulator that loads PEI core after initialization finished.
+# Portions copyright (c) 2011, Apple Inc. All rights reserved.<BR>
+# Copyright (c) 2012, Intel Corporation. All rights reserved.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = EmuSec
+  FILE_GUID                      = BCAF98C9-22B0-3B4F-9CBD-C8A6B4DBCEE9
+  MODULE_TYPE                    = SEC
+  VERSION_STRING                 = 1.0
+
+
+[Sources]
+  Sec.c
+
+[Sources.X64]
+  X64/SwitchRam.asm
+  X64/SwitchRam.S
+
+[Sources.IA32]
+  Ia32/TempRam.c
+  Ia32/SwitchRam.asm
+  Ia32/Test.asm
+  Ia32/SwitchRam.S
+  Ia32/FakeTest.h
+  Ia32/FakeTest.i
+  Ia32/FakeTest.inc
+
+[Packages]
+  MdePkg/MdePkg.dec
+  EmulatorPkg/EmulatorPkg.dec
+
+[LibraryClasses]
+  DebugLib
+  PeCoffGetEntryPointLib
+  PeiServicesLib
+  PpiListLib
+  BaseMemoryLib
+
+[Ppis]
+  gEfiTemporaryRamSupportPpiGuid
+
+[Pcd]
+  gEmulatorPkgTokenSpaceGuid.PcdPeiServicesTablePage
diff --git a/TestPkg/FakeEmuSec/X64/SwitchRam.S b/TestPkg/FakeEmuSec/X64/SwitchRam.S
new file mode 100644
index 0000000000..4225a74cd6
--- /dev/null
+++ b/TestPkg/FakeEmuSec/X64/SwitchRam.S
@@ -0,0 +1,66 @@
+#------------------------------------------------------------------------------
+#
+# Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+# Portions copyright (c) 2011, Apple Inc. All rights reserved.
+# SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+#------------------------------------------------------------------------------
+
+
+
+//  EFI_STATUS
+//  EFIAPI
+//  SecTemporaryRamSupport (
+//    IN CONST EFI_PEI_SERVICES   **PeiServices,         // %rcx
+//    IN EFI_PHYSICAL_ADDRESS     TemporaryMemoryBase,   // %rdx
+//    IN EFI_PHYSICAL_ADDRESS     PermanentMemoryBase,   // %r8
+//    IN UINTN                    CopySize               // %r9
+//    )
+//
+ASM_GLOBAL ASM_PFX(SecTemporaryRamSupport)
+ASM_PFX(SecTemporaryRamSupport):
+  // Adjust callers %rbp to account for stack move
+  subq    %rdx, %rbp     // Calc offset of %rbp in Temp Memory
+  addq    %r8,  %rbp     // add in permanent base to offset
+
+  pushq   %rbp           // stack frame is for the debugger
+  movq    %rsp, %rbp
+
+  pushq   %rdx          // Save TemporaryMemoryBase
+  pushq   %r8           // Save PermanentMemoryBase
+  pushq   %r9           // Save CopySize
+
+  //
+  // Copy all of temp RAM to permanent memory, including stack
+  //
+  // CopyMem (PermanentMemoryBase, TemporaryMemoryBase, CopySize);
+  //          %rcx,                %rdx,                %r8
+  movq    %r8,  %rcx    // Shift arguments
+  movq    %r9,  %r8
+  subq    $0x28, %rsp   // Allocate register spill area & 16-byte align stack
+  call    ASM_PFX(CopyMem)
+  // Temp mem stack now copied to permanent location. %esp still in temp memory
+  addq    $0x28, %rsp
+
+  popq    %r9           // CopySize (old stack)
+  popq    %r8           // PermanentMemoryBase (old stack)
+  popq    %rdx          // TemporaryMemoryBase (old stack)
+
+  movq    %rsp, %rcx    // Move to new stack
+  subq    %rdx, %rcx    // Calc offset of stack in Temp Memory
+  addq    %r8,  %rcx    // Calc PermanentMemoryBase address
+  movq    %rcx, %rsp    // Update stack
+  // Stack now points to permanent memory
+
+  // ZeroMem (TemporaryMemoryBase /* rcx */, CopySize /* rdx */);
+  movq    %rdx, %rcx
+  movq    %r9,  %rdx
+  subq    $0x28, %rsp   // Allocate register spill area & 16-byte align stack
+  call    ASM_PFX(ZeroMem)
+  addq    $0x28, %rsp
+
+  // This data comes off the NEW stack
+  popq    %rbp
+  ret
+
+
diff --git a/TestPkg/FakeEmuSec/X64/SwitchRam.asm b/TestPkg/FakeEmuSec/X64/SwitchRam.asm
new file mode 100644
index 0000000000..3a724360ef
--- /dev/null
+++ b/TestPkg/FakeEmuSec/X64/SwitchRam.asm
@@ -0,0 +1,70 @@
+;------------------------------------------------------------------------------
+;
+; Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<BR>
+; Portions copyright (c) 2011, Apple Inc. All rights reserved.
+; SPDX-License-Identifier: BSD-2-Clause-Patent
+;
+;------------------------------------------------------------------------------
+
+EXTERN CopyMem:PROC
+EXTERN ZeroMem:PROC
+
+    .code
+
+;------------------------------------------------------------------------------
+;  EFI_STATUS
+;  EFIAPI
+;  SecTemporaryRamSupport (
+;    IN CONST EFI_PEI_SERVICES   **PeiServices,         // %rcx
+;    IN EFI_PHYSICAL_ADDRESS     TemporaryMemoryBase,   // %rdx
+;    IN EFI_PHYSICAL_ADDRESS     PermanentMemoryBase,   // %r8
+;    IN UINTN                    CopySize               // %r9
+;    )
+;------------------------------------------------------------------------------
+SecTemporaryRamSupport PROC
+  ; Adjust callers %rbp to account for stack move
+  sub     rbp, rdx      ; Calc offset of %rbp in Temp Memory
+  add     rbp, r8       ; add in permanent base to offset
+
+  push    rbp           ; stack frame is for the debugger
+  mov     rbp, rsp
+
+  push    rdx           ; Save TemporaryMemoryBase
+  push    r8            ; Save PermanentMemoryBase
+  push    r9            ; Save CopySize
+
+  ;
+  ; Copy all of temp RAM to permanent memory, including stack
+  ;
+  ; CopyMem (PermanentMemoryBase, TemporaryMemoryBase, CopySize);
+  ;          %rcx,                %rdx,                %r8
+  mov     rcx, r8       ; Shift arguments
+  mov     r8, r9
+  sub     rsp, 028h     ; Allocate register spill area & 16-byte align stack
+  call    CopyMem
+  ; Temp mem stack now copied to permanent location. %esp still in temp memory
+  add     rsp, 028h
+
+  pop     r9            ; CopySize (old stack)
+  pop     r8            ; PermanentMemoryBase (old stack)
+  pop     rdx           ; TemporaryMemoryBase (old stack)
+
+  mov     rcx, rsp      ; Move to new stack
+  sub     rcx, rdx      ; Calc offset of stack in Temp Memory
+  add     rcx, r8       ; Calc PermanentMemoryBase address
+  mov     rsp, rcx      ; Update stack
+  ; Stack now points to permanent memory
+
+  ; ZeroMem (TemporaryMemoryBase /* rcx */, CopySize /* rdx */);
+  mov     rcx, rdx
+  mov     rdx, r9
+  sub     rsp, 028h     ; Allocate register spill area & 16-byte align stack
+  call    ZeroMem
+  add     rsp, 028h
+
+  ; This data comes off the NEW stack
+  pop     rbp
+  ret
+SecTemporaryRamSupport ENDP
+
+  END
diff --git a/TestPkg/FakeEmuSec/X64/Test_Inf.h b/TestPkg/FakeEmuSec/X64/Test_Inf.h
new file mode 100644
index 0000000000..fe33bc6e7c
--- /dev/null
+++ b/TestPkg/FakeEmuSec/X64/Test_Inf.h
@@ -0,0 +1,11 @@
+/*++ @file
+  Stub SEC that is called from the OS application that is the root of the emulator.
+
+  The OS application will call the SEC with the PEI Entry Point API.
+
+Copyright (c) 2011, Apple Inc. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define testaddr1 028h
diff --git a/TestPkg/FakeLogo/HaveATest.jpg b/TestPkg/FakeLogo/HaveATest.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..b0ee419721ad19e926cddf1347667ac57ae70b37
GIT binary patch
literal 31331
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%0AL(38W
zpN+cS*5<~62@9dvW{?3%jcDzW?JRGLlsiz_aLL2k(f+K%VgNfqmnqd3*7aA32w0Zu
zn2$lDXZZ7=S4@OnZ-&W!9p;RpSv(RxU5U!|nxCw-XZLC_h|?{+s8#%Zva*~8pVDq!
zWHa91?ri96O0z8Ku!Ycv>%^vN%x=srG@lF!B3t$4g^*9U9cE_%q(7Y1UVxVa@v#q=
zI^l9}DK+Q>!Mwt}NMjAml)~i!n~an%4>_!x4+M-HQo}{qV@K+KS}P9D?Wl^&{;qJl
z&3UV|m+F5?ni955hHdh@Z#F+(zGBSEwBOU(dd@wv^X<$^Ej^dk=zV#XV4E*Y6jLDt
zd#5oDBvx<ndCJEQ#E>5`ARxJ7&GnU#P>^|HtAk5(13ei%&DR>qf`F~_QShb2z1$p!
zAZG1n;n17hck-5wxazCrff)M7FIR{i=e2ve;m!?NZRejx?!F1~+vP~KO$r^hFsOqz
zjK8sOPzGXQA{peAZfIQaY4qR>QgSJ=d+#|cUO)jDe7uGj8yF%WS&e@e*`~&l+?k=7
zei}utgabP@WpI%!6n`BiT^>h^^f*kcM#xtGLlUr9XV}kG-lKk-sSCtOe;L&>W@2W9
zRTMPIevNW=VbYYZX1x|ga@jz>WE+jzdG7WyabZFSs{&@RB}JgFOvTEhglLG#K|~&h
z&UN^4Z@zuS!)#bv-_FO~)WP5@3XHa@=7d^QE>my^u!Dz7%~Y~tMi!Hb#$S)-OWy!Y
znf{>_FBplWgEQg@s&&hXvXy5Tc|U#hH)So_CTpnAS8yS;-1a!v5t6Kdf3Jx9kx`Ns
z*qKLRH{)1V$HpKntu<(yhl8wc<U@*-J)wrLXs7lvX2G;bXF)7zk(~{KqUnQ9d8S)c
z@jadC-m0M<cYeLK4ZTd7iflT=7oNw=E@L8g>IO!)t?i!-DyCl(XYpwdd0$w&ej^kT
zbZkzob)9TI$Q<sEjVUU?WI!JXU#(h~mYM7f%vf`!5%3Doo>ku5CGAPCn*bs3X!;v3
zpS*E@s%=-nh^Q|(+Rn2<#swZO^!eHR5P=Hew@eq=T#NQXtG8N(bJ2Fj5M9-3nQ@YZ
z6JSVP0X~!KtUG(k-s#AyhGlD0V<^tlvy~An%#qt?7?|e;)-v+H;Txt7yP1$3*v<&k
zC@GtT4tiU|3U_{D9>0|WxIrpj)z?~E@0KQ+FefT%i1NC;J@cb){z=b^WS9Q>2VDg>
zKXWZ+6dHkgNiy)JW?u-1hyVBw*fj4|Ok<Kw7VX)CGZxiF)nUr4%~Y}vRRbkRGg~uR
zX*V`;v|@pM><cogl8uw0j-#D#ozv`wJsL&Jb2nRI(Rp41o5ef|@4$&{abS>mS@x{6
z(TxEF02#_Wf8EWaX36aKYd@k<;cMNIh@(q$a^)9iC$=ia&RnC$NxgSqZ)GM<u2ACO
z3K>g5V}bKuya8O+THeV$ec>WqY8?iB4*U4K_!1MRl2v8yKsan=FX!BigD!ZJR5IN9
zogLY2*lY`>@sMU)rMkX1=+wO1m%Bu*Uy#)#X4qT-|9I5cE7Xl0N*21}C9#}v*r_f}
z-(Xp4k%bS##2<Q?y!Xgt9#KU8bk>$$6_YQqmRO;*02FbJEpV>iItcScY2ZLugK28B
z=Af>AcqytA;<g6G!aPm;@{%DvfhM@CAKlREUL_@bumZvOy2NaMX<sQ65jc-ucOIW2
zm`AlQmHJvL$dQ8LnEKgy^<RwlSBgBW{8Ec0AY?_AfZ3`?U~A_g6xzGA{~M5|0(oPK
z&DGPWkKa)wP=yuc?IthIodiQC4n>a`xGNyJ4Lys})g|~p%y?u5K$)sV1oHbNl%)t*
z??1`~eBoPHGh1@zdyxN&!7|$sSAt~k#X}X|&qAf6&i>xdoON?@8lkFBP@+0*jdflG
zQ__tn-;7|nxQEhFKsyh02Uj&P)}pCFP7WLDYAb|kAYDwbk3JcBNp+%n!zOAnWMzwA
z6w$+0#HgZ2^|EzXn%YY#>T#b55==1{`}{W%DxK=2r!AJV(R-nvo?CE8M}|s~*mLuf
zIB(jKH_*&S>A>Z^yy<=UD?)hBd|nu{&Kz)bPJR$vBeUd+%P7U>dOI}UHpZVKu$)x7
zIBgFFCTc|I_LjLz(J?9q=P<-9KLr#JuFz8q^RH0s;&tCRcoT`8EnWx%m_JXcZtr{W
z7j2%-?M&vjx8Banj9~!CMdc{n8{+tyG^#SZTnp(elmvwZf6N>e(W&)3w_?T`8Z*uF
z8+VtsMm5eXRdeX=8jS}{&p&OMp&GPwCg38)uE&t(;cQEl%Za01%_{ITN&19*x+i4?
zO{VzN6+hQ&Dk{KkxvpS=R`lJ}dtLvKobvjM@vMS;m90T}MpixFv#|vNkEKM#zj)?1
z7RtEHywau4@LQd4ay74M@0LDZ@CnWKWBnsE3;?h1onT%{)L${w$fPqjtmr@2Y5d#>
zb2K-NtehcIpJ#m#B{2u&pFpensDJ34x_BM|nmW%>#zf4_!DwP@=JUxwq>@f`akp)?
zUFOA58pQr1IOF7*BY*amTSQE-f`_KsJiy{8&&)v4PzJI6BTL9hq@VgJhhb3^nV+Rl
z289q!G9hO?HehV|y(6*dbQq^xt4UA)_w^d^tEo@?PV`wNYI#Ea9DYaPzXV{XududD
zEM6`tU5@v>q&)@)+0uxqVEPo@|C!hImGnabBqgkWav2}A;fgd5clgN1rc^~*{WLZ<
z?dK8jU8U2VT)Jq1yrokK^~IBXt>VwawlnhaA--G%Zyc0yr5oX0Ing5BAM{(9<MBvi
zrWySKR;pq{wU17P^>2zSN`t%H^{;F1T4s;!=RJ?I#eXqPnDOY1iWTu(xL{y?x#3~n
zM3jy;vT9bff4K~|Er-gfzYAg;{YoD>VvSY{Jj>~LXD??+;V|R5Gvh6OeMC`zI0?vn
z9HQoV$a5U4^rD$5WA-lw)kTk$nUPoJ@_SDE6~6f8y!)wVcQc<T0uj8qlR@wcVWa(3
z?Zd}S7?zgmE12}`@3&U&d9H>MB~&GBm=H0gbeeVwq<rSYW%IZ}oQVx-OHa6qs7h>z
zs)LI+q>D@bkJK}_k4)5d@~>ZjCdclmiA0A;m4G=hglb>5AhT7YsN#>y%lC*`HRjx~
ze0ufp#*nH;8+;m?P+l5yWUa9+`@mzO;zn0ggMd$%=_E-)ZOEt^c|K`;aR6s6T6IXA
zU_G;DeOcWkpAyipAN!xnH?<)`W#XTd0{Y-({_LJ^9L{j);=%dk%zDc|q%)zKPxKMx
z*M3qDgry*BAd6@$fRorvFh5lHxnTs`vis})oIEl{@tQvtwh^#3n^3C3VAL6?Z0!9`
zIt{0Az{GWEf{-wKn;P0u!4TYa)A&@*f#LVr0C;DV*%z#Nao&FF&fe20_WFaysQ2aO
z)DIU+<oSdU8=DL^Pmh(D@z1>XzRx<H?L2}vvtv3|N>jf<BNUHK_-yI<Jqkzy)4)VO
zHP4!1gXWGO-vtKp&=0+eT$u-~8pO^`dj*HyYfA0TWIjp?7NQ+p!4>nx9G{UQC18`N
z1^GJUxSb?Ll+4o-9tf7VX_YvWf%n2m052XO*Q4eJJaTDz#=%Q5VU!Z`CY8jkw|OO(
zIya_zxaA2H)(a|%+ApJ5z%cNjU(TM9=LQNfcmDHLOY$iLJ8No)voDi>^6>ERmq9!{
zaEko?7@@3_>7gj>FNR*haQ*p<w@j8PB!lXNh!Gkj#qIlLE7{)tZWof>0tMv*_bk>V
zX)XTJvL$Yq<~Po4Qd8b9msllW<1Qj3<(kc~LS}N}sirhXgN1!Q`NBY-%?g{b-k7Na
z{TSawj4j1<aY9Br(AxnL8fL0FX)Nqn{B#@YtLE35R86vCz%L_nEB|?|@*Ra|T}LMm
z5mbKEgCH#3x1oa~lR0Y~J}wckXw5<Y9Yrt=Al2Le9lvs#a%fmQlzE|rtw_W4K<HMe
z^ML6tVlYXy*Y~dW$O5h5%(%h7jYp%bgM@Y1-ES(h8UOK<NjJf6a!n^;uy{F^Y`u8{
z!&V?BFb`~=Xwa&<l3^?v*a&P*MLxz-R};XG(U36S&G64`oeB^(`-R*0u_-iF%F)X_
zyzrq2ghKFkX8;mIwF(XXNJQ#pcJDuGAUYg#Ob+&pJo4)Mi;=HW$#*Td^7+}MSAZa0
zk+{6D_N;Jed{FXoobv^9xG^~fPZ#)(s8TSy%d>V*sI9Q(^|6tTl;VcjWnu3F>!VL6
zQh5-_y%O2WoW#eg<F~=ZdBee|oQC(PaHu*T;j=vsh<!;C&$BPFOYxb4g#WpPVxVmk
zs@PM#@dj5nW;e$|P7WNkWfYgnixOa(-xmioxnqJH?`xi=DQHlKzu2NNvlP<!<~ZxR
zIx>I{G^N%5f@L5dXO={m%7#yWXBw?<1Hm?wad9UAURDXy|A87#@Zub+;QlKT`XA`>
zMd9w0)8v-9v;?<>KWp*A3t5EF8D8K*;}}9Km9$|9Cy*c%EhtU7opDC;PQ?h8PuI?K
z?{OsQ{}KV?6&z8~Q2^mTo=$q5U;=j&Yml<P&L#f{$?d3Gk0D^;q?@jm11m?ryuYLh
zPJ<17qy>8wr<dyJx8dHmWD7$^;h(hKIveT=b^vi4WHPB<Ov|`RG7e)}I1f8b1=*4-
zT><x`s|w}3g82+}<`%Niw<j!Gyg#G01Tau3?bU{frb*o}IO^Ma-%Tiz<2Hf5Ps&%s
z6d{&nzcl8MsCh*(ri9Q2F4jM3uXroq|7}#;k`<4T@$^*W%jFQV+KU4r<Xes^lrI9o
zXPnyGjnyv)MNWX>qbgawv+@!=-ak3!4iDduue(jIM%ebJF~1P~i-A@Ij~JkzizB8X
zr*Gvme<4V#dP1m-tmS@Xt#Z{Ylc{z2yd_y69qM_OF`EvNJXhNvOm)v}Eohshw*FX?
zT*(YRj^e96Qm^*>nK6C)xp>-YAmfWhf_1k2ilS<C%tyBHFKBHTYCPp$6B#x+O#^P5
zRs89qzR=tbh<~ML``x&~ZpHC_NMfoG`2OH8hC$FuVv`0~v7%_mJ5fg}=&`TXZ}@$C
zU2qt^giTX%7$Jj76f-2!^KLe9poH1>MBDZXO5tUT@)t!EamAzn?!X1^%wB1x+KC}0
z7`F(`+d%1Fnl~Q@%`~1&r1*c46Myy!CNgx-_vzaqReN>7MY$X%;Erh4r$dl>k&j=>
zN2)<#M9$0?X-j9M+T6^p9fgO#N0U^TX^UkwEIL+J|5U^rvK5w*F^Tv|`k}B?_Py=l
zx|8UwxzX;0kT1dScGgH=;Jj{#Sf@hPRLklkglDD>Q;o;)wI4&TlOkUT4k)RjQ1$x5
z!BPEDZE;7UPLfwia7M4|6>)Okpc*0YL+NMI3okLV{X>PDRY9SH&riI<o(7eA_hPRq
zGoaG~ue12IC>MFE4$aF0NH|`4G8s(P!q)ZPjZ>{khCKGg;=^}1hWKeN`zL7>ka5jl
zbmcog=w12h37~GL;oqu&2=q3D?@1QfA$!vPP84Rt5g1*&FF6;Kqn_Xtb7fS(?+2#x
z@+x|1MCKDDgFL~*9{|*47wQeh%LPxabn!)5TmeWgvMnj{!qsab`kD?<cMZ;lp=iTJ
zN9hmoM0|w0k@Pa7B>!EMKBEK5>LXq6Vij;*)8MEVF{J2{6vXe3J4FSAgFs)tOW*c<
zGIvTS`t!Cd(F3NF?4gD&gi-yw#~>%zr?D;YEf``-2g%ZK#G{wM?V=_&h5c`x|L=wG
zK7)_DktM%c_-aE2QFPv1nm-sdxKuiXCX2UZmNS61jwy$b#)9+)tf(sha~p(>X0k^s
z2#JJ}QB}@I=rTW#Up4W-5nZv<@N|F-Qfq!U(z=(yrV*KzDZlVHm#W_Sx_vGi-q5Z{
zdc2xl`8k0ZRv8M1ueY)Mdez&to!5BLt;a=kPgM83f=YX)IBNfLERbKj*5avxG%D}x
zzGnc9x(`O+t)X_g+55jcX89j9k4sZ=8g4(dlO%H-5QjyP@jMz++U#I8TjxQ1EUUvE
zjKzU#NUU{vs~_v#Q#+r}<Ks*3=8>(X@Mlr$Oo2lacVzXNqk5T}wmR}sYW`v*9Nz1B
z(Xa0~Q!cZ1F?%epDwo1vFZVK1>(#Vi94WD0<QnNN)9(52g{AJc8?HfAx5wu>eGNvn
z%|y2iK@{S@f{$C?Z=Ns4{s3Y20#0NeE^MZk={RA)%hzN^56lbxgNrTv!vmko95v#N
z0cn3Q-mnz00nQF{w&F{CH-YPyQWo>DlD^_&@7JM!F^p`#$@Xhu{}lMXzyr)n)f^0?
z8g&yiF<GWISq^Z1W!jpn(g|CwfVv(PSz>cyJzW4Whv1M$%r<i!3C;+66&E>nO-)G{
zf0aC_G1Jb^9k64(OM4mbsylqrzLIM}u56U*caPXN^*iu9wBI=EW>xewwS^yM%7(9K
zg-zRa9}!#QSBUCkV7Pq22xXj<;JIkb;1w?RmH)7B*0@?Xn%{lWiZ#NO6&Om9Que}Y
zE6sAsR&;qAFf&Q5pQWvv(EjpUOc3uK_SS6}QL{NdFhjBI*XcL~1~+#2^S>A#gaemI
z$RwY1KAm4oNyqU<7J%}(GWp2xBZoYqP_JvIY+Ipfc88B?zpXWhPW2l3fmbAp3)dKo
zOMD3x?y^Cpw^J8WXR6Z@I755wNk7?|96`1DkcIP4A3pdGZ5neou=MBjUp;yCnv?xI
z;x07$ww=9E&f(asVtygLth-Pbq{I5;`Wo%2VA>GE1p@<Bs0T5b2mx2jLHCG>u8qb|
zX{fn;8L(GHPk(0_*hU6Q6HVuT0ES_lL`6P5TEJc_ucR}GVYWKBB>Vd5ZF}O4M345E
zPOw)NEm$|#@;!us02qajEsx~+f*3LX`uJi#0t^y`H)J`n>}w~MQ7x6FZQc5T0Gg)E
zIWT+0|G;L<4ldIYHJd8Pyo)?yS@%lhoe;}A>}Zqb_(h8NX=F7YJEs>WOZ1AX@@se9
zDE4w#$=KI3!^Hp!<#CLN3-wV-xkrgHdyn!QiDF(;m_@UH5i$NR=>C_){cqGIqR`x)
zc#1;1Jz1)W78*^{y5`{;Gqp>60w#-%k5?M&g%$WA79!uSzK?Y>;OGgn3?E)RWgJy(
zfV%_l5G?~!6`AawpL1?=WWExg4Ue-bE_Jgw<6RiT!+gSbi=E$u%d+v!A3GDB*>rcm
zmv&YoXo&6tVkVY}sPi5clz1&-iO7GCf4afDoeibY=%_h?w2isK(w407-0*kkQ_Aw<
zm`{|>?q;p81?kJbCj?2Qh@tW@7d0><W}g^Q4zClSRQGF-qkN?AE+1BAe-0X>ru;qm
zS)1p5Q%Z2n#uUQB=7s7>eHPDpJ$<!g6meTCKYZ$$sr9boN^=0wrlAg2&{le<SG~Ip
zTii{-;oYJ3e=$sSLxi*GY;DWe-JZI6-oEpAlyJ`zoNE7sfM;(^)9!i~R=L)3;+1Yw
z^5GBDHWD!P^Gwiw?8;zfyY;hki1~RJWsq=;*w$Z+?bj4;Wm}WqmrvzgB&#bI1tvJ_
zy35kxQG__yv3H>Rx{-zW%4P2-FuJM$LQ6u34qv?CGA4jr8t4}z2D;Syi$T99wXtby
zC-cf7=a)gUIgV^e#_B=DX2G&{8rwT#m{%mWiJjFz5XoqnP(#Mc#^)c1fho{gQbB~H
zw$Cb<bJ)Ay0d}z^isf^J=M&*RnW&wnzTD9;Dy-i=E0j4lC^|2iN7Y4CqnrIQk*UlP
z4wsU$B@8HCSRSRVskHOKxqKx$AYiFjBZC&qTyF%|a@Hh;`?#K1wJm0M%+&Sx#_B4^
zwuS0jFf%)PVNjgek_>$ngG#Sbo_mP|!1*;^3ifHhQoq!G|Ksyi2C1+n>LIy0CAo-;
z_b2(ME$2*UYpHnPYnp?#_}?7#+I)>EQ#vp3u8+;beH=7O_t@fk!dc>KD^F=5Wog*b
zE_Tv9*bJx};1vQWlI84|<Pqo8a#*;@rlWRqExxU}sWMNs2y|>?`=0+EL%wNLrGEn<
zQ0u^Zs<AiTPdBAE)>O4eR<+vACnOvW1nOljL4Ii3)UQcb>i`@Nee7fe@(~fjqoJO2
zXM3A#gGcyK#~72FnlM;4u}@bta%kvv%cobpuA>UNm3sckE!|{T7iJLW91{*f6ijKG
zR1(G#?0_PJ8ql-~{7!7HU82&QUv+&lL3bPYp~i#V)`^=}pl%VBi!IOrz#xzY+}+LY
zW}`r=BZ0{pnh}qm2SjuLpZ?tQs<iI6vb3^4syCSECU%761rOM7sf+$x_8!wyem{++
zr)6}VN@4g-%>wmV+psx<^F4#oU`SEYvvYAG%<OWaGVD?9Cr`+;yK@?HnO2xuwD7Hi
zi#WcM5HR5EMCqa?VwK}rF>9|F4~zQ3BDK9a-ghw}s~Q788fsveQl>489VgQ63`kcC
z_$t6vdRS&M|GjSfzau8$fR@>y<I5N__jD(2h>MBk0C4RiCU|JA>#38EX>jK%->4k$
zxZb~u|0qB8eUKgdBTv(fES~d1@LF|dXorhk5>x-oOVsbsP%z8Xw;*q`HBp`Z(dM>~
z5A9<>=MHQC*OSSYnzIrT-SDSF)Z`zY5Wnzxj`r+x=asDO8qOk!BPqL$(Vlz>c|nVD
zb~WHe@BOon+pDGB$2vlpFavbtNUu5ewCFE}$jv2<S6Ar4w}`7D)!;rEQvm(M56#2V
zh%k_`=j3F?&tJhGyepxWL>u+1wMv`{8WPA_q%>f|4JuMm=I(zd{oxk+DA<>?CD}_A
z@zmmo$A^_{_Pz#gB9%g!Qh4eSd#~mFJ91&GPB!N2lH4fy_j&NRaJAr;&!E~DCTbr9
z)`xG*1(<ar_F>Y$)yjFRK1+r?bkqzWtQY$cV&1jb2YpY`hdE5&*Ef7Lz+s?q_3}m8
zx|2#tqsxq;AB1`L*lLQs&Bd9DIo2^Tc+A0bW|D4*$1+`-BapPGQIn(M6AFAH^#tzY
zM&BTR>fUI8bZx%nS#qzj|J<vw5@`%S|9HtcTz$(}(LoWy$!`#=GucLAvz#pXU5B-3
zO1#4S)erUddnHo8t;5|O@GmYX{mRapmpLKS_H)ygRsJol*+oM^0W*|3A<`qgL<u*<
zVo`Wu6!3K!jLi<t0<lVZw0`zsY>f#u!lEE=#h;#0zuD0$V_A`M?fzy1AH&-&vJfY5
zjK7nH+8K5d`f8&f+M(Pv#dn?@S+(NW?Dp8}T>-&R*c}A&B6M!WA_#TiiMiE7KpQpq
zz;k|hY~pWonG<2P|HSwQ2R>`-%C@49z8H!qeQ!ZbF*aN-q{2<MWw5~ofOo5!{Gubp
z%~8o$yAY>=`3_XcA4cOPL=<}b)#L7{yhp^Qx7?MG-Bl%8eBh}Trp8natlx#F)z7eO
zM81bpE~NClzO+tFF#oc$!h$kdum6#_t8_1$-L}ofSzZ{CfFQq4ELu(Hc`<yef?cdt
z_A4u;wm4l@9N{2BE^?mQ9}|MaN8TWmy+nQM1zM-hf5~%9dWqk;*453YF*{%@XrcLf
zP6Mr_uzOTcYsr@eO0oe4-tZ`=;?ivj1|kWo?>TJmmYV{rgc(GTZ0=Mlqp9zYb|w6s
zMQ;ZAG+hkUVA55dapd`#V$rHP8*h$tV5Q0*Ly9r<-7zZ=EXsyBMQEq+YJ8G4gt3N<
zOfhzg13G;8hZ6ihBjp<s?cDU43K!n@LX{o<o#(x`YF^lI4w25D()C5r%0H%ZTQVDx
zXi<`iPZ%>}msYk4x*8wVcs_fO1OIX+@`7;nvD{yb8?vxJf2L%^$M>X=b&!{xuJ*f?
zQ~mtwYibn75Y`Bhm514omxeo@<E%}q0Z>Vm?<qXhFJB25eL!E4G#)cU4Wic?yw@k7
ziCShFkq+5$-DYb!G_cL**U766tY}b*{B6RAP_5|-XMcaj2#cas)V@Le0likeyb<UO
zJa@Y-Eq=-Ra~QY154w)lVkCI$Tu4CjCDAqaJ+tXj!VFA_TQlYiNFLzziNa!4W?@*H
z&JZAUgxt_hUA91;TN$^!X8h)TqYK<sBolab4Bs7+$Ru>~>d4BR{jPg!ZNXKR!u3r&
z7SmW9xQpb8!hNkRJ!5<6*Wu)=C4`$JC^rp#<mOoLT)4@;Fd7cBTTV<oD7-LTDbx^M
zvUv<yvDT$?UF;zkNqGe}X}n{aJsAYJ#5;)&0u0F}Zs^Ca5L(hrn$7drgct3^1LpE~
zTRVu3u*@(HT~UjuZ{o&cRQ<W1m+A`?vb6;A`=_mKEgozY`#2;U)t(4)90@27KEmDz
zK17~by0a&5d3Bwn#@i%n%Xu8R)}4oY7{32yuKx3hN`o5h+>1|`I9ogzXG7;7#8#oQ
z5So0dA%Xl{QpiL=&vS!LS8k3?Totnb^VYnl+t}E7v4!-5WHgJ68O;v(yuaxJPUWVS
zBvAPw4zEbMmJD9Xw6{M?y9qeh+x1oO!5I21J!(vz?lPoyRSia6Y42ewnFJ^rTb$Rw
zldOywa=#bpZ(rpv82QX|M_fp)eXTU&Z(u!I<6qx2)1x$ZIhQ#vL}$OD!B~>#(#4z?
z22a#7DR~lT=-N5DZgJtAA6bu1hgKS}XQ@r9t7gghs-8LAs81;YDWx|Y6WjmL$h#D4
zlzB7_y=tjFV&X&i{p`Zh^#r<P+FUW9-AKh+T5>n@>uTHo0OpTgoo9>Z77HXfCcen4
z=6or=VBPTe@>-E5*3?fAFs`QyHZ)9q3XTQ|NOvd37*a3!8S}-7Vsz&`qK7Hxq$jop
zF~_~ddQ(Bg%p<{@sezB(V)I6#qrj^xxR~Tr+l7K>)TD8hqcaG-ymK8@cFN+%rio>$
z2<(QiiWuFiXQ=T7z=qHKxwllh;>dJ(eA;mg3&sL>;#_~Fof%uF{~yfz?=r;{QxW(_
z9>Ok7&7M|pD&bWg@9sMKUCTR_eJ8yyZ8zUyW0k)qqJFa#tsTw|OiT3{D$JRK7@@Us
zx<o7ejrCLV33n93)xs^*yG8!Lk^<W;Sv4LXUO0O0e&Jc(sVaeQTMGHvs7>9I$#&Ul
z&(Ae=I!BwSu&(%sogM#PYjW4!*JddnM-KGBHN3c%t1L<wIFyw9Hpp@sV~tjZ3sjd9
z57P=ZR##r<(mqv4S3OWzm(cMIbS-H>G^(aP7_en08rXqG@ad0HyFGS!a_a7OTer^%
z-2Y<G^51}<s_!8qmeKgj^w(z~_);}(%=(2wQZm+M;B>v`q4<rkH@D%Cvqoj}(P}CX
zBhtY}CTpf_TZ?htH7>*}(ya;@`QwKz`cnRJI5)9+OyuaP+`RXb5%(X+SVN=Rd~zWn
z2fw$|CFsf#lt9P*I|(;~ob(VuVqaUmmOGLfE#9S5-ExfyQB5`))m))HUy85mrYXK0
z(ziN}nTl<<GgW^&NuLvq#i42#;+0_P*5DzWg1($5;#Dc$f=fT(;$B>xaJ#0dLt6fz
zj#Tvz0$oO0r&@P`XG<k|3a;rno8$UfCt1~=Erlmtp;BFOCM3b_nq?-jX$9Y9h5@K(
zbn5yO37r#s`N9_Zu4cil^>i!&GaK`p^;e7)h6I}ixdcN(B99!|;G@r|CCk>6<e-hq
z8o}<YdpSRGU;3}BDoPm1E3#o*L=l+vdB%E1<E*t8J_!1c*gPEr?iT3o62S2fk)#)E
z&HDr{=;>~5oA#Oz5E1wOUiQ$+DGj*4!!(1mo)S~PUWLM0=3-qPJ~uw2vQqXfp8W1h
z8<HLB?NGRw^=T;|3c3<sYF7hxj+M^d#yvDt^<Vx99-cFb|BDevlxezr`C{cayb!N>
zfO=Y2*~+Cjf=!3b(mFtG?t=$2vdUJ~DefKL(>EAoU<fhmMV1C|Re?+;9w&x69zZd`
z7^i9!RYZ)T=*|GAFn8TSXl~}QC1QT@aVOLe<ko+p+(0UiP)5Gf8dhu}C{fj<W^=a;
zE)h7;eM2>1Nj^q|0vqGoLvUAj5DS_qVtHwY#)+-U8HfQqn#7MUp}e5PS}nj;k!-KH
zpmRx+Y}5=kOiZN?gPP;bqa2*L!+}RE|38!~k%;P01zVhBjMYgQ=E^*&hwylW<H+e}
z1`+7vwo+IBWtyGq<CpW(NP1;iTF-q`IyV%C?wl|{3t5NDgMn?LbZPHu%GInrV|ne>
z`E-N`nluW1U9G;!0T#U}PSu|A-AK3Ztx7(iR#ud(?4uvy^QX!=l9KWX=Q7Vy9KDv(
z>`vxvrxWFq+$Ixw%+~re^7UKagR<vs-h7GGk)&VOG;hQAt=0Rkl~jvUxAIbD*rwSe
z_@RWE8UVQYZTc!9*693X%S5(Qv=ffO<E#)Ob8qk={LW0u7qxmXeTn$cSZY3hPlX7u
ztE*so{w)_^pxKJm(!rDYN~oO~bNOmiPZ+ROFxv<Gr8h0?PvZPAH92>rY5C*53jNVC
z(vg37P;Lu4SPj=9p4grYss?8maqAiDm+bSaw@lUNm!weAlaCyZ0}dIM7b2~;;&X+F
zy;N+jOGAg?XY~pMXM4B$jkobtX`@cBD3;kO%G;2!y{iiiEKO-3O9}ec>Tm;8qv5v3
z8>_t~yfnY*=UJWI1^m51d)BLb?*tW!2yvAz<l=9mfLEKHTOX1SvRFMHbPEde*CMp-
zO3?nsw6nqkD7ragtv#;M1`>)_r|@1g`g;JjEs@1GQ<4}Ondx|>uyK3xRYYV8)Gf0u
z+?o1x2-Rgt-b++zCQeyvVT946-g}yPVnag)*X5g1UVmGQ&0OeWE=OKy{8)>fVNsm^
z;5PI6{pU_GTF5&_W$IuIp&g6@WyPLnL6glOK8abJ0+YGd^2fTrVy!0yCm!6LeERd0
zB_lp84r;V&v8wqx$1e&b#4n-FlQ}`HbN)Y%1#|a2Yl`oU+JB_IjUl6%W_SXa1nhq#
z!e+nDp24r|<hXP#TMY13<oDL_Iqu~==t?;>&gkS~lXYty(tiG%f8g9cbAjoF!7K+Y
zrw?m?1^%+cByD=`Nz%Y<<JTd>t{I6(>&A;)!L*O0*_Wf_#m_HO@>d_MYTivb_FjfQ
z|FNrW=U?&G&#j6eQcQ5t^Xqc7VX^50da8y-9b5!fo9qR@k*f0v#L-IrYD4#^ut2zK
z?gUo>TwD2ES!$yo#?h1F_}sg$1H9=!p<`1D?!!=|NHl~o-jaP2L;t!85G}ivlkUQS
z9VB5N>*ysz&4=6QOGk|r|Jcy7x_0bK6=ov3Rf=g;)eFA=*e6jXk}r<GCWlu2w>tG-
zC>0wX+?t@n)}n3pQpQWv-0BZZ+q}`a#Zaa^qp@-4N2Sd8p_Q5uB-hCgX3bF3YDBCb
zyliNZxB-tI(Be(zcECx?q2(Ox-DZ%X7P8ieD#a=qZMa^~GZoi%3E7GFbqrU(I+b-A
zn4?dCgBOz*&LF=Fd(5n1?Ux*NlUpAz1ZV5JJgNttWR&`ju+r$=b&J^jp&Gw6m(>U6
zuT51TQf&6>yPId~9UJp449JO{+L8;naa^{eubA)mj{zQVl6qhh2sgf<&B3I(wbgP*
zH^Lc!(Fre{k-M%57My%J%_3OtI^UKxCmE4E`inOIs$opuM>LpW7pt0QV~KWDS2A$!
zx9kA15vNEXQM9tdN?~En_a(?t!*xiJ2i1_z+~<rA^%d@xuT%v$Y-N|nki@azEeSnZ
zz0xt+4<}is(<PaDxF&|p6yr~zHm`dZHG5C)k@V=E0l>LexZ0Z!kF0@r+HI4b7r#P-
z#r(r@LbwNYO;DLc3twc0fQ6ps3Srr6JOh4zN?vMfC#{vVH1CtJ>bM?ym(LyuWjJ)Y
zjaU27pT?0rf<D!_@jKR2uy~PZoGhuklpAV!82PqGS)rp?i{$7mymCaaGLZg)bfWju
zorMdE@fflt(J4>g=L?cR*4NO9$w&GK-pZa!)V2`{Ei6wT)AM8<DH?#!5-T)}!YoO<
z&x4QkFSyGmZet#sh_2dv%&2I8pc%p831;AyqR04+x&!yUHN1iC33V?zX0T3AuRgB`
zAjzZra!B07%fXOdL#ZB-_wWIj;(iFV&^k0o)35zpM<B}ba`O4@km(fe;jk_DXo2P7
z49i)^7i<MOrl#Ej`F#^tR&cHBquI|;z4E~*x7#ou!kBs*j^t;atc%XrR|>O^`@%<B
zdrMhrmd`I(;Rv2e95YcZfmA>+l^pq(yg>HTp-=ABQ^n4Ou4CX)Wh?3#N~QK6zc<V2
zhu!qFOd9_fzhiLTsnyI)I8(tDqZHA`I@m1BVTJ+&t31=+@nH;@HcS&IVv!6BZnaoa
zr`g<(YUMHw5ap|4ItxNDcixDl5}xvsfSd!-wF&<bDXO8JThOa$A+G9K8WLTtIhGk$
z5}@+0_6l8*iK)ac%}|ObSMB{x=OgQEy|~YA7Pr1iP}tni(<Bjmp0%j$1#fx@fMMUM
z9wFxlc+6dggI||WhFbWU2v4;TDD0|OV8VKd64U!BUvh>K=g2b8%QG{b82+?b85RVQ
z)}yF>P`c>H$1$P=m({##&3i1At2q|uxvxHax>&(qV8uTKZOr?xJ6iw6=u3WNn5yO7
zw0EG+cA6a3hc*lxH7ff<2USm8j)3eR!Ta;&#r6$3Ua}`X*LpXm9K6ie*E^)>V2b#;
zeAXqN`5f|0r&GtfY{F?;rL9t|Mshp6gZ^E-CMraJ08}H9w38_B_nY#n?jqEdb;<Hv
zo>g7(eNR|=Fu}bB-_tNsa3N2R^VVqF(4W-ZuB5Wiz%;~O4#ch?Kayr4j+!#1ed{CO
z&&Jtrlf`DoLfyt{fsp5$8rsU0$^jqTmfUrDUcB;}^(pVx)!YXE=?`Pwn3oKf8<|e3
zNLbk#;qT-@6nHu4?u}K)k3Hy=iMn06P|7wszVQtKV#i<a%I_tDzq!?aQVG(n-Fs+k
z+<VpU<vuk>$H=s*#npd(>!2b^iqAvoNOq$SG~0(Yw~MY`te(7{i=LC^F*=409z1$K
z255QjnN2oQ$i~T0=bQ%1;_b@hJz@`bQiDku*Vc;Cvu;e*2%sw;e|l%R*=dRE$Yh@t
zTFUFXe8P5NYcZzZA{&WTu6<xyem*$q#@KwRL!7v|%H;djPKie@{RLF)@Uqq{hawlr
zI=qvkTkYMrPnt9HxM{|#-h~y>x2MAzR6m`Kv-V|+0SQbTV-QoGvol8u8GYyghhNu}
z_3m3OTdl6RyORD=gTOv(K8AIS<eiu+gqnQ=I^jxR{2>!p`XkUCzZXy!al21&++zK4
zlo*2eNyk@|!f=2uvqY9NC1%iSAV0a+;)}K^ATalcr&c$%Nz>}xtTpw)Y%4hDj?XC*
z=N2>O1u5T67@k&tsR9JZ{We5u1mHrOa<C-6!rHOQMPYm>dI<+^aW$fMO8y_3fG*;A
z6-{#JZ~XUxhun#O)s(+7ktDmtvQH>OS@OFxT2|IFt$U&qCWpg1i0&}=?>k9tXYnke
z_ylNza%y#$1Uw08_yn^@oOukpFDm6~D)`d+U}hupKE8fA4XF!;`r&(ylSnr6wWz}v
z>v@-~ZjO_T`<M*NsKoRk)krO^!`~`enSn2D$a}^m%#b#Xx4dsF)cG<!vv4fM8}^Su
zx1o8n>4^u@u<swo2wr|E&(<b}aPo6cA4B;DLCB(*1ubu?tscj99_?fV&$F^f0+v6C
zHQ7#(md2(9ybuX<PS^gLUu=D=Om&{}{6F8Ad$dh;zr#noAHy>UK>dEmP~*<eDGSDH
znVh#3sqd?_vwSN8iKMmUjJYAZVRmral^&l8Mw$8re$Vv@5=sgFBRJEnXHu5Ar9MrX
zhZ8TCz;M-`iiz|-OjX9&to0xm5H4FbY$qq^Jyfy}c!+AtvAhr@87!=(W*+>k)jMYX
zCwV<>Ff_4`n`PZJ)F!T%^6sQddA}^hc-FI`@lyfCuOZJL7?FYyHgt}aOrn`f5HSJ-
z`!<$D_A*(E3m1E21x^QX9MU=pLa;=dt8ZvL_<<s6GsoBE(}w*buj+bnl(4bz-9(~-
zj{0_)PxSR@Ldaf+`MO9vAFOi+(Vi?VyGij9A*qK?wWop!h_)IIG>#38EqP{)!mqt%
zU)z@VoXoVi3AN;QrI<OIx-iIR;7Lh}jkAImK-9C7u6iK{7a>K7n{@H6bDDWxj^Nb3
zg~ZR!L&*_<2qv}4u^z1=e(O#gOJhk+2Nx_|_%aUO9rm$>bK>P*O-eebBEP@wrygB-
zXUx)%oWUJIbtG)<Xv7)`ut-EzG2d&33`VT+iEIssS7e1{x?j6gn=7I3|Liu~d6=qb
ztDd!Nym~bjM%WPE8!RC`jMFNtB6vfz60dX>7mIUIS`hBBlJ8M1DXt#*2vXg^9Zvi7
z+kh6eR3f>r7EdC!rDguh{~Cr#o;tJ;uY4jnerklQF3Eh_CNLhw=W4Ollm<BsBSP?`
z4Ri3o_$*!f!&HlAb-b|2$29O_;)sSW7^!q+O!82MEU{^6#^~0I&+tsps`d+rwx-dc
zl|u@g7$!FEA4pEP)1vv+nBOtW&o9bvVfH&4AW+&94d_$Tranz*0q+=NX5J7>8CKmY
zVBSdJlx9!+42vt5JTa(s8EVmke$!DSij`1zqt?4nq1Zv#`shGSGYE<uI^ZJr46B=Q
zj_v%VjiZBjn1h-%>-Y*|dJ_5XX_uETYaPd`G-5P2UYHu$f5lnqzCtwq%*?>6dRybV
z6xd}yXH}kOZZ?X9f`-RG_ZCYyJ5>I~AZb3z*w2>mV%*<cn{y>LUTC6Im!bFS--Y<d
zTys=hmmtIsmj0(cWCdU6UWcu!fBYq@jqs3c??c-?6`{zL*^CP`&M&L=A-lA*#h<@=
zBW7B<<VF>%?647w-$$S(j!i`y4K}1hkQ7Mtj-rZ#gz(IHC!GvTJW~>?MhYQn{5bsh
z3NNY`IZ3ywSij^R&f~YIyw7LrHuZ@!I4N9}*@Y7T*<~e*)$H@wsPpUnRFg@BSq<o2
zlADMh%qEl(=YJ-Qz6Og9)+)so@RH8Fn2h~&y;GFtN*ct7*@%*Qox{-=;(Z}bn$fUU
z9NmGA!Ha4W#u+%us=hrj8ZO4xz9ZaVo{0D0=dArF^hUSgR3=H=rB`t`%FCds^+VQ_
z#AdDxiy0%;VEtW<9%3MhCE9<<l=QQUr&X$)oiO#?@H7z`;`kR5Ntv0x`j|WeuW)<6
z@pxAI2Exrn;Ov^~Mhdg`G19ooqgqClJPeoBTr7jWYR>>^^aATN#xuIE@gqsx3CZ-B
zDS0!gsr%ZdiSd?H7^{$39k|zYi!v94Kl2f~R7g;O!#ZZeSL1bZpL-*cj{JZb6BM2k
z%)~kUXcz7IKAig)Wa)_1Swgr&5n5=Y=6?d6|BSe_l~b<+i)$@^5z@EL96FL_8S#>S
z`!lk(0hOt8jqhl@Ec?gNQaW&mn!Qsx!38i;YpA2D!y%8J*<Gw!Q%|(Tv&s3+n|$n1
z-2B9-xMM>tM&)=3M^k+FR6&drL$p#*Kb#^lhF87C%!V<E)9tx@>(CblnkN~qQy~4Q
zf4Dnlg#?}#WR>j)TMM0&BM3g=o><!D+@Ew+?O1XUSercXUpmi-Pg$4~1BA}NG`i3o
z>NEz-k(58r@-_crFwg70mT^>aI0r$piA<0+G)kln)O-^w`3RK*i}9RzTMpYcZiLml
zq4y~R$^d6O!eT4wp*dcPmvnnHcyF$yv5H_{7o61)lwE=uzP~OJSpX<H4i)k1HR!RV
zN#meO%c<d_asYz#>}8BC{{1)nQ}FUnMERe%awac_I<<jVkT6Aq^0G=bb*))VbE@Ei
zOMSjYlkM5LDR#qJ)B&rjwk!=!TKRUemJw|kiy>Lc6dxfoHU|P9BwA60EKW+mGgp}9
zeM|W@KKehK5-TqrTaR)QeFyr-M$Fj8n@NGKIVuewTJC0GN!$0FhZea>|J}SKc*16A
z!lBR^wS=~Am58DHC#c#^;O1Y9zZmTj)2vWumB?vhNAr;o343z&U<vkEQ}Qlag+WLs
z_fjAtlj|=ACrD}WFUDIHyoNu@D!@z%Qru@k`bjsgNC5$K=S!j*LDp}sX!|t;BUvHa
z9Rg!?{tt-8H9d`c{TyWJ3fny3d(<Bo_w}E?bN|NK|2L8-?iXtX2KFExX%ttxMibu6
zB~;UTUjUeS_9VD8O71y|(&f;9pE}H`t13XUu%9s~p{I&8PLu8Vw4vr^AfmCq{Vk2L
P;pqJS^A>Eyzl;ALC)o^j

literal 0
HcmV?d00001

diff --git a/TestPkg/FakeLogo/JpegLogo.idf b/TestPkg/FakeLogo/JpegLogo.idf
new file mode 100644
index 0000000000..3702a1c48d
--- /dev/null
+++ b/TestPkg/FakeLogo/JpegLogo.idf
@@ -0,0 +1,10 @@
+// /** @file
+// Platform Logo image definition file.
+//
+// Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
+//
+// SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+// **/
+
+#image IMG_LOGO Logo.jpg
diff --git a/TestPkg/FakeLogo/JpegLogoDxe.inf b/TestPkg/FakeLogo/JpegLogoDxe.inf
new file mode 100644
index 0000000000..4396bbfd8a
--- /dev/null
+++ b/TestPkg/FakeLogo/JpegLogoDxe.inf
@@ -0,0 +1,53 @@
+## @file
+#  The default logo JPEG picture shown on setup screen.
+#
+#  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = JpegLogoDxe
+  FILE_GUID                      = 319CFE1D-8F15-4A7A-BF40-EECA953D87EF
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+
+  ENTRY_POINT                    = InitializeLogo
+#
+#  This flag specifies whether HII resource section is generated into PE image.
+#
+  UEFI_HII_RESOURCE_SECTION      = TRUE
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64
+#
+
+[Sources.X64]
+  Logo.jpg
+  Logo.c
+  JpegLogo.idf
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+
+[LibraryClasses]
+  UefiBootServicesTableLib
+  UefiDriverEntryPoint
+  DebugLib
+  DebugAgentLib
+
+[Protocols]
+  gEfiHiiDatabaseProtocolGuid        ## CONSUMES
+  gEfiHiiImageExProtocolGuid         ## CONSUMES
+  gEfiHiiPackageListProtocolGuid     ## PRODUCES CONSUMES
+  gEdkiiPlatformLogoProtocolGuid     ## PRODUCES
+
+[Depex]
+  gEfiHiiDatabaseProtocolGuid AND
+  gEfiHiiImageExProtocolGuid
diff --git a/TestPkg/FakeLogo/Logo.c b/TestPkg/FakeLogo/Logo.c
new file mode 100644
index 0000000000..813421f3d1
--- /dev/null
+++ b/TestPkg/FakeLogo/Logo.c
@@ -0,0 +1,153 @@
+/** @file
+  Logo DXE Driver, install Edkii Platform Logo protocol.
+
+Copyright (c) 2016 - 2020, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+#include <Uefi.h>
+#include <Protocol/HiiDatabase.h>
+#include <Protocol/GraphicsOutput.h>
+#include <Protocol/HiiImageEx.h>
+#include <Protocol/PlatformLogo.h>
+#include <Protocol/HiiPackageList.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/DebugLib.h>
+
+typedef struct {
+  EFI_IMAGE_ID                          ImageId;
+  EDKII_PLATFORM_LOGO_DISPLAY_ATTRIBUTE Attribute;
+  INTN                                  OffsetX;
+  INTN                                  OffsetY;
+} LOGO_ENTRY;
+
+EFI_HII_IMAGE_EX_PROTOCOL *mHiiImageEx;
+EFI_HII_HANDLE            mHiiHandle;
+LOGO_ENTRY                mLogos[] = {
+  {
+    IMAGE_TOKEN (IMG_LOGO),
+    EdkiiPlatformLogoDisplayAttributeCenter,
+    0,
+    0
+  }
+};
+
+/**
+  Load a platform logo image and return its data and attributes.
+
+  @param This              The pointer to this protocol instance.
+  @param Instance          The visible image instance is found.
+  @param Image             Points to the image.
+  @param Attribute         The display attributes of the image returned.
+  @param OffsetX           The X offset of the image regarding the Attribute.
+  @param OffsetY           The Y offset of the image regarding the Attribute.
+
+  @retval EFI_SUCCESS      The image was fetched successfully.
+  @retval EFI_NOT_FOUND    The specified image could not be found.
+**/
+EFI_STATUS
+EFIAPI
+GetImage (
+  IN     EDKII_PLATFORM_LOGO_PROTOCOL          *This,
+  IN OUT UINT32                                *Instance,
+     OUT EFI_IMAGE_INPUT                       *Image,
+     OUT EDKII_PLATFORM_LOGO_DISPLAY_ATTRIBUTE *Attribute,
+     OUT INTN                                  *OffsetX,
+     OUT INTN                                  *OffsetY
+  )
+{
+  UINT32 Current;
+  if (Instance == NULL || Image == NULL ||
+      Attribute == NULL || OffsetX == NULL || OffsetY == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Current = *Instance;
+  if (Current >= ARRAY_SIZE (mLogos)) {
+    return EFI_NOT_FOUND;
+  }
+
+  (*Instance)++;
+  *Attribute = mLogos[Current].Attribute;
+  *OffsetX   = mLogos[Current].OffsetX;
+  *OffsetY   = mLogos[Current].OffsetY;
+  return mHiiImageEx->GetImageEx (mHiiImageEx, mHiiHandle, mLogos[Current].ImageId, Image);
+}
+
+EDKII_PLATFORM_LOGO_PROTOCOL mPlatformLogo = {
+  GetImage
+};
+
+/**
+  Entrypoint of this module.
+
+  This function is the entrypoint of this module. It installs the Edkii
+  Platform Logo protocol.
+
+  @param  ImageHandle       The firmware allocated handle for the EFI image.
+  @param  SystemTable       A pointer to the EFI System Table.
+
+  @retval EFI_SUCCESS       The entry point is executed successfully.
+
+**/
+EFI_STATUS
+EFIAPI
+InitializeLogo (
+  IN EFI_HANDLE               ImageHandle,
+  IN EFI_SYSTEM_TABLE         *SystemTable
+  )
+{
+  EFI_STATUS                  Status;
+  EFI_HII_PACKAGE_LIST_HEADER *PackageList;
+  EFI_HII_DATABASE_PROTOCOL   *HiiDatabase;
+  EFI_HANDLE                  Handle;
+
+  Status = gBS->LocateProtocol (
+                  &gEfiHiiDatabaseProtocolGuid,
+                  NULL,
+                  (VOID **) &HiiDatabase
+                  );
+  ASSERT_EFI_ERROR (Status);
+
+  Status = gBS->LocateProtocol (
+                  &gEfiHiiImageExProtocolGuid,
+                  NULL,
+                  (VOID **) &mHiiImageEx
+                  );
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Retrieve HII package list from ImageHandle
+  //
+  Status = gBS->OpenProtocol (
+                  ImageHandle,
+                  &gEfiHiiPackageListProtocolGuid,
+                  (VOID **) &PackageList,
+                  ImageHandle,
+                  NULL,
+                  EFI_OPEN_PROTOCOL_GET_PROTOCOL
+                  );
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "HII Image Package with logo not found in PE/COFF resource section\n"));
+    return Status;
+  }
+
+  //
+  // Publish HII package list to HII Database.
+  //
+  Status = HiiDatabase->NewPackageList (
+                          HiiDatabase,
+                          PackageList,
+                          NULL,
+                          &mHiiHandle
+                          );
+  if (!EFI_ERROR (Status)) {
+    Handle = NULL;
+    Status = gBS->InstallMultipleProtocolInterfaces (
+                    &Handle,
+                    &gEdkiiPlatformLogoProtocolGuid, &mPlatformLogo,
+                    NULL
+                    );
+  }
+  return Status;
+}
diff --git a/TestPkg/FakeLogo/Logo.jpg b/TestPkg/FakeLogo/Logo.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..d1d099789fa794648b86c046f0320a553954764e
GIT binary patch
literal 11944
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

literal 0
HcmV?d00001

diff --git a/TestPkg/FakeTimeStamp.txt b/TestPkg/FakeTimeStamp.txt
new file mode 100644
index 0000000000..5364869e59
--- /dev/null
+++ b/TestPkg/FakeTimeStamp.txt
@@ -0,0 +1 @@
+Fri 7/1/ 91013
\ No newline at end of file
diff --git a/TestPkg/FvmainCompactScratchEnd.fdf.inc b/TestPkg/FvmainCompactScratchEnd.fdf.inc
new file mode 100644
index 0000000000..780741f1ce
--- /dev/null
+++ b/TestPkg/FvmainCompactScratchEnd.fdf.inc
@@ -0,0 +1,65 @@
+## @file
+#  This FDF include file computes the end of the scratch buffer used in
+#  DecompressMemFvs() [OvmfPkg/Sec/SecMain.c]. It is based on the decompressed
+#  (ie. original) size of the LZMA-compressed section of the one FFS file in
+#  the FVMAIN_COMPACT firmware volume.
+#
+#  Copyright (C) 2015, Red Hat, Inc.
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+##
+
+# The GUID EE4E5898-3914-4259-9D6E-DC7BD79403CF means "LzmaCustomDecompress".
+# The decompressed output will have the following structure (see the file
+# "9E21FD93-9C72-4c15-8C4B-E77F1DB2D792SEC1.guided.dummy" in the
+# Build/Ovmf*/*/FV/Ffs/9E21FD93-9C72-4c15-8C4B-E77F1DB2D792/ directory):
+#
+# Size                 Contents
+# -------------------  --------------------------------------------------------
+#                   4  EFI_COMMON_SECTION_HEADER, stating size 124 (0x7C) and
+#                      type 0x19 (EFI_SECTION_RAW). The purpose of this section
+#                      is to pad the start of PEIFV to 128 bytes.
+#                 120  Zero bytes (padding).
+#
+#                   4  EFI_COMMON_SECTION_HEADER, stating size
+#                      (PcdOvmfPeiMemFvSize + 4), and type 0x17
+#                      (EFI_SECTION_FIRMWARE_VOLUME_IMAGE).
+# PcdOvmfPeiMemFvSize  PEIFV. Note that the above sizes pad the offset of this
+#                      object to 128 bytes. See also the "guided.dummy.txt"
+#                      file in the same directory.
+#
+#                   4  EFI_COMMON_SECTION_HEADER, stating size 12 (0xC) and
+#                      type 0x19 (EFI_SECTION_RAW). The purpose of this section
+#                      is to pad the start of DXEFV to 16 bytes.
+#                   8  Zero bytes (padding).
+#
+#                   4  EFI_COMMON_SECTION_HEADER, stating size
+#                      (PcdOvmfDxeMemFvSize + 4), and type 0x17
+#                      (EFI_SECTION_FIRMWARE_VOLUME_IMAGE).
+# PcdOvmfDxeMemFvSize  DXEFV. Note that the above sizes pad the offset of this
+#                      object to 16 bytes. See also the "guided.dummy.txt" file
+#                      in the same directory.
+#
+# The total size after decompression is (128 + PcdOvmfPeiMemFvSize + 16 +
+# PcdOvmfDxeMemFvSize).
+
+DEFINE OUTPUT_SIZE = (128 + gUefiOvmfPkgTokenSpaceGuid.PcdOvmfPeiMemFvSize + 16 + gUefiOvmfPkgTokenSpaceGuid.PcdOvmfDxeMemFvSize)
+
+# LzmaCustomDecompressLib uses a constant scratch buffer size of 64KB; see
+# SCRATCH_BUFFER_REQUEST_SIZE in
+# "MdeModulePkg/Library/LzmaCustomDecompressLib/LzmaDecompress.c".
+
+DEFINE DECOMP_SCRATCH_SIZE = 0x00010000
+
+# Note: when we use PcdOvmfDxeMemFvBase in this context, BaseTools have not yet
+# offset it with MEMFD's base address. For that reason we have to do it manually.
+#
+# The calculation below mirrors DecompressMemFvs() [OvmfPkg/Sec/SecMain.c].
+
+DEFINE OUTPUT_BASE                   = ($(MEMFD_BASE_ADDRESS) + gUefiOvmfPkgTokenSpaceGuid.PcdOvmfDxeMemFvBase + 0x00100000)
+DEFINE DECOMP_SCRATCH_BASE_UNALIGNED = ($(OUTPUT_BASE) + $(OUTPUT_SIZE))
+DEFINE DECOMP_SCRATCH_BASE_ALIGNMENT = 0x000FFFFF
+DEFINE DECOMP_SCRATCH_BASE_MASK      = 0xFFF00000
+DEFINE DECOMP_SCRATCH_BASE           = (($(DECOMP_SCRATCH_BASE_UNALIGNED) + $(DECOMP_SCRATCH_BASE_ALIGNMENT)) & $(DECOMP_SCRATCH_BASE_MASK))
+
+SET gUefiOvmfPkgTokenSpaceGuid.PcdOvmfDecompressionScratchEnd = $(DECOMP_SCRATCH_BASE) + $(DECOMP_SCRATCH_SIZE)
diff --git a/TestPkg/Library/AcpiTimerLib/AcpiTimerLib.c b/TestPkg/Library/AcpiTimerLib/AcpiTimerLib.c
new file mode 100644
index 0000000000..7a740b32c8
--- /dev/null
+++ b/TestPkg/Library/AcpiTimerLib/AcpiTimerLib.c
@@ -0,0 +1,210 @@
+/** @file
+  ACPI Timer implements one instance of Timer Library.
+
+  Copyright (c) 2008 - 2012, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2011, Andrei Warkentin <andreiw@motorola.com>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <Library/DebugLib.h>
+#include <Library/BaseLib.h>
+#include <IndustryStandard/Acpi.h>
+
+#include "AcpiTimerLib.h"
+
+//
+// The ACPI Time is a 24-bit counter
+//
+#define ACPI_TIMER_COUNT_SIZE  BIT24
+
+/**
+  Stalls the CPU for at least the given number of ticks.
+
+  Stalls the CPU for at least the given number of ticks. It's invoked by
+  MicroSecondDelay() and NanoSecondDelay().
+
+  @param  Delay     A period of time to delay in ticks.
+
+**/
+VOID
+InternalAcpiDelay (
+  IN      UINT32                    Delay
+  )
+{
+  UINT32                            Ticks;
+  UINT32                            Times;
+
+  Times    = Delay >> 22;
+  Delay   &= BIT22 - 1;
+  do {
+    //
+    // The target timer count is calculated here
+    //
+    Ticks    = InternalAcpiGetTimerTick () + Delay;
+    Delay    = BIT22;
+    //
+    // Wait until time out
+    // Delay >= 2^23 could not be handled by this function
+    // Timer wrap-arounds are handled correctly by this function
+    //
+    while (((Ticks - InternalAcpiGetTimerTick ()) & BIT23) == 0) {
+      CpuPause ();
+    }
+  } while (Times-- > 0);
+}
+
+/**
+  Stalls the CPU for at least the given number of microseconds.
+
+  Stalls the CPU for the number of microseconds specified by MicroSeconds.
+
+  @param  MicroSeconds  The minimum number of microseconds to delay.
+
+  @return MicroSeconds
+
+**/
+UINTN
+EFIAPI
+MicroSecondDelay (
+  IN      UINTN                     MicroSeconds
+  )
+{
+  InternalAcpiDelay (
+    (UINT32)DivU64x32 (
+              MultU64x32 (
+                MicroSeconds,
+                ACPI_TIMER_FREQUENCY
+                ),
+              1000000u
+              )
+    );
+  return MicroSeconds;
+}
+
+/**
+  Stalls the CPU for at least the given number of nanoseconds.
+
+  Stalls the CPU for the number of nanoseconds specified by NanoSeconds.
+
+  @param  NanoSeconds The minimum number of nanoseconds to delay.
+
+  @return NanoSeconds
+
+**/
+UINTN
+EFIAPI
+NanoSecondDelay (
+  IN      UINTN                     NanoSeconds
+  )
+{
+  InternalAcpiDelay (
+    (UINT32)DivU64x32 (
+              MultU64x32 (
+                NanoSeconds,
+                ACPI_TIMER_FREQUENCY
+                ),
+              1000000000u
+              )
+    );
+  return NanoSeconds;
+}
+
+/**
+  Retrieves the current value of a 64-bit free running performance counter.
+
+  Retrieves the current value of a 64-bit free running performance counter. The
+  counter can either count up by 1 or count down by 1. If the physical
+  performance counter counts by a larger increment, then the counter values
+  must be translated. The properties of the counter can be retrieved from
+  GetPerformanceCounterProperties().
+
+  @return The current value of the free running performance counter.
+
+**/
+UINT64
+EFIAPI
+GetPerformanceCounter (
+  VOID
+  )
+{
+  return (UINT64)InternalAcpiGetTimerTick ();
+}
+
+/**
+  Retrieves the 64-bit frequency in Hz and the range of performance counter
+  values.
+
+  If StartValue is not NULL, then the value that the performance counter starts
+  with immediately after is it rolls over is returned in StartValue. If
+  EndValue is not NULL, then the value that the performance counter end with
+  immediately before it rolls over is returned in EndValue. The 64-bit
+  frequency of the performance counter in Hz is always returned. If StartValue
+  is less than EndValue, then the performance counter counts up. If StartValue
+  is greater than EndValue, then the performance counter counts down. For
+  example, a 64-bit free running counter that counts up would have a StartValue
+  of 0 and an EndValue of 0xFFFFFFFFFFFFFFFF. A 24-bit free running counter
+  that counts down would have a StartValue of 0xFFFFFF and an EndValue of 0.
+
+  @param  StartValue  The value the performance counter starts with when it
+                      rolls over.
+  @param  EndValue    The value that the performance counter ends with before
+                      it rolls over.
+
+  @return The frequency in Hz.
+
+**/
+UINT64
+EFIAPI
+GetPerformanceCounterProperties (
+  OUT      UINT64                    *StartValue,  OPTIONAL
+  OUT      UINT64                    *EndValue     OPTIONAL
+  )
+{
+  if (StartValue != NULL) {
+    *StartValue = 0;
+  }
+
+  if (EndValue != NULL) {
+    *EndValue = ACPI_TIMER_COUNT_SIZE - 1;
+  }
+
+  return ACPI_TIMER_FREQUENCY;
+}
+
+/**
+  Converts elapsed ticks of performance counter to time in nanoseconds.
+
+  This function converts the elapsed ticks of running performance counter to
+  time value in unit of nanoseconds.
+
+  @param  Ticks     The number of elapsed ticks of running performance counter.
+
+  @return The elapsed time in nanoseconds.
+
+**/
+UINT64
+EFIAPI
+GetTimeInNanoSecond (
+  IN      UINT64                     Ticks
+  )
+{
+  UINT64  NanoSeconds;
+  UINT32  Remainder;
+
+  //
+  //          Ticks
+  // Time = --------- x 1,000,000,000
+  //        Frequency
+  //
+  NanoSeconds = MultU64x32 (DivU64x32Remainder (Ticks, ACPI_TIMER_FREQUENCY, &Remainder), 1000000000u);
+
+  //
+  // Frequency < 0x100000000, so Remainder < 0x100000000, then (Remainder * 1,000,000,000)
+  // will not overflow 64-bit.
+  //
+  NanoSeconds += DivU64x32 (MultU64x32 ((UINT64) Remainder, 1000000000u), ACPI_TIMER_FREQUENCY);
+
+  return NanoSeconds;
+}
diff --git a/TestPkg/Library/AcpiTimerLib/AcpiTimerLib.h b/TestPkg/Library/AcpiTimerLib/AcpiTimerLib.h
new file mode 100644
index 0000000000..6740096ff4
--- /dev/null
+++ b/TestPkg/Library/AcpiTimerLib/AcpiTimerLib.h
@@ -0,0 +1,23 @@
+/** @file
+  Internal definitions for ACPI Timer Library
+
+  Copyright (C) 2014, Gabriel L. Somlo <somlo@cmu.edu>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _ACPI_TIMER_LIB_INTERNAL_H_
+#define _ACPI_TIMER_LIB_INTERNAL_H_
+
+/**
+  Internal function to read the current tick counter of ACPI.
+
+  @return The tick counter read.
+
+**/
+UINT32
+InternalAcpiGetTimerTick (
+  VOID
+  );
+
+#endif // _ACPI_TIMER_LIB_INTERNAL_H_
diff --git a/TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLib.c b/TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLib.c
new file mode 100644
index 0000000000..7707a9d6af
--- /dev/null
+++ b/TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLib.c
@@ -0,0 +1,103 @@
+/** @file
+  Provide constructor and GetTick for Base instance of ACPI Timer Library
+
+  Copyright (C) 2014, Gabriel L. Somlo <somlo@cmu.edu>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#include <Library/DebugLib.h>
+#include <Library/IoLib.h>
+#include <Library/PciLib.h>
+#include <OvmfPlatforms.h>
+
+//
+// Cached ACPI Timer IO Address
+//
+STATIC UINT32 mAcpiTimerIoAddr;
+
+/**
+  The constructor function caches the ACPI tick counter address, and,
+  if necessary, enables ACPI IO space.
+
+  @retval EFI_SUCCESS   The constructor always returns RETURN_SUCCESS.
+
+**/
+RETURN_STATUS
+EFIAPI
+AcpiTimerLibConstructor (
+  VOID
+  )
+{
+  UINT16 HostBridgeDevId;
+  UINTN Pmba;
+  UINT32 PmbaAndVal;
+  UINT32 PmbaOrVal;
+  UINTN AcpiCtlReg;
+  UINT8 AcpiEnBit;
+
+  //
+  // Query Host Bridge DID to determine platform type
+  //
+  HostBridgeDevId = PciRead16 (OVMF_HOSTBRIDGE_DID);
+  switch (HostBridgeDevId) {
+    case INTEL_82441_DEVICE_ID:
+      Pmba       = POWER_MGMT_REGISTER_PIIX4 (PIIX4_PMBA);
+      PmbaAndVal = ~(UINT32)PIIX4_PMBA_MASK;
+      PmbaOrVal  = PIIX4_PMBA_VALUE;
+      AcpiCtlReg = POWER_MGMT_REGISTER_PIIX4 (PIIX4_PMREGMISC);
+      AcpiEnBit  = PIIX4_PMREGMISC_PMIOSE;
+      break;
+    case INTEL_Q35_MCH_DEVICE_ID:
+      Pmba       = POWER_MGMT_REGISTER_Q35 (ICH9_PMBASE);
+      PmbaAndVal = ~(UINT32)ICH9_PMBASE_MASK;
+      PmbaOrVal  = ICH9_PMBASE_VALUE;
+      AcpiCtlReg = POWER_MGMT_REGISTER_Q35 (ICH9_ACPI_CNTL);
+      AcpiEnBit  = ICH9_ACPI_CNTL_ACPI_EN;
+      break;
+    default:
+      DEBUG ((DEBUG_ERROR, "%a: Unknown Host Bridge Device ID: 0x%04x\n",
+        __FUNCTION__, HostBridgeDevId));
+      ASSERT (FALSE);
+      return RETURN_UNSUPPORTED;
+  }
+
+  //
+  // Check to see if the Power Management Base Address is already enabled
+  //
+  if ((PciRead8 (AcpiCtlReg) & AcpiEnBit) == 0) {
+    //
+    // If the Power Management Base Address is not programmed,
+    // then program it now.
+    //
+    PciAndThenOr32 (Pmba, PmbaAndVal, PmbaOrVal);
+
+    //
+    // Enable PMBA I/O port decodes
+    //
+    PciOr8 (AcpiCtlReg, AcpiEnBit);
+  }
+
+  mAcpiTimerIoAddr = (PciRead32 (Pmba) & ~PMBA_RTE) + ACPI_TIMER_OFFSET;
+  return RETURN_SUCCESS;
+}
+
+/**
+  Internal function to read the current tick counter of ACPI.
+
+  Read the current ACPI tick counter using the counter address cached
+  by this instance's constructor.
+
+  @return The tick counter read.
+
+**/
+UINT32
+InternalAcpiGetTimerTick (
+  VOID
+  )
+{
+  //
+  //   Return the current ACPI timer value.
+  //
+  return IoRead32 (mAcpiTimerIoAddr);
+}
diff --git a/TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLib.inf b/TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLib.inf
new file mode 100644
index 0000000000..0d7ae90033
--- /dev/null
+++ b/TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLib.inf
@@ -0,0 +1,32 @@
+## @file
+#  Base ACPI Timer Library Instance.
+#
+#  Copyright (C) 2014, Gabriel L. Somlo <somlo@cmu.edu>
+#  Copyright (c) 2008 - 2010, Intel Corporation. All rights reserved.
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+[Defines]
+  INF_VERSION    = 0x00010005
+  BASE_NAME      = BaseAcpiTimerLib
+  FILE_GUID      = FB648CF5-91BE-4737-9023-FD807AC6D96D
+  MODULE_TYPE    = BASE
+  VERSION_STRING = 1.0
+  LIBRARY_CLASS  = TimerLib|PEI_CORE PEIM DXE_CORE
+  CONSTRUCTOR    = AcpiTimerLibConstructor
+
+[Sources]
+  AcpiTimerLib.c
+  AcpiTimerLib.h
+  BaseAcpiTimerLib.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  PciLib
+  IoLib
diff --git a/TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLibBhyve.c b/TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLibBhyve.c
new file mode 100644
index 0000000000..c23eb80f3a
--- /dev/null
+++ b/TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLibBhyve.c
@@ -0,0 +1,32 @@
+/** @file
+  Provide InternalAcpiGetTimerTick for the bhyve instance of the
+  Base ACPI Timer Library
+
+  Copyright (C) 2020, Rebecca Cran <rebecca@bsdio.com>
+  Copyright (C) 2014, Gabriel L. Somlo <somlo@cmu.edu>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#include <Library/IoLib.h>
+#include <OvmfPlatforms.h>
+
+/**
+  Internal function to read the current tick counter of ACPI.
+
+  Read the current ACPI tick counter using the counter address cached
+  by this instance's constructor.
+
+  @return The tick counter read.
+
+**/
+UINT32
+InternalAcpiGetTimerTick (
+  VOID
+  )
+{
+  //
+  // Return the current ACPI timer value.
+  //
+  return IoRead32 (BHYVE_ACPI_TIMER_IO_ADDR);
+}
diff --git a/TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLibBhyve.inf b/TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLibBhyve.inf
new file mode 100644
index 0000000000..39fe838256
--- /dev/null
+++ b/TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLibBhyve.inf
@@ -0,0 +1,30 @@
+## @file
+#  Base ACPI Timer Library Instance for Bhyve.
+#
+#  Copyright (C) 2020, Rebecca Cran <rebecca@bsdio.com>
+#  Copyright (C) 2014, Gabriel L. Somlo <somlo@cmu.edu>
+#  Copyright (c) 2008 - 2010, Intel Corporation. All rights reserved.
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+[Defines]
+  INF_VERSION    = 0x00010005
+  BASE_NAME      = BaseAcpiTimerLibBhyve
+  FILE_GUID      = A5E3B247-7302-11EA-9C04-3CECEF0C1C08
+  MODULE_TYPE    = BASE
+  VERSION_STRING = 1.0
+  LIBRARY_CLASS  = TimerLib
+
+[Sources]
+  AcpiTimerLib.c
+  AcpiTimerLib.h
+  BaseAcpiTimerLibBhyve.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  IoLib
diff --git a/TestPkg/Library/AcpiTimerLib/BaseRomAcpiTimerLib.c b/TestPkg/Library/AcpiTimerLib/BaseRomAcpiTimerLib.c
new file mode 100644
index 0000000000..b05359b72e
--- /dev/null
+++ b/TestPkg/Library/AcpiTimerLib/BaseRomAcpiTimerLib.c
@@ -0,0 +1,121 @@
+/** @file
+  Provide constructor and GetTick for BaseRom instance of ACPI Timer Library
+
+  Copyright (c) 2008 - 2012, Intel Corporation. All rights reserved.
+  Copyright (c) 2011, Andrei Warkentin <andreiw@motorola.com>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#include <Library/DebugLib.h>
+#include <Library/IoLib.h>
+#include <Library/PciLib.h>
+#include <OvmfPlatforms.h>
+
+/**
+  The constructor function enables ACPI IO space.
+
+  If ACPI I/O space not enabled, this function will enable it.
+  It will always return RETURN_SUCCESS.
+
+  @retval EFI_SUCCESS   The constructor always returns RETURN_SUCCESS.
+
+**/
+RETURN_STATUS
+EFIAPI
+AcpiTimerLibConstructor (
+  VOID
+  )
+{
+  UINT16 HostBridgeDevId;
+  UINTN Pmba;
+  UINT32 PmbaAndVal;
+  UINT32 PmbaOrVal;
+  UINTN AcpiCtlReg;
+  UINT8 AcpiEnBit;
+
+  //
+  // Query Host Bridge DID to determine platform type
+  //
+  HostBridgeDevId = PciRead16 (OVMF_HOSTBRIDGE_DID);
+  switch (HostBridgeDevId) {
+    case INTEL_82441_DEVICE_ID:
+      Pmba       = POWER_MGMT_REGISTER_PIIX4 (PIIX4_PMBA);
+      PmbaAndVal = ~(UINT32)PIIX4_PMBA_MASK;
+      PmbaOrVal  = PIIX4_PMBA_VALUE;
+      AcpiCtlReg = POWER_MGMT_REGISTER_PIIX4 (PIIX4_PMREGMISC);
+      AcpiEnBit  = PIIX4_PMREGMISC_PMIOSE;
+      break;
+    case INTEL_Q35_MCH_DEVICE_ID:
+      Pmba       = POWER_MGMT_REGISTER_Q35 (ICH9_PMBASE);
+      PmbaAndVal = ~(UINT32)ICH9_PMBASE_MASK;
+      PmbaOrVal  = ICH9_PMBASE_VALUE;
+      AcpiCtlReg = POWER_MGMT_REGISTER_Q35 (ICH9_ACPI_CNTL);
+      AcpiEnBit  = ICH9_ACPI_CNTL_ACPI_EN;
+      break;
+    default:
+      DEBUG ((DEBUG_ERROR, "%a: Unknown Host Bridge Device ID: 0x%04x\n",
+        __FUNCTION__, HostBridgeDevId));
+      ASSERT (FALSE);
+      return RETURN_UNSUPPORTED;
+  }
+
+  //
+  // Check to see if the Power Management Base Address is already enabled
+  //
+  if ((PciRead8 (AcpiCtlReg) & AcpiEnBit) == 0) {
+    //
+    // If the Power Management Base Address is not programmed,
+    // then program it now.
+    //
+    PciAndThenOr32 (Pmba, PmbaAndVal, PmbaOrVal);
+
+    //
+    // Enable PMBA I/O port decodes
+    //
+    PciOr8 (AcpiCtlReg, AcpiEnBit);
+  }
+
+  return RETURN_SUCCESS;
+}
+
+/**
+  Internal function to read the current tick counter of ACPI.
+
+  Dynamically compute the address of the ACPI tick counter based on the
+  properties of the underlying platform, to avoid relying on global variables.
+
+  @return The tick counter read.
+
+**/
+UINT32
+InternalAcpiGetTimerTick (
+  VOID
+  )
+{
+  UINT16 HostBridgeDevId;
+  UINTN Pmba;
+
+  //
+  // Query Host Bridge DID to determine platform type
+  //
+  HostBridgeDevId = PciRead16 (OVMF_HOSTBRIDGE_DID);
+  switch (HostBridgeDevId) {
+    case INTEL_82441_DEVICE_ID:
+      Pmba = POWER_MGMT_REGISTER_PIIX4 (PIIX4_PMBA);
+      break;
+    case INTEL_Q35_MCH_DEVICE_ID:
+      Pmba = POWER_MGMT_REGISTER_Q35 (ICH9_PMBASE);
+      break;
+    default:
+      DEBUG ((DEBUG_ERROR, "%a: Unknown Host Bridge Device ID: 0x%04x\n",
+        __FUNCTION__, HostBridgeDevId));
+      ASSERT (FALSE);
+      return 0;
+  }
+
+  //
+  //   Read PMBA to read and return the current ACPI timer value.
+  //
+  return IoRead32 ((PciRead32 (Pmba) & ~PMBA_RTE) + ACPI_TIMER_OFFSET);
+}
diff --git a/TestPkg/Library/AcpiTimerLib/BaseRomAcpiTimerLib.inf b/TestPkg/Library/AcpiTimerLib/BaseRomAcpiTimerLib.inf
new file mode 100644
index 0000000000..4c9a99e5ff
--- /dev/null
+++ b/TestPkg/Library/AcpiTimerLib/BaseRomAcpiTimerLib.inf
@@ -0,0 +1,31 @@
+## @file
+#  BaseRom ACPI Timer Library Instance.
+#
+#  Copyright (c) 2008 - 2010, Intel Corporation. All rights reserved.
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+[Defines]
+  INF_VERSION    = 0x00010005
+  BASE_NAME      = BaseRomAcpiTimerLib
+  FILE_GUID      = CDD9D74F-213E-4c28-98F7-8B4A167DB936
+  MODULE_TYPE    = BASE
+  VERSION_STRING = 1.0
+  LIBRARY_CLASS  = TimerLib|SEC
+  CONSTRUCTOR    = AcpiTimerLibConstructor
+
+[Sources]
+  AcpiTimerLib.c
+  AcpiTimerLib.h
+  BaseRomAcpiTimerLib.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  PciLib
+  IoLib
diff --git a/TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.c b/TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.c
new file mode 100644
index 0000000000..62a0cea4be
--- /dev/null
+++ b/TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.c
@@ -0,0 +1,83 @@
+/** @file
+  Provide constructor and GetTick for Dxe instance of ACPI Timer Library
+
+  Copyright (C) 2014, Gabriel L. Somlo <somlo@cmu.edu>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#include <Library/DebugLib.h>
+#include <Library/IoLib.h>
+#include <Library/PcdLib.h>
+#include <Library/PciLib.h>
+#include <OvmfPlatforms.h>
+
+//
+// Cached ACPI Timer IO Address
+//
+STATIC UINT32 mAcpiTimerIoAddr;
+
+/**
+  The constructor function caches the ACPI tick counter address
+
+  At the time this constructor runs (DXE_CORE or later), ACPI IO space
+  has already been enabled by either PlatformPei or by the "Base"
+  instance of this library.
+  In order to avoid querying the underlying platform type during each
+  tick counter read operation, we cache the counter address during
+  initialization of this instance of the Timer Library.
+
+  @retval EFI_SUCCESS   The constructor always returns RETURN_SUCCESS.
+
+**/
+RETURN_STATUS
+EFIAPI
+AcpiTimerLibConstructor (
+  VOID
+  )
+{
+  UINT16 HostBridgeDevId;
+  UINTN Pmba;
+
+  //
+  // Query Host Bridge DID to determine platform type
+  //
+  HostBridgeDevId = PcdGet16 (PcdOvmfHostBridgePciDevId);
+  switch (HostBridgeDevId) {
+    case INTEL_82441_DEVICE_ID:
+      Pmba = POWER_MGMT_REGISTER_PIIX4 (PIIX4_PMBA);
+      break;
+    case INTEL_Q35_MCH_DEVICE_ID:
+      Pmba = POWER_MGMT_REGISTER_Q35 (ICH9_PMBASE);
+      break;
+    default:
+      DEBUG ((DEBUG_ERROR, "%a: Unknown Host Bridge Device ID: 0x%04x\n",
+        __FUNCTION__, HostBridgeDevId));
+      ASSERT (FALSE);
+      return RETURN_UNSUPPORTED;
+  }
+
+  mAcpiTimerIoAddr = (PciRead32 (Pmba) & ~PMBA_RTE) + ACPI_TIMER_OFFSET;
+
+  return RETURN_SUCCESS;
+}
+
+/**
+  Internal function to read the current tick counter of ACPI.
+
+  Read the current ACPI tick counter using the counter address cached
+  by this instance's constructor.
+
+  @return The tick counter read.
+
+**/
+UINT32
+InternalAcpiGetTimerTick (
+  VOID
+  )
+{
+  //
+  //   Return the current ACPI timer value.
+  //
+  return IoRead32 (mAcpiTimerIoAddr);
+}
diff --git a/TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.inf b/TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.inf
new file mode 100644
index 0000000000..80d79e5f21
--- /dev/null
+++ b/TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.inf
@@ -0,0 +1,35 @@
+## @file
+#  DXE ACPI Timer Library Instance.
+#
+#  Copyright (C) 2014, Gabriel L. Somlo <somlo@cmu.edu>
+#  Copyright (c) 2008 - 2010, Intel Corporation. All rights reserved.
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+[Defines]
+  INF_VERSION    = 0x00010005
+  BASE_NAME      = DxeAcpiTimerLib
+  FILE_GUID      = 52DECA02-2EE8-4EAA-8EAD-1AB83F8A5955
+  MODULE_TYPE    = BASE
+  VERSION_STRING = 1.0
+  LIBRARY_CLASS  = TimerLib|DXE_DRIVER DXE_RUNTIME_DRIVER DXE_SMM_DRIVER UEFI_DRIVER UEFI_APPLICATION SMM_CORE
+  CONSTRUCTOR    = AcpiTimerLibConstructor
+
+[Sources]
+  AcpiTimerLib.c
+  AcpiTimerLib.h
+  DxeAcpiTimerLib.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[Pcd]
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfHostBridgePciDevId
+
+[LibraryClasses]
+  BaseLib
+  PciLib
+  IoLib
diff --git a/TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.c b/TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.c
new file mode 100644
index 0000000000..61bc3bf69d
--- /dev/null
+++ b/TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.c
@@ -0,0 +1,152 @@
+/** @file
+  I/O APIC library.
+
+  I/O APIC library assumes I/O APIC is enabled. It does not
+  handles cases where I/O APIC is disabled.
+
+  Copyright (c) 2011 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <Base.h>
+
+#include <Library/IoApicLib.h>
+
+#include <Library/DebugLib.h>
+#include <Library/PcdLib.h>
+#include <Library/IoLib.h>
+#include <Library/LocalApicLib.h>
+
+#include <Register/IoApic.h>
+
+/**
+  Read a 32-bit I/O APIC register.
+
+  If Index is >= 0x100, then ASSERT().
+
+  @param  Index  Specifies the I/O APIC register to read.
+
+  @return  The 32-bit value read from the I/O APIC register specified by Index.
+**/
+UINT32
+EFIAPI
+IoApicRead (
+  IN UINTN  Index
+  )
+{
+  ASSERT (Index < 0x100);
+  MmioWrite8 (PcdGet32 (PcdIoApicBaseAddress) + IOAPIC_INDEX_OFFSET, (UINT8)Index);
+  return MmioRead32 (PcdGet32 (PcdIoApicBaseAddress) + IOAPIC_DATA_OFFSET);
+}
+
+/**
+  Write a 32-bit I/O APIC register.
+
+  If Index is >= 0x100, then ASSERT().
+
+  @param  Index  Specifies the I/O APIC register to write.
+  @param  Value  Specifies the value to write to the I/O APIC register specified by Index.
+
+  @return  The 32-bit value written to I/O APIC register specified by Index.
+**/
+UINT32
+EFIAPI
+IoApicWrite (
+  IN UINTN   Index,
+  IN UINT32  Value
+  )
+{
+  ASSERT (Index < 0x100);
+  MmioWrite8 (PcdGet32 (PcdIoApicBaseAddress) + IOAPIC_INDEX_OFFSET, (UINT8)Index);
+  return MmioWrite32 (PcdGet32 (PcdIoApicBaseAddress) + IOAPIC_DATA_OFFSET, Value);
+}
+
+/**
+  Set the interrupt mask of an I/O APIC interrupt.
+
+  If Irq is larger than the maximum number I/O APIC redirection entries, then ASSERT().
+
+  @param  Irq     Specifies the I/O APIC interrupt to enable or disable.
+  @param  Enable  If TRUE, then enable the I/O APIC interrupt specified by Irq.
+                  If FALSE, then disable the I/O APIC interrupt specified by Irq.
+**/
+VOID
+EFIAPI
+IoApicEnableInterrupt (
+  IN UINTN    Irq,
+  IN BOOLEAN  Enable
+  )
+{
+  IO_APIC_VERSION_REGISTER         Version;
+  IO_APIC_REDIRECTION_TABLE_ENTRY  Entry;
+
+  Version.Uint32 = IoApicRead (IO_APIC_VERSION_REGISTER_INDEX);
+  ASSERT (Version.Bits.MaximumRedirectionEntry < 0xF0);
+  ASSERT (Irq <= Version.Bits.MaximumRedirectionEntry);
+
+  Entry.Uint32.Low = IoApicRead (IO_APIC_REDIRECTION_TABLE_ENTRY_INDEX + Irq * 2);
+  Entry.Bits.Mask = Enable ? 0 : 1;
+  IoApicWrite (IO_APIC_REDIRECTION_TABLE_ENTRY_INDEX + Irq * 2, Entry.Uint32.Low);
+}
+
+/**
+  Configures an I/O APIC interrupt.
+
+  Configure an I/O APIC Redirection Table Entry to deliver an interrupt in physical
+  mode to the Local APIC of the currently executing CPU.  The default state of the
+  entry is for the interrupt to be disabled (masked).  IoApicEnableInterrupts() must
+  be used to enable(unmask) the I/O APIC Interrupt.
+
+  If Irq is larger than the maximum number I/O APIC redirection entries, then ASSERT().
+  If Vector >= 0x100, then ASSERT().
+  If DeliveryMode is not supported, then ASSERT().
+
+  @param  Irq             Specifies the I/O APIC interrupt to initialize.
+  @param  Vector          The 8-bit interrupt vector associated with the I/O APIC
+                          Interrupt.  Must be in the range 0x10..0xFE.
+  @param  DeliveryMode    A 3-bit value that specifies how the recept of the I/O APIC
+                          interrupt is handled.  The only supported values are:
+                            0: IO_APIC_DELIVERY_MODE_FIXED
+                            1: IO_APIC_DELIVERY_MODE_LOWEST_PRIORITY
+                            2: IO_APIC_DELIVERY_MODE_SMI
+                            4: IO_APIC_DELIVERY_MODE_NMI
+                            5: IO_APIC_DELIVERY_MODE_INIT
+                            7: IO_APIC_DELIVERY_MODE_EXTINT
+  @param  LevelTriggered  TRUE specifies a level triggered interrupt.
+                          FALSE specifies an edge triggered interrupt.
+  @param  AssertionLevel  TRUE specified an active high interrupt.
+                          FALSE specifies an active low interrupt.
+**/
+VOID
+EFIAPI
+IoApicConfigureInterrupt (
+  IN UINTN    Irq,
+  IN UINTN    Vector,
+  IN UINTN    DeliveryMode,
+  IN BOOLEAN  LevelTriggered,
+  IN BOOLEAN  AssertionLevel
+  )
+{
+  IO_APIC_VERSION_REGISTER         Version;
+  IO_APIC_REDIRECTION_TABLE_ENTRY  Entry;
+
+  Version.Uint32 = IoApicRead (IO_APIC_VERSION_REGISTER_INDEX);
+  ASSERT (Version.Bits.MaximumRedirectionEntry < 0xF0);
+  ASSERT (Irq <= Version.Bits.MaximumRedirectionEntry);
+  ASSERT (Vector <= 0xFF);
+  ASSERT (DeliveryMode < 8 && DeliveryMode != 6 && DeliveryMode != 3);
+
+  Entry.Uint32.Low = IoApicRead (IO_APIC_REDIRECTION_TABLE_ENTRY_INDEX + Irq * 2);
+  Entry.Bits.Vector          = (UINT8)Vector;
+  Entry.Bits.DeliveryMode    = (UINT32)DeliveryMode;
+  Entry.Bits.DestinationMode = 0;
+  Entry.Bits.Polarity        = AssertionLevel ? 0 : 1;
+  Entry.Bits.TriggerMode     = LevelTriggered ? 1 : 0;
+  Entry.Bits.Mask            = 1;
+  IoApicWrite (IO_APIC_REDIRECTION_TABLE_ENTRY_INDEX + Irq * 2, Entry.Uint32.Low);
+
+  Entry.Uint32.High = IoApicRead (IO_APIC_REDIRECTION_TABLE_ENTRY_INDEX + Irq * 2 + 1);
+  Entry.Bits.DestinationID = GetApicId ();
+  IoApicWrite (IO_APIC_REDIRECTION_TABLE_ENTRY_INDEX + Irq * 2 + 1, Entry.Uint32.High);
+}
diff --git a/TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.inf b/TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.inf
new file mode 100644
index 0000000000..aaf6858291
--- /dev/null
+++ b/TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.inf
@@ -0,0 +1,50 @@
+## @file
+#  NvVarsFileLib
+#
+#  This library saves and restores non-volatile variables in a
+#  file within a file system.
+#
+#  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = BaseFakeLibraryLib
+  MODULE_UNI_FILE                = BaseFakeLibraryLib.uni
+  FILE_GUID                      = 9172fe8b-9a36-40f8-bba5-5d48e45370ec
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = FakeLibraryLib
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32
+#
+
+[Sources]
+  BaseFakeLibraryLib.c
+  Extra.uni
+  UniIncluded.uni
+  
+
+[Packages]
+  MdePkg/MdePkg.dec
+  UefiCpuPkg/UefiCpuPkg.dec
+  PcAtChipsetPkg/PcAtChipsetPkg.dec
+
+[LibraryClasses]
+  DebugLib
+  IoLib
+  PcdLib
+  LocalApicLib
+
+[Pcd]
+  gPcAtChipsetPkgTokenSpaceGuid.PcdIoApicBaseAddress    ## CONSUMES
+
+
+
diff --git a/TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.uni b/TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.uni
new file mode 100644
index 0000000000..950a1eb23d
--- /dev/null
+++ b/TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.uni
@@ -0,0 +1,20 @@
+// /** @file
+// Instance of CPU Library for various architecture.
+//
+// CPU Library implemented using ASM functions for IA-32, X64 and RISCV64,
+// PAL CALLs for IPF, and empty functions for EBC.
+//
+// Copyright (c) 2007 - 2014, Intel Corporation. All rights reserved.<BR>
+// Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
+// Portions copyright (c) 2011 - 2013, ARM Ltd. All rights reserved.<BR>
+// Copyright (c) 2020, Hewlett Packard Enterprise Development LP. All rights reserved.<BR>
+//
+// SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+// **/
+
+
+#string STR_MODULE_ABSTRACT             #language en-US STR_EXTRA_ABSTRACT
+
+#string STR_MODULE_DESCRIPTION          #language en-US "Fake Library Instance try to test the influence which brought by all types of source code files' changing (Copy from PcAtChipsetPkg\Library\BaseIoApicLib)."
+
diff --git a/TestPkg/Library/BaseFakeLibraryLib/Extra.uni b/TestPkg/Library/BaseFakeLibraryLib/Extra.uni
new file mode 100644
index 0000000000..c32e1c71aa
--- /dev/null
+++ b/TestPkg/Library/BaseFakeLibraryLib/Extra.uni
@@ -0,0 +1,26 @@
+// /** @file
+// Instance of CPU Library for various architecture.
+//
+// CPU Library implemented using ASM functions for IA-32, X64 and RISCV64,
+// PAL CALLs for IPF, and empty functions for EBC.
+//
+// Copyright (c) 2007 - 2014, Intel Corporation. All rights reserved.<BR>
+// Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
+// Portions copyright (c) 2011 - 2013, ARM Ltd. All rights reserved.<BR>
+// Copyright (c) 2020, Hewlett Packard Enterprise Development LP. All rights reserved.<BR>
+//
+// SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+// **/
+
+#include "UniIncluded.uni"
+
+
+#string STR_EXTRA_ABSTRACT             
+#language en-US 
+EXTRAINC_ABSTRACT
+
+#string STR_EXTRA_DESCRIPTION          
+#language en-US 
+"This is the Extra DESCRIPTION of the Module"
+
diff --git a/TestPkg/Library/BaseFakeLibraryLib/UniIncluded.uni b/TestPkg/Library/BaseFakeLibraryLib/UniIncluded.uni
new file mode 100644
index 0000000000..d36890f0b5
--- /dev/null
+++ b/TestPkg/Library/BaseFakeLibraryLib/UniIncluded.uni
@@ -0,0 +1,21 @@
+// /** @file
+// Instance of CPU Library for various architecture.
+//
+// CPU Library implemented using ASM functions for IA-32, X64 and RISCV64,
+// PAL CALLs for IPF, and empty functions for EBC.
+//
+// Copyright (c) 2007 - 2014, Intel Corporation. All rights reserved.<BR>
+// Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
+// Portions copyright (c) 2011 - 2013, ARM Ltd. All rights reserved.<BR>
+// Copyright (c) 2020, Hewlett Packard Enterprise Development LP. All rights reserved.<BR>
+//
+// SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+// **/
+
+#langdef en-US  "English"
+
+#string EXTRAINC_ABSTRACT             #language en-US "This is the UNI included in the Extra ABSTRACT of the Module"
+
+#string EXTRAINC_DESCRIPTION          #language en-US "This is the UNI included in the Extra DESCRIPTION of the Module"
+
diff --git a/TestPkg/Library/DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf b/TestPkg/Library/DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf
new file mode 100644
index 0000000000..13063942cd
--- /dev/null
+++ b/TestPkg/Library/DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf
@@ -0,0 +1,40 @@
+## @file
+#  An instance of the PCI Library that is based on both the PCI CF8 Library and
+#  the PCI Express Library.
+#
+#  This PciLib instance caches the OVMF platform type (I440FX vs. Q35) in
+#  its entry point function, then delegates function calls to one of the
+#  PciCf8Lib or PciExpressLib "backends" as appropriate.
+#
+#  Copyright (C) 2016, Red Hat, Inc.
+#
+#  Copyright (c) 2007 - 2014, Intel Corporation. All rights reserved.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = DxePciLibI440FxQ35
+  FILE_GUID                      = 5360bff6-3911-4495-ae3c-b02ff004b585
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = PciLib|DXE_DRIVER DXE_RUNTIME_DRIVER SMM_CORE DXE_SMM_DRIVER UEFI_DRIVER UEFI_APPLICATION
+  CONSTRUCTOR                    = InitializeConfigAccessMethod
+
+#  VALID_ARCHITECTURES           = IA32 X64
+
+[Sources]
+  PciLib.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  PcdLib
+  PciCf8Lib
+  PciExpressLib
+
+[Pcd]
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfHostBridgePciDevId
diff --git a/TestPkg/Library/DxePciLibI440FxQ35/PciLib.c b/TestPkg/Library/DxePciLibI440FxQ35/PciLib.c
new file mode 100644
index 0000000000..866648a578
--- /dev/null
+++ b/TestPkg/Library/DxePciLibI440FxQ35/PciLib.c
@@ -0,0 +1,1223 @@
+/** @file
+  PCI Library functions that use
+  (a) I/O ports 0xCF8 and 0xCFC to perform PCI Configuration cycles, layering
+      on top of one PCI CF8 Library instance; or
+  (b) PCI Library functions that use the 256 MB PCI Express MMIO window to
+      perform PCI Configuration cycles, layering on PCI Express Library.
+
+  The decision is made in the entry point function, based on the OVMF platform
+  type, and then adhered to during the lifetime of the client module.
+
+  Copyright (C) 2016, Red Hat, Inc.
+
+  Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+
+#include <Base.h>
+
+#include <IndustryStandard/Q35MchIch9.h>
+
+#include <Library/PciLib.h>
+#include <Library/PciCf8Lib.h>
+#include <Library/PciExpressLib.h>
+#include <Library/PcdLib.h>
+
+STATIC BOOLEAN mRunningOnQ35;
+
+RETURN_STATUS
+EFIAPI
+InitializeConfigAccessMethod (
+  VOID
+  )
+{
+  mRunningOnQ35 = (PcdGet16 (PcdOvmfHostBridgePciDevId) ==
+                   INTEL_Q35_MCH_DEVICE_ID);
+  return RETURN_SUCCESS;
+}
+
+/**
+  Registers a PCI device so PCI configuration registers may be accessed after
+  SetVirtualAddressMap().
+
+  Registers the PCI device specified by Address so all the PCI configuration registers
+  associated with that PCI device may be accessed after SetVirtualAddressMap() is called.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+
+  @retval RETURN_SUCCESS           The PCI device was registered for runtime access.
+  @retval RETURN_UNSUPPORTED       An attempt was made to call this function
+                                   after ExitBootServices().
+  @retval RETURN_UNSUPPORTED       The resources required to access the PCI device
+                                   at runtime could not be mapped.
+  @retval RETURN_OUT_OF_RESOURCES  There are not enough resources available to
+                                   complete the registration.
+
+**/
+RETURN_STATUS
+EFIAPI
+PciRegisterForRuntimeAccess (
+  IN UINTN  Address
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressRegisterForRuntimeAccess (Address) :
+         PciCf8RegisterForRuntimeAccess (Address);
+}
+
+/**
+  Reads an 8-bit PCI configuration register.
+
+  Reads and returns the 8-bit PCI configuration register specified by Address.
+  This function must guarantee that all PCI read and write operations are
+  serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+
+  @return The read value from the PCI configuration register.
+
+**/
+UINT8
+EFIAPI
+PciRead8 (
+  IN      UINTN                     Address
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressRead8 (Address) :
+         PciCf8Read8 (Address);
+}
+
+/**
+  Writes an 8-bit PCI configuration register.
+
+  Writes the 8-bit PCI configuration register specified by Address with the
+  value specified by Value. Value is returned. This function must guarantee
+  that all PCI read and write operations are serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+  @param  Value   The value to write.
+
+  @return The value written to the PCI configuration register.
+
+**/
+UINT8
+EFIAPI
+PciWrite8 (
+  IN      UINTN                     Address,
+  IN      UINT8                     Value
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressWrite8 (Address, Value) :
+         PciCf8Write8 (Address, Value);
+}
+
+/**
+  Performs a bitwise OR of an 8-bit PCI configuration register with
+  an 8-bit value.
+
+  Reads the 8-bit PCI configuration register specified by Address, performs a
+  bitwise OR between the read result and the value specified by
+  OrData, and writes the result to the 8-bit PCI configuration register
+  specified by Address. The value written to the PCI configuration register is
+  returned. This function must guarantee that all PCI read and write operations
+  are serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+  @param  OrData  The value to OR with the PCI configuration register.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT8
+EFIAPI
+PciOr8 (
+  IN      UINTN                     Address,
+  IN      UINT8                     OrData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressOr8 (Address, OrData) :
+         PciCf8Or8 (Address, OrData);
+}
+
+/**
+  Performs a bitwise AND of an 8-bit PCI configuration register with an 8-bit
+  value.
+
+  Reads the 8-bit PCI configuration register specified by Address, performs a
+  bitwise AND between the read result and the value specified by AndData, and
+  writes the result to the 8-bit PCI configuration register specified by
+  Address. The value written to the PCI configuration register is returned.
+  This function must guarantee that all PCI read and write operations are
+  serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+  @param  AndData The value to AND with the PCI configuration register.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT8
+EFIAPI
+PciAnd8 (
+  IN      UINTN                     Address,
+  IN      UINT8                     AndData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressAnd8 (Address, AndData) :
+         PciCf8And8 (Address, AndData);
+}
+
+/**
+  Performs a bitwise AND of an 8-bit PCI configuration register with an 8-bit
+  value, followed a  bitwise OR with another 8-bit value.
+
+  Reads the 8-bit PCI configuration register specified by Address, performs a
+  bitwise AND between the read result and the value specified by AndData,
+  performs a bitwise OR between the result of the AND operation and
+  the value specified by OrData, and writes the result to the 8-bit PCI
+  configuration register specified by Address. The value written to the PCI
+  configuration register is returned. This function must guarantee that all PCI
+  read and write operations are serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+  @param  AndData The value to AND with the PCI configuration register.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT8
+EFIAPI
+PciAndThenOr8 (
+  IN      UINTN                     Address,
+  IN      UINT8                     AndData,
+  IN      UINT8                     OrData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressAndThenOr8 (Address, AndData, OrData) :
+         PciCf8AndThenOr8 (Address, AndData, OrData);
+}
+
+/**
+  Reads a bit field of a PCI configuration register.
+
+  Reads the bit field in an 8-bit PCI configuration register. The bit field is
+  specified by the StartBit and the EndBit. The value of the bit field is
+  returned.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+
+  @return The value of the bit field read from the PCI configuration register.
+
+**/
+UINT8
+EFIAPI
+PciBitFieldRead8 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldRead8 (Address, StartBit, EndBit) :
+         PciCf8BitFieldRead8 (Address, StartBit, EndBit);
+}
+
+/**
+  Writes a bit field to a PCI configuration register.
+
+  Writes Value to the bit field of the PCI configuration register. The bit
+  field is specified by the StartBit and the EndBit. All other bits in the
+  destination PCI configuration register are preserved. The new value of the
+  8-bit register is returned.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  Value     The new value of the bit field.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT8
+EFIAPI
+PciBitFieldWrite8 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     Value
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldWrite8 (Address, StartBit, EndBit, Value) :
+         PciCf8BitFieldWrite8 (Address, StartBit, EndBit, Value);
+}
+
+/**
+  Reads a bit field in an 8-bit PCI configuration, performs a bitwise OR, and
+  writes the result back to the bit field in the 8-bit port.
+
+  Reads the 8-bit PCI configuration register specified by Address, performs a
+  bitwise OR between the read result and the value specified by
+  OrData, and writes the result to the 8-bit PCI configuration register
+  specified by Address. The value written to the PCI configuration register is
+  returned. This function must guarantee that all PCI read and write operations
+  are serialized. Extra left bits in OrData are stripped.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  OrData    The value to OR with the PCI configuration register.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT8
+EFIAPI
+PciBitFieldOr8 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     OrData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldOr8 (Address, StartBit, EndBit, OrData) :
+         PciCf8BitFieldOr8 (Address, StartBit, EndBit, OrData);
+}
+
+/**
+  Reads a bit field in an 8-bit PCI configuration register, performs a bitwise
+  AND, and writes the result back to the bit field in the 8-bit register.
+
+  Reads the 8-bit PCI configuration register specified by Address, performs a
+  bitwise AND between the read result and the value specified by AndData, and
+  writes the result to the 8-bit PCI configuration register specified by
+  Address. The value written to the PCI configuration register is returned.
+  This function must guarantee that all PCI read and write operations are
+  serialized. Extra left bits in AndData are stripped.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  AndData   The value to AND with the PCI configuration register.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT8
+EFIAPI
+PciBitFieldAnd8 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     AndData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldAnd8 (Address, StartBit, EndBit, AndData) :
+         PciCf8BitFieldAnd8 (Address, StartBit, EndBit, AndData);
+}
+
+/**
+  Reads a bit field in an 8-bit port, performs a bitwise AND followed by a
+  bitwise OR, and writes the result back to the bit field in the
+  8-bit port.
+
+  Reads the 8-bit PCI configuration register specified by Address, performs a
+  bitwise AND followed by a bitwise OR between the read result and
+  the value specified by AndData, and writes the result to the 8-bit PCI
+  configuration register specified by Address. The value written to the PCI
+  configuration register is returned. This function must guarantee that all PCI
+  read and write operations are serialized. Extra left bits in both AndData and
+  OrData are stripped.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  AndData   The value to AND with the PCI configuration register.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT8
+EFIAPI
+PciBitFieldAndThenOr8 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     AndData,
+  IN      UINT8                     OrData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldAndThenOr8 (Address, StartBit, EndBit, AndData, OrData) :
+         PciCf8BitFieldAndThenOr8 (Address, StartBit, EndBit, AndData, OrData);
+}
+
+/**
+  Reads a 16-bit PCI configuration register.
+
+  Reads and returns the 16-bit PCI configuration register specified by Address.
+  This function must guarantee that all PCI read and write operations are
+  serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+
+  @return The read value from the PCI configuration register.
+
+**/
+UINT16
+EFIAPI
+PciRead16 (
+  IN      UINTN                     Address
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressRead16 (Address) :
+         PciCf8Read16 (Address);
+}
+
+/**
+  Writes a 16-bit PCI configuration register.
+
+  Writes the 16-bit PCI configuration register specified by Address with the
+  value specified by Value. Value is returned. This function must guarantee
+  that all PCI read and write operations are serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+  @param  Value   The value to write.
+
+  @return The value written to the PCI configuration register.
+
+**/
+UINT16
+EFIAPI
+PciWrite16 (
+  IN      UINTN                     Address,
+  IN      UINT16                    Value
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressWrite16 (Address, Value) :
+         PciCf8Write16 (Address, Value);
+}
+
+/**
+  Performs a bitwise OR of a 16-bit PCI configuration register with
+  a 16-bit value.
+
+  Reads the 16-bit PCI configuration register specified by Address, performs a
+  bitwise OR between the read result and the value specified by
+  OrData, and writes the result to the 16-bit PCI configuration register
+  specified by Address. The value written to the PCI configuration register is
+  returned. This function must guarantee that all PCI read and write operations
+  are serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+  @param  OrData  The value to OR with the PCI configuration register.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT16
+EFIAPI
+PciOr16 (
+  IN      UINTN                     Address,
+  IN      UINT16                    OrData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressOr16 (Address, OrData) :
+         PciCf8Or16 (Address, OrData);
+}
+
+/**
+  Performs a bitwise AND of a 16-bit PCI configuration register with a 16-bit
+  value.
+
+  Reads the 16-bit PCI configuration register specified by Address, performs a
+  bitwise AND between the read result and the value specified by AndData, and
+  writes the result to the 16-bit PCI configuration register specified by
+  Address. The value written to the PCI configuration register is returned.
+  This function must guarantee that all PCI read and write operations are
+  serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+  @param  AndData The value to AND with the PCI configuration register.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT16
+EFIAPI
+PciAnd16 (
+  IN      UINTN                     Address,
+  IN      UINT16                    AndData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressAnd16 (Address, AndData) :
+         PciCf8And16 (Address, AndData);
+}
+
+/**
+  Performs a bitwise AND of a 16-bit PCI configuration register with a 16-bit
+  value, followed a  bitwise OR with another 16-bit value.
+
+  Reads the 16-bit PCI configuration register specified by Address, performs a
+  bitwise AND between the read result and the value specified by AndData,
+  performs a bitwise OR between the result of the AND operation and
+  the value specified by OrData, and writes the result to the 16-bit PCI
+  configuration register specified by Address. The value written to the PCI
+  configuration register is returned. This function must guarantee that all PCI
+  read and write operations are serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+  @param  AndData The value to AND with the PCI configuration register.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT16
+EFIAPI
+PciAndThenOr16 (
+  IN      UINTN                     Address,
+  IN      UINT16                    AndData,
+  IN      UINT16                    OrData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressAndThenOr16 (Address, AndData, OrData) :
+         PciCf8AndThenOr16 (Address, AndData, OrData);
+}
+
+/**
+  Reads a bit field of a PCI configuration register.
+
+  Reads the bit field in a 16-bit PCI configuration register. The bit field is
+  specified by the StartBit and the EndBit. The value of the bit field is
+  returned.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+
+  @return The value of the bit field read from the PCI configuration register.
+
+**/
+UINT16
+EFIAPI
+PciBitFieldRead16 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldRead16 (Address, StartBit, EndBit) :
+         PciCf8BitFieldRead16 (Address, StartBit, EndBit);
+}
+
+/**
+  Writes a bit field to a PCI configuration register.
+
+  Writes Value to the bit field of the PCI configuration register. The bit
+  field is specified by the StartBit and the EndBit. All other bits in the
+  destination PCI configuration register are preserved. The new value of the
+  16-bit register is returned.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  Value     The new value of the bit field.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT16
+EFIAPI
+PciBitFieldWrite16 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    Value
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldWrite16 (Address, StartBit, EndBit, Value) :
+         PciCf8BitFieldWrite16 (Address, StartBit, EndBit, Value);
+}
+
+/**
+  Reads a bit field in a 16-bit PCI configuration, performs a bitwise OR, and
+  writes the result back to the bit field in the 16-bit port.
+
+  Reads the 16-bit PCI configuration register specified by Address, performs a
+  bitwise OR between the read result and the value specified by
+  OrData, and writes the result to the 16-bit PCI configuration register
+  specified by Address. The value written to the PCI configuration register is
+  returned. This function must guarantee that all PCI read and write operations
+  are serialized. Extra left bits in OrData are stripped.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  OrData    The value to OR with the PCI configuration register.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT16
+EFIAPI
+PciBitFieldOr16 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    OrData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldOr16 (Address, StartBit, EndBit, OrData) :
+         PciCf8BitFieldOr16 (Address, StartBit, EndBit, OrData);
+}
+
+/**
+  Reads a bit field in a 16-bit PCI configuration register, performs a bitwise
+  AND, and writes the result back to the bit field in the 16-bit register.
+
+  Reads the 16-bit PCI configuration register specified by Address, performs a
+  bitwise AND between the read result and the value specified by AndData, and
+  writes the result to the 16-bit PCI configuration register specified by
+  Address. The value written to the PCI configuration register is returned.
+  This function must guarantee that all PCI read and write operations are
+  serialized. Extra left bits in AndData are stripped.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  AndData   The value to AND with the PCI configuration register.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT16
+EFIAPI
+PciBitFieldAnd16 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    AndData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldAnd16 (Address, StartBit, EndBit, AndData) :
+         PciCf8BitFieldAnd16 (Address, StartBit, EndBit, AndData);
+}
+
+/**
+  Reads a bit field in a 16-bit port, performs a bitwise AND followed by a
+  bitwise OR, and writes the result back to the bit field in the
+  16-bit port.
+
+  Reads the 16-bit PCI configuration register specified by Address, performs a
+  bitwise AND followed by a bitwise OR between the read result and
+  the value specified by AndData, and writes the result to the 16-bit PCI
+  configuration register specified by Address. The value written to the PCI
+  configuration register is returned. This function must guarantee that all PCI
+  read and write operations are serialized. Extra left bits in both AndData and
+  OrData are stripped.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  AndData   The value to AND with the PCI configuration register.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT16
+EFIAPI
+PciBitFieldAndThenOr16 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    AndData,
+  IN      UINT16                    OrData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldAndThenOr16 (Address, StartBit, EndBit, AndData, OrData) :
+         PciCf8BitFieldAndThenOr16 (Address, StartBit, EndBit, AndData, OrData);
+}
+
+/**
+  Reads a 32-bit PCI configuration register.
+
+  Reads and returns the 32-bit PCI configuration register specified by Address.
+  This function must guarantee that all PCI read and write operations are
+  serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+
+  @return The read value from the PCI configuration register.
+
+**/
+UINT32
+EFIAPI
+PciRead32 (
+  IN      UINTN                     Address
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressRead32 (Address) :
+         PciCf8Read32 (Address);
+}
+
+/**
+  Writes a 32-bit PCI configuration register.
+
+  Writes the 32-bit PCI configuration register specified by Address with the
+  value specified by Value. Value is returned. This function must guarantee
+  that all PCI read and write operations are serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+  @param  Value   The value to write.
+
+  @return The value written to the PCI configuration register.
+
+**/
+UINT32
+EFIAPI
+PciWrite32 (
+  IN      UINTN                     Address,
+  IN      UINT32                    Value
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressWrite32 (Address, Value) :
+         PciCf8Write32 (Address, Value);
+}
+
+/**
+  Performs a bitwise OR of a 32-bit PCI configuration register with
+  a 32-bit value.
+
+  Reads the 32-bit PCI configuration register specified by Address, performs a
+  bitwise OR between the read result and the value specified by
+  OrData, and writes the result to the 32-bit PCI configuration register
+  specified by Address. The value written to the PCI configuration register is
+  returned. This function must guarantee that all PCI read and write operations
+  are serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+  @param  OrData  The value to OR with the PCI configuration register.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT32
+EFIAPI
+PciOr32 (
+  IN      UINTN                     Address,
+  IN      UINT32                    OrData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressOr32 (Address, OrData) :
+         PciCf8Or32 (Address, OrData);
+}
+
+/**
+  Performs a bitwise AND of a 32-bit PCI configuration register with a 32-bit
+  value.
+
+  Reads the 32-bit PCI configuration register specified by Address, performs a
+  bitwise AND between the read result and the value specified by AndData, and
+  writes the result to the 32-bit PCI configuration register specified by
+  Address. The value written to the PCI configuration register is returned.
+  This function must guarantee that all PCI read and write operations are
+  serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+  @param  AndData The value to AND with the PCI configuration register.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT32
+EFIAPI
+PciAnd32 (
+  IN      UINTN                     Address,
+  IN      UINT32                    AndData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressAnd32 (Address, AndData) :
+         PciCf8And32 (Address, AndData);
+}
+
+/**
+  Performs a bitwise AND of a 32-bit PCI configuration register with a 32-bit
+  value, followed a  bitwise OR with another 32-bit value.
+
+  Reads the 32-bit PCI configuration register specified by Address, performs a
+  bitwise AND between the read result and the value specified by AndData,
+  performs a bitwise OR between the result of the AND operation and
+  the value specified by OrData, and writes the result to the 32-bit PCI
+  configuration register specified by Address. The value written to the PCI
+  configuration register is returned. This function must guarantee that all PCI
+  read and write operations are serialized.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Address The address that encodes the PCI Bus, Device, Function and
+                  Register.
+  @param  AndData The value to AND with the PCI configuration register.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT32
+EFIAPI
+PciAndThenOr32 (
+  IN      UINTN                     Address,
+  IN      UINT32                    AndData,
+  IN      UINT32                    OrData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressAndThenOr32 (Address, AndData, OrData) :
+         PciCf8AndThenOr32 (Address, AndData, OrData);
+}
+
+/**
+  Reads a bit field of a PCI configuration register.
+
+  Reads the bit field in a 32-bit PCI configuration register. The bit field is
+  specified by the StartBit and the EndBit. The value of the bit field is
+  returned.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+
+  @return The value of the bit field read from the PCI configuration register.
+
+**/
+UINT32
+EFIAPI
+PciBitFieldRead32 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldRead32 (Address, StartBit, EndBit) :
+         PciCf8BitFieldRead32 (Address, StartBit, EndBit);
+}
+
+/**
+  Writes a bit field to a PCI configuration register.
+
+  Writes Value to the bit field of the PCI configuration register. The bit
+  field is specified by the StartBit and the EndBit. All other bits in the
+  destination PCI configuration register are preserved. The new value of the
+  32-bit register is returned.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  Value     The new value of the bit field.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT32
+EFIAPI
+PciBitFieldWrite32 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    Value
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldWrite32 (Address, StartBit, EndBit, Value) :
+         PciCf8BitFieldWrite32 (Address, StartBit, EndBit, Value);
+}
+
+/**
+  Reads a bit field in a 32-bit PCI configuration, performs a bitwise OR, and
+  writes the result back to the bit field in the 32-bit port.
+
+  Reads the 32-bit PCI configuration register specified by Address, performs a
+  bitwise OR between the read result and the value specified by
+  OrData, and writes the result to the 32-bit PCI configuration register
+  specified by Address. The value written to the PCI configuration register is
+  returned. This function must guarantee that all PCI read and write operations
+  are serialized. Extra left bits in OrData are stripped.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  OrData    The value to OR with the PCI configuration register.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT32
+EFIAPI
+PciBitFieldOr32 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    OrData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldOr32 (Address, StartBit, EndBit, OrData) :
+         PciCf8BitFieldOr32 (Address, StartBit, EndBit, OrData);
+}
+
+/**
+  Reads a bit field in a 32-bit PCI configuration register, performs a bitwise
+  AND, and writes the result back to the bit field in the 32-bit register.
+
+  Reads the 32-bit PCI configuration register specified by Address, performs a
+  bitwise AND between the read result and the value specified by AndData, and
+  writes the result to the 32-bit PCI configuration register specified by
+  Address. The value written to the PCI configuration register is returned.
+  This function must guarantee that all PCI read and write operations are
+  serialized. Extra left bits in AndData are stripped.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  AndData   The value to AND with the PCI configuration register.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT32
+EFIAPI
+PciBitFieldAnd32 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    AndData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldAnd32 (Address, StartBit, EndBit, AndData) :
+         PciCf8BitFieldAnd32 (Address, StartBit, EndBit, AndData);
+}
+
+/**
+  Reads a bit field in a 32-bit port, performs a bitwise AND followed by a
+  bitwise OR, and writes the result back to the bit field in the
+  32-bit port.
+
+  Reads the 32-bit PCI configuration register specified by Address, performs a
+  bitwise AND followed by a bitwise OR between the read result and
+  the value specified by AndData, and writes the result to the 32-bit PCI
+  configuration register specified by Address. The value written to the PCI
+  configuration register is returned. This function must guarantee that all PCI
+  read and write operations are serialized. Extra left bits in both AndData and
+  OrData are stripped.
+
+  If Address > 0x0FFFFFFF, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   The PCI configuration register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  AndData   The value to AND with the PCI configuration register.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The value written back to the PCI configuration register.
+
+**/
+UINT32
+EFIAPI
+PciBitFieldAndThenOr32 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    AndData,
+  IN      UINT32                    OrData
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressBitFieldAndThenOr32 (Address, StartBit, EndBit, AndData, OrData) :
+         PciCf8BitFieldAndThenOr32 (Address, StartBit, EndBit, AndData, OrData);
+}
+
+/**
+  Reads a range of PCI configuration registers into a caller supplied buffer.
+
+  Reads the range of PCI configuration registers specified by StartAddress and
+  Size into the buffer specified by Buffer. This function only allows the PCI
+  configuration registers from a single PCI function to be read. Size is
+  returned. When possible 32-bit PCI configuration read cycles are used to read
+  from StartAddress to StartAddress + Size. Due to alignment restrictions, 8-bit
+  and 16-bit PCI configuration read cycles may be used at the beginning and the
+  end of the range.
+
+  If StartAddress > 0x0FFFFFFF, then ASSERT().
+  If ((StartAddress & 0xFFF) + Size) > 0x1000, then ASSERT().
+  If Size > 0 and Buffer is NULL, then ASSERT().
+
+  @param  StartAddress  The starting address that encodes the PCI Bus, Device,
+                        Function and Register.
+  @param  Size          The size in bytes of the transfer.
+  @param  Buffer        The pointer to a buffer receiving the data read.
+
+  @return Size
+
+**/
+UINTN
+EFIAPI
+PciReadBuffer (
+  IN      UINTN                     StartAddress,
+  IN      UINTN                     Size,
+  OUT     VOID                      *Buffer
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressReadBuffer (StartAddress, Size, Buffer) :
+         PciCf8ReadBuffer (StartAddress, Size, Buffer);
+}
+
+/**
+  Copies the data in a caller supplied buffer to a specified range of PCI
+  configuration space.
+
+  Writes the range of PCI configuration registers specified by StartAddress and
+  Size from the buffer specified by Buffer. This function only allows the PCI
+  configuration registers from a single PCI function to be written. Size is
+  returned. When possible 32-bit PCI configuration write cycles are used to
+  write from StartAddress to StartAddress + Size. Due to alignment restrictions,
+  8-bit and 16-bit PCI configuration write cycles may be used at the beginning
+  and the end of the range.
+
+  If StartAddress > 0x0FFFFFFF, then ASSERT().
+  If ((StartAddress & 0xFFF) + Size) > 0x1000, then ASSERT().
+  If Size > 0 and Buffer is NULL, then ASSERT().
+
+  @param  StartAddress  The starting address that encodes the PCI Bus, Device,
+                        Function and Register.
+  @param  Size          The size in bytes of the transfer.
+  @param  Buffer        The pointer to a buffer containing the data to write.
+
+  @return Size written to StartAddress.
+
+**/
+UINTN
+EFIAPI
+PciWriteBuffer (
+  IN      UINTN                     StartAddress,
+  IN      UINTN                     Size,
+  IN      VOID                      *Buffer
+  )
+{
+  return mRunningOnQ35 ?
+         PciExpressWriteBuffer (StartAddress, Size, Buffer) :
+         PciCf8WriteBuffer (StartAddress, Size, Buffer);
+}
diff --git a/TestPkg/Library/NvVarsFileLib/FsAccess.c b/TestPkg/Library/NvVarsFileLib/FsAccess.c
new file mode 100644
index 0000000000..8fbea471c0
--- /dev/null
+++ b/TestPkg/Library/NvVarsFileLib/FsAccess.c
@@ -0,0 +1,508 @@
+/** @file
+  File System Access for NvVarsFileLib
+
+  Copyright (c) 2004 - 2014, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include "NvVarsFileLib.h"
+
+#include <Library/BaseMemoryLib.h>
+#include <Library/DebugLib.h>
+#include <Library/MemoryAllocationLib.h>
+
+
+/**
+  Open the NvVars file for reading or writing
+
+  @param[in]  FsHandle - Handle for a gEfiSimpleFileSystemProtocolGuid instance
+  @param[in]  ReadingFile - TRUE: open the file for reading.  FALSE: writing
+  @param[out] NvVarsFile - If EFI_SUCCESS is returned, then this is updated
+                           with the opened NvVars file.
+
+  @return     EFI_SUCCESS if the file was opened
+
+**/
+EFI_STATUS
+GetNvVarsFile (
+  IN  EFI_HANDLE            FsHandle,
+  IN  BOOLEAN               ReadingFile,
+  OUT EFI_FILE_HANDLE       *NvVarsFile
+  )
+{
+  EFI_STATUS                            Status;
+  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL       *Fs;
+  EFI_FILE_HANDLE                       Root;
+
+  //
+  // Get the FileSystem protocol on that handle
+  //
+  Status = gBS->HandleProtocol (
+                  FsHandle,
+                  &gEfiSimpleFileSystemProtocolGuid,
+                  (VOID **)&Fs
+                  );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Get the volume (the root directory)
+  //
+  Status = Fs->OpenVolume (Fs, &Root);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Attempt to open the NvVars file in the root directory
+  //
+  Status = Root->Open (
+                   Root,
+                   NvVarsFile,
+                   L"NvVars",
+                   ReadingFile ?
+                     EFI_FILE_MODE_READ :
+                     (
+                       EFI_FILE_MODE_CREATE |
+                       EFI_FILE_MODE_READ |
+                       EFI_FILE_MODE_WRITE
+                     ),
+                   0
+                   );
+
+  return Status;
+}
+
+
+/**
+  Open the NvVars file for reading or writing
+
+  @param[in]  File - The file to inspect
+  @param[out] Exists - Returns whether the file exists
+  @param[out] Size - Returns the size of the file
+                     (0 if the file does not exist)
+
+**/
+VOID
+NvVarsFileReadCheckup (
+  IN  EFI_FILE_HANDLE        File,
+  OUT BOOLEAN                *Exists,
+  OUT UINTN                  *Size
+  )
+{
+  EFI_FILE_INFO               *FileInfo;
+
+  *Exists = FALSE;
+  *Size = 0;
+
+  FileInfo = FileHandleGetInfo (File);
+  if (FileInfo == NULL) {
+    return;
+  }
+
+  if ((FileInfo->Attribute & EFI_FILE_DIRECTORY) != 0) {
+    FreePool (FileInfo);
+    return;
+  }
+
+  *Exists = TRUE;
+  *Size = (UINTN) FileInfo->FileSize;
+
+  FreePool (FileInfo);
+}
+
+
+/**
+  Open the NvVars file for reading or writing
+
+  @param[in]  File - The file to inspect
+  @param[out] Exists - Returns whether the file exists
+  @param[out] Size - Returns the size of the file
+                     (0 if the file does not exist)
+
+**/
+EFI_STATUS
+FileHandleEmpty (
+  IN  EFI_FILE_HANDLE        File
+  )
+{
+  EFI_STATUS                  Status;
+  EFI_FILE_INFO               *FileInfo;
+
+  //
+  // Retrieve the FileInfo structure
+  //
+  FileInfo = FileHandleGetInfo (File);
+  if (FileInfo == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // If the path is a directory, then return an error
+  //
+  if ((FileInfo->Attribute & EFI_FILE_DIRECTORY) != 0) {
+    FreePool (FileInfo);
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // If the file size is already 0, then it is empty, so
+  // we can return success.
+  //
+  if (FileInfo->FileSize == 0) {
+    FreePool (FileInfo);
+    return EFI_SUCCESS;
+  }
+
+  //
+  // Set the file size to 0.
+  //
+  FileInfo->FileSize = 0;
+  Status = FileHandleSetInfo (File, FileInfo);
+
+  FreePool (FileInfo);
+
+  return Status;
+}
+
+
+/**
+  Reads a file to a newly allocated buffer
+
+  @param[in]  File - The file to read
+  @param[in]  ReadSize - The size of data to read from the file
+
+  @return     Pointer to buffer allocated to hold the file
+              contents.  NULL if an error occurred.
+
+**/
+VOID*
+FileHandleReadToNewBuffer (
+  IN EFI_FILE_HANDLE            FileHandle,
+  IN UINTN                      ReadSize
+  )
+{
+  EFI_STATUS                  Status;
+  UINTN                       ActualReadSize;
+  VOID                        *FileContents;
+
+  ActualReadSize = ReadSize;
+  FileContents = AllocatePool (ReadSize);
+  if (FileContents != NULL) {
+    Status = FileHandleRead (
+               FileHandle,
+               &ReadSize,
+               FileContents
+               );
+    if (EFI_ERROR (Status) || (ActualReadSize != ReadSize)) {
+      FreePool (FileContents);
+      return NULL;
+    }
+  }
+
+  return FileContents;
+}
+
+
+/**
+  Reads the contents of the NvVars file on the file system
+
+  @param[in]  FsHandle - Handle for a gEfiSimpleFileSystemProtocolGuid instance
+
+  @return     EFI_STATUS based on the success or failure of the file read
+
+**/
+EFI_STATUS
+ReadNvVarsFile (
+  IN  EFI_HANDLE            FsHandle
+  )
+{
+  EFI_STATUS                  Status;
+  EFI_FILE_HANDLE             File;
+  UINTN                       FileSize;
+  BOOLEAN                     FileExists;
+  VOID                        *FileContents;
+  EFI_HANDLE                  SerializedVariables;
+
+  Status = GetNvVarsFile (FsHandle, TRUE, &File);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_INFO, "FsAccess.c: Could not open NV Variables file on this file system\n"));
+    return Status;
+  }
+
+  NvVarsFileReadCheckup (File, &FileExists, &FileSize);
+  if (FileSize == 0) {
+    FileHandleClose (File);
+    return EFI_UNSUPPORTED;
+  }
+
+  FileContents = FileHandleReadToNewBuffer (File, FileSize);
+  if (FileContents == NULL) {
+    FileHandleClose (File);
+    return EFI_UNSUPPORTED;
+  }
+
+  DEBUG ((
+    DEBUG_INFO,
+    "FsAccess.c: Read %Lu bytes from NV Variables file\n",
+    (UINT64)FileSize
+    ));
+
+  Status = SerializeVariablesNewInstanceFromBuffer (
+             &SerializedVariables,
+             FileContents,
+             FileSize
+             );
+  if (!RETURN_ERROR (Status)) {
+    Status = SerializeVariablesSetSerializedVariables (SerializedVariables);
+  }
+
+  FreePool (FileContents);
+  FileHandleClose (File);
+
+  return Status;
+}
+
+
+/**
+  Writes a variable to indicate that the NV variables
+  have been loaded from the file system.
+
+**/
+STATIC
+VOID
+SetNvVarsVariable (
+  VOID
+  )
+{
+  BOOLEAN                        VarData;
+  UINTN                          Size;
+
+  //
+  // Write a variable to indicate we've already loaded the
+  // variable data.  If it is found, we skip the loading on
+  // subsequent attempts.
+  //
+  Size = sizeof (VarData);
+  VarData = TRUE;
+  gRT->SetVariable (
+         L"NvVars",
+         &gEfiSimpleFileSystemProtocolGuid,
+         EFI_VARIABLE_NON_VOLATILE |
+           EFI_VARIABLE_BOOTSERVICE_ACCESS |
+           EFI_VARIABLE_RUNTIME_ACCESS,
+         Size,
+         (VOID*) &VarData
+         );
+}
+
+
+/**
+  Loads the non-volatile variables from the NvVars file on the
+  given file system.
+
+  @param[in]  FsHandle - Handle for a gEfiSimpleFileSystemProtocolGuid instance
+
+  @return     EFI_STATUS based on the success or failure of load operation
+
+**/
+EFI_STATUS
+LoadNvVarsFromFs (
+  EFI_HANDLE                            FsHandle
+  )
+{
+  EFI_STATUS                     Status;
+  BOOLEAN                        VarData;
+  UINTN                          Size;
+
+  DEBUG ((DEBUG_INFO, "FsAccess.c: LoadNvVarsFromFs\n"));
+
+  //
+  // We write a variable to indicate we've already loaded the
+  // variable data.  If it is found, we skip the loading.
+  //
+  // This is relevant if the non-volatile variable have been
+  // able to survive a reboot operation.  In that case, we don't
+  // want to re-load the file as it would overwrite newer changes
+  // made to the variables.
+  //
+  Size = sizeof (VarData);
+  VarData = TRUE;
+  Status = gRT->GetVariable (
+                  L"NvVars",
+                  &gEfiSimpleFileSystemProtocolGuid,
+                  NULL,
+                  &Size,
+                  (VOID*) &VarData
+                  );
+  if (Status == EFI_SUCCESS) {
+    DEBUG ((DEBUG_INFO, "NV Variables were already loaded\n"));
+    return EFI_ALREADY_STARTED;
+  }
+
+  //
+  // Attempt to restore the variables from the NvVars file.
+  //
+  Status = ReadNvVarsFile (FsHandle);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_INFO, "Error while restoring NV variable data\n"));
+    return Status;
+  }
+
+  //
+  // Write a variable to indicate we've already loaded the
+  // variable data.  If it is found, we skip the loading on
+  // subsequent attempts.
+  //
+  SetNvVarsVariable();
+
+  DEBUG ((
+    DEBUG_INFO,
+    "FsAccess.c: Read NV Variables file (size=%Lu)\n",
+    (UINT64)Size
+    ));
+
+  return Status;
+}
+
+
+STATIC
+RETURN_STATUS
+EFIAPI
+IterateVariablesCallbackAddAllNvVariables (
+  IN  VOID                         *Context,
+  IN  CHAR16                       *VariableName,
+  IN  EFI_GUID                     *VendorGuid,
+  IN  UINT32                       Attributes,
+  IN  UINTN                        DataSize,
+  IN  VOID                         *Data
+  )
+{
+  EFI_HANDLE  Instance;
+
+  Instance = (EFI_HANDLE) Context;
+
+  //
+  // Only save non-volatile variables
+  //
+  if ((Attributes & EFI_VARIABLE_NON_VOLATILE) == 0) {
+    return RETURN_SUCCESS;
+  }
+
+  return SerializeVariablesAddVariable (
+           Instance,
+           VariableName,
+           VendorGuid,
+           Attributes,
+           DataSize,
+           Data
+           );
+}
+
+
+/**
+  Saves the non-volatile variables into the NvVars file on the
+  given file system.
+
+  @param[in]  FsHandle - Handle for a gEfiSimpleFileSystemProtocolGuid instance
+
+  @return     EFI_STATUS based on the success or failure of load operation
+
+**/
+EFI_STATUS
+SaveNvVarsToFs (
+  EFI_HANDLE                            FsHandle
+  )
+{
+  EFI_STATUS                  Status;
+  EFI_FILE_HANDLE             File;
+  UINTN                       WriteSize;
+  UINTN                       VariableDataSize;
+  VOID                        *VariableData;
+  EFI_HANDLE                  SerializedVariables;
+
+  SerializedVariables = NULL;
+
+  Status = SerializeVariablesNewInstance (&SerializedVariables);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  Status = SerializeVariablesIterateSystemVariables (
+             IterateVariablesCallbackAddAllNvVariables,
+             (VOID*) SerializedVariables
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  VariableData = NULL;
+  VariableDataSize = 0;
+  Status = SerializeVariablesToBuffer (
+             SerializedVariables,
+             NULL,
+             &VariableDataSize
+             );
+  if (Status == RETURN_BUFFER_TOO_SMALL) {
+    VariableData = AllocatePool (VariableDataSize);
+    if (VariableData == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+    } else {
+      Status = SerializeVariablesToBuffer (
+                 SerializedVariables,
+                 VariableData,
+                 &VariableDataSize
+                 );
+    }
+  }
+
+  SerializeVariablesFreeInstance (SerializedVariables);
+
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Open the NvVars file for writing.
+  //
+  Status = GetNvVarsFile (FsHandle, FALSE, &File);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_INFO, "FsAccess.c: Unable to open file to saved NV Variables\n"));
+    return Status;
+  }
+
+  //
+  // Empty the starting file contents.
+  //
+  Status = FileHandleEmpty (File);
+  if (EFI_ERROR (Status)) {
+    FileHandleClose (File);
+    return Status;
+  }
+
+  WriteSize = VariableDataSize;
+  Status = FileHandleWrite (File, &WriteSize, VariableData);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  FileHandleClose (File);
+
+  if (!EFI_ERROR (Status)) {
+    //
+    // Write a variable to indicate we've already loaded the
+    // variable data.  If it is found, we skip the loading on
+    // subsequent attempts.
+    //
+    SetNvVarsVariable();
+
+    DEBUG ((DEBUG_INFO, "Saved NV Variables to NvVars file\n"));
+  }
+
+  return Status;
+
+}
+
+
diff --git a/TestPkg/Library/NvVarsFileLib/NvVarsFileLib.c b/TestPkg/Library/NvVarsFileLib/NvVarsFileLib.c
new file mode 100644
index 0000000000..7395723a92
--- /dev/null
+++ b/TestPkg/Library/NvVarsFileLib/NvVarsFileLib.c
@@ -0,0 +1,77 @@
+/** @file
+  Save Non-Volatile Variables to a file system.
+
+  Copyright (c) 2009, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include "NvVarsFileLib.h"
+#include <Library/DebugLib.h>
+#include <Library/NvVarsFileLib.h>
+
+EFI_HANDLE    mNvVarsFileLibFsHandle = NULL;
+
+
+/**
+  Attempts to connect the NvVarsFileLib to the specified file system.
+
+  @param[in]  FsHandle - Handle for a gEfiSimpleFileSystemProtocolGuid instance
+
+  @return     The EFI_STATUS while attempting to connect the NvVarsFileLib
+              to the file system instance.
+  @retval     EFI_SUCCESS - The given file system was connected successfully
+
+**/
+EFI_STATUS
+EFIAPI
+ConnectNvVarsToFileSystem (
+  IN EFI_HANDLE    FsHandle
+  )
+{
+  EFI_STATUS Status;
+
+  //
+  // We might fail to load the variable, since the file system initially
+  // will not have the NvVars file.
+  //
+  LoadNvVarsFromFs (FsHandle);
+
+  //
+  // We must be able to save the variables successfully to the file system
+  // to have connected successfully.
+  //
+  Status = SaveNvVarsToFs (FsHandle);
+  if (!EFI_ERROR (Status)) {
+    mNvVarsFileLibFsHandle = FsHandle;
+  }
+
+  return Status;
+}
+
+
+/**
+  Update non-volatile variables stored on the file system.
+
+  @return     The EFI_STATUS while attempting to update the variable on
+              the connected file system.
+  @retval     EFI_SUCCESS - The non-volatile variables were saved to the disk
+  @retval     EFI_NOT_STARTED - A file system has not been connected
+
+**/
+EFI_STATUS
+EFIAPI
+UpdateNvVarsOnFileSystem (
+  )
+{
+  if (mNvVarsFileLibFsHandle == NULL) {
+    //
+    // A file system had not been connected to the library.
+    //
+    return EFI_NOT_STARTED;
+  } else {
+    return SaveNvVarsToFs (mNvVarsFileLibFsHandle);
+  }
+}
+
+
diff --git a/TestPkg/Library/NvVarsFileLib/NvVarsFileLib.h b/TestPkg/Library/NvVarsFileLib/NvVarsFileLib.h
new file mode 100644
index 0000000000..c736aeb6e8
--- /dev/null
+++ b/TestPkg/Library/NvVarsFileLib/NvVarsFileLib.h
@@ -0,0 +1,55 @@
+/** @file
+  Save Non-Volatile Variables to a file system.
+
+  Copyright (c) 2009 - 2011, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __NV_VARS_FILE_LIB_INSTANCE__
+#define __NV_VARS_FILE_LIB_INSTANCE__
+
+#include <Uefi.h>
+
+#include <Guid/FileInfo.h>
+
+#include <Protocol/SimpleFileSystem.h>
+
+#include <Library/BaseLib.h>
+#include <Library/FileHandleLib.h>
+#include <Library/SerializeVariablesLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiRuntimeServicesTableLib.h>
+#include <Library/UefiLib.h>
+
+/**
+  Loads the non-volatile variables from the NvVars file on the
+  given file system.
+
+  @param[in]  FsHandle - Handle for a gEfiSimpleFileSystemProtocolGuid instance
+
+  @return     EFI_STATUS based on the success or failure of load operation
+
+**/
+EFI_STATUS
+LoadNvVarsFromFs (
+  EFI_HANDLE                            FsHandle
+  );
+
+
+/**
+  Saves the non-volatile variables into the NvVars file on the
+  given file system.
+
+  @param[in]  FsHandle - Handle for a gEfiSimpleFileSystemProtocolGuid instance
+
+  @return     EFI_STATUS based on the success or failure of load operation
+
+**/
+EFI_STATUS
+SaveNvVarsToFs (
+  EFI_HANDLE                            FsHandle
+  );
+
+#endif
+
diff --git a/TestPkg/Library/NvVarsFileLib/NvVarsFileLib.inf b/TestPkg/Library/NvVarsFileLib/NvVarsFileLib.inf
new file mode 100644
index 0000000000..7df3c8315b
--- /dev/null
+++ b/TestPkg/Library/NvVarsFileLib/NvVarsFileLib.inf
@@ -0,0 +1,56 @@
+## @file
+#  NvVarsFileLib
+#
+#  This library saves and restores non-volatile variables in a
+#  file within a file system.
+#
+#  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = NvVarsFileLib
+  FILE_GUID                      = 9172fe8b-9a36-40f8-bba5-5e57a44390bd
+  MODULE_TYPE                    = UEFI_DRIVER
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = NvVarsFileLib|DXE_DRIVER DXE_RUNTIME_DRIVER UEFI_DRIVER
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 EBC
+#
+
+[Sources]
+  FsAccess.c
+  NvVarsFileLib.c
+  NvVarsFileLib.h
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  OvmfPkg/OvmfPkg.dec
+  ShellPkg/ShellPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  BaseMemoryLib
+  DebugLib
+  FileHandleLib
+  MemoryAllocationLib
+  SerializeVariablesLib
+
+[Protocols]
+  gEfiSimpleFileSystemProtocolGuid              ## CONSUMES
+
+
+[Guids]
+  gEfiFileInfoGuid
+
+[Depex]
+  gEfiVariableWriteArchProtocolGuid
+
diff --git a/TestPkg/Library/PlatformDebugLibIoPort/DebugIoPortNocheck.c b/TestPkg/Library/PlatformDebugLibIoPort/DebugIoPortNocheck.c
new file mode 100644
index 0000000000..1cf68aa3e7
--- /dev/null
+++ b/TestPkg/Library/PlatformDebugLibIoPort/DebugIoPortNocheck.c
@@ -0,0 +1,25 @@
+/** @file
+  Dectection code for hypervisor debug port.
+
+  Copyright (c) 2020, Citrix Systems, Inc.
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include "DebugLibDetect.h"
+
+/**
+  Always return TRUE without detection as the debug I/O port is always
+  present.
+
+  @retval TRUE   The debug I/O port is always present.
+
+**/
+BOOLEAN
+EFIAPI
+PlatformDebugLibIoPortDetect (
+  VOID
+  )
+{
+  return TRUE;
+}
diff --git a/TestPkg/Library/PlatformDebugLibIoPort/DebugIoPortQemu.c b/TestPkg/Library/PlatformDebugLibIoPort/DebugIoPortQemu.c
new file mode 100644
index 0000000000..925ba58804
--- /dev/null
+++ b/TestPkg/Library/PlatformDebugLibIoPort/DebugIoPortQemu.c
@@ -0,0 +1,34 @@
+/** @file
+  Detection code for QEMU debug port.
+
+  Copyright (c) 2006 - 2019, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2012, Red Hat, Inc.<BR>
+  Copyright (c) 2020, Citrix Systems, Inc.
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <Library/IoLib.h>
+#include <Library/PcdLib.h>
+#include "DebugLibDetect.h"
+
+//
+// The constant value that is read from the debug I/O port
+//
+#define BOCHS_DEBUG_PORT_MAGIC    0xE9
+
+/**
+  Return the result of detecting the debug I/O port device.
+
+  @retval TRUE   if the debug I/O port device was detected.
+  @retval FALSE  otherwise
+
+**/
+BOOLEAN
+EFIAPI
+PlatformDebugLibIoPortDetect (
+  VOID
+  )
+{
+  return IoRead8 (PcdGet16 (PcdDebugIoPort)) == BOCHS_DEBUG_PORT_MAGIC;
+}
diff --git a/TestPkg/Library/PlatformDebugLibIoPort/DebugLib.c b/TestPkg/Library/PlatformDebugLibIoPort/DebugLib.c
new file mode 100644
index 0000000000..36df435b2d
--- /dev/null
+++ b/TestPkg/Library/PlatformDebugLibIoPort/DebugLib.c
@@ -0,0 +1,361 @@
+/** @file
+  Base Debug library instance for hypervisor debug port.
+  It uses PrintLib to send debug messages to a fixed I/O port.
+
+  Copyright (c) 2006 - 2019, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2012, Red Hat, Inc.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <Base.h>
+#include <Library/DebugLib.h>
+#include <Library/BaseLib.h>
+#include <Library/IoLib.h>
+#include <Library/PrintLib.h>
+#include <Library/PcdLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/DebugPrintErrorLevelLib.h>
+#include "DebugLibDetect.h"
+
+//
+// Define the maximum debug and assert message length that this library supports
+//
+#define MAX_DEBUG_MESSAGE_LENGTH  0x100
+
+//
+// VA_LIST can not initialize to NULL for all compiler, so we use this to
+// indicate a null VA_LIST
+//
+VA_LIST     mVaListNull;
+
+/**
+  Prints a debug message to the debug output device if the specified error level is enabled.
+
+  If any bit in ErrorLevel is also set in DebugPrintErrorLevelLib function
+  GetDebugPrintErrorLevel (), then print the message specified by Format and the
+  associated variable argument list to the debug output device.
+
+  If Format is NULL, then ASSERT().
+
+  @param  ErrorLevel  The error level of the debug message.
+  @param  Format      Format string for the debug message to print.
+  @param  ...         Variable argument list whose contents are accessed
+                      based on the format string specified by Format.
+
+**/
+VOID
+EFIAPI
+DebugPrint (
+  IN  UINTN        ErrorLevel,
+  IN  CONST CHAR8  *Format,
+  ...
+  )
+{
+  VA_LIST         Marker;
+
+  VA_START (Marker, Format);
+  DebugVPrint (ErrorLevel, Format, Marker);
+  VA_END (Marker);
+}
+
+
+/**
+  Prints a debug message to the debug output device if the specified
+  error level is enabled base on Null-terminated format string and a
+  VA_LIST argument list or a BASE_LIST argument list.
+
+  If any bit in ErrorLevel is also set in DebugPrintErrorLevelLib function
+  GetDebugPrintErrorLevel (), then print the message specified by Format and
+  the associated variable argument list to the debug output device.
+
+  If Format is NULL, then ASSERT().
+
+  @param  ErrorLevel      The error level of the debug message.
+  @param  Format          Format string for the debug message to print.
+  @param  VaListMarker    VA_LIST marker for the variable argument list.
+  @param  BaseListMarker  BASE_LIST marker for the variable argument list.
+
+**/
+VOID
+DebugPrintMarker (
+  IN  UINTN         ErrorLevel,
+  IN  CONST CHAR8   *Format,
+  IN  VA_LIST       VaListMarker,
+  IN  BASE_LIST     BaseListMarker
+  )
+{
+  CHAR8    Buffer[MAX_DEBUG_MESSAGE_LENGTH];
+  UINTN    Length;
+
+  //
+  // If Format is NULL, then ASSERT().
+  //
+  ASSERT (Format != NULL);
+
+  //
+  // Check if the global mask disables this message or the device is inactive
+  //
+  if ((ErrorLevel & GetDebugPrintErrorLevel ()) == 0 ||
+      !PlatformDebugLibIoPortFound ()) {
+    return;
+  }
+
+  //
+  // Convert the DEBUG() message to an ASCII String
+  //
+  if (BaseListMarker == NULL) {
+    Length = AsciiVSPrint (Buffer, sizeof (Buffer), Format, VaListMarker);
+  } else {
+    Length = AsciiBSPrint (Buffer, sizeof (Buffer), Format, BaseListMarker);
+  }
+
+  //
+  // Send the print string to the debug I/O port
+  //
+  IoWriteFifo8 (PcdGet16 (PcdDebugIoPort), Length, Buffer);
+}
+
+
+/**
+  Prints a debug message to the debug output device if the specified
+  error level is enabled.
+
+  If any bit in ErrorLevel is also set in DebugPrintErrorLevelLib function
+  GetDebugPrintErrorLevel (), then print the message specified by Format and
+  the associated variable argument list to the debug output device.
+
+  If Format is NULL, then ASSERT().
+
+  @param  ErrorLevel    The error level of the debug message.
+  @param  Format        Format string for the debug message to print.
+  @param  VaListMarker  VA_LIST marker for the variable argument list.
+
+**/
+VOID
+EFIAPI
+DebugVPrint (
+  IN  UINTN         ErrorLevel,
+  IN  CONST CHAR8   *Format,
+  IN  VA_LIST       VaListMarker
+  )
+{
+  DebugPrintMarker (ErrorLevel, Format, VaListMarker, NULL);
+}
+
+
+/**
+  Prints a debug message to the debug output device if the specified
+  error level is enabled.
+  This function use BASE_LIST which would provide a more compatible
+  service than VA_LIST.
+
+  If any bit in ErrorLevel is also set in DebugPrintErrorLevelLib function
+  GetDebugPrintErrorLevel (), then print the message specified by Format and
+  the associated variable argument list to the debug output device.
+
+  If Format is NULL, then ASSERT().
+
+  @param  ErrorLevel      The error level of the debug message.
+  @param  Format          Format string for the debug message to print.
+  @param  BaseListMarker  BASE_LIST marker for the variable argument list.
+
+**/
+VOID
+EFIAPI
+DebugBPrint (
+  IN  UINTN         ErrorLevel,
+  IN  CONST CHAR8   *Format,
+  IN  BASE_LIST     BaseListMarker
+  )
+{
+  DebugPrintMarker (ErrorLevel, Format, mVaListNull, BaseListMarker);
+}
+
+
+/**
+  Prints an assert message containing a filename, line number, and description.
+  This may be followed by a breakpoint or a dead loop.
+
+  Print a message of the form "ASSERT <FileName>(<LineNumber>): <Description>\n"
+  to the debug output device.  If DEBUG_PROPERTY_ASSERT_BREAKPOINT_ENABLED bit of
+  PcdDebugProperyMask is set then CpuBreakpoint() is called. Otherwise, if
+  DEBUG_PROPERTY_ASSERT_DEADLOOP_ENABLED bit of PcdDebugProperyMask is set then
+  CpuDeadLoop() is called.  If neither of these bits are set, then this function
+  returns immediately after the message is printed to the debug output device.
+  DebugAssert() must actively prevent recursion.  If DebugAssert() is called while
+  processing another DebugAssert(), then DebugAssert() must return immediately.
+
+  If FileName is NULL, then a <FileName> string of "(NULL) Filename" is printed.
+  If Description is NULL, then a <Description> string of "(NULL) Description" is printed.
+
+  @param  FileName     The pointer to the name of the source file that generated the assert condition.
+  @param  LineNumber   The line number in the source file that generated the assert condition
+  @param  Description  The pointer to the description of the assert condition.
+
+**/
+VOID
+EFIAPI
+DebugAssert (
+  IN CONST CHAR8  *FileName,
+  IN UINTN        LineNumber,
+  IN CONST CHAR8  *Description
+  )
+{
+  CHAR8  Buffer[MAX_DEBUG_MESSAGE_LENGTH];
+  UINTN  Length;
+
+  //
+  // Generate the ASSERT() message in Ascii format
+  //
+  Length = AsciiSPrint (Buffer, sizeof Buffer, "ASSERT %a(%Lu): %a\n",
+             FileName, (UINT64)LineNumber, Description);
+
+  //
+  // Send the print string to the debug I/O port, if present
+  //
+  if (PlatformDebugLibIoPortFound ()) {
+    IoWriteFifo8 (PcdGet16 (PcdDebugIoPort), Length, Buffer);
+  }
+
+  //
+  // Generate a Breakpoint, DeadLoop, or NOP based on PCD settings
+  //
+  if ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_ASSERT_BREAKPOINT_ENABLED) != 0) {
+    CpuBreakpoint ();
+  } else if ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_ASSERT_DEADLOOP_ENABLED) != 0) {
+    CpuDeadLoop ();
+  }
+}
+
+
+/**
+  Fills a target buffer with PcdDebugClearMemoryValue, and returns the target buffer.
+
+  This function fills Length bytes of Buffer with the value specified by
+  PcdDebugClearMemoryValue, and returns Buffer.
+
+  If Buffer is NULL, then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  @param   Buffer  The pointer to the target buffer to be filled with PcdDebugClearMemoryValue.
+  @param   Length  The number of bytes in Buffer to fill with zeros PcdDebugClearMemoryValue.
+
+  @return  Buffer  The pointer to the target buffer filled with PcdDebugClearMemoryValue.
+
+**/
+VOID *
+EFIAPI
+DebugClearMemory (
+  OUT VOID  *Buffer,
+  IN UINTN  Length
+  )
+{
+  //
+  // If Buffer is NULL, then ASSERT().
+  //
+  ASSERT (Buffer != NULL);
+
+  //
+  // SetMem() checks for the the ASSERT() condition on Length and returns Buffer
+  //
+  return SetMem (Buffer, Length, PcdGet8(PcdDebugClearMemoryValue));
+}
+
+
+/**
+  Returns TRUE if ASSERT() macros are enabled.
+
+  This function returns TRUE if the DEBUG_PROPERTY_DEBUG_ASSERT_ENABLED bit of
+  PcdDebugProperyMask is set.  Otherwise FALSE is returned.
+
+  @retval  TRUE    The DEBUG_PROPERTY_DEBUG_ASSERT_ENABLED bit of PcdDebugProperyMask is set.
+  @retval  FALSE   The DEBUG_PROPERTY_DEBUG_ASSERT_ENABLED bit of PcdDebugProperyMask is clear.
+
+**/
+BOOLEAN
+EFIAPI
+DebugAssertEnabled (
+  VOID
+  )
+{
+  return (BOOLEAN) ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_DEBUG_ASSERT_ENABLED) != 0);
+}
+
+
+/**
+  Returns TRUE if DEBUG() macros are enabled.
+
+  This function returns TRUE if the DEBUG_PROPERTY_DEBUG_PRINT_ENABLED bit of
+  PcdDebugProperyMask is set.  Otherwise FALSE is returned.
+
+  @retval  TRUE    The DEBUG_PROPERTY_DEBUG_PRINT_ENABLED bit of PcdDebugProperyMask is set.
+  @retval  FALSE   The DEBUG_PROPERTY_DEBUG_PRINT_ENABLED bit of PcdDebugProperyMask is clear.
+
+**/
+BOOLEAN
+EFIAPI
+DebugPrintEnabled (
+  VOID
+  )
+{
+  return (BOOLEAN) ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_DEBUG_PRINT_ENABLED) != 0);
+}
+
+
+/**
+  Returns TRUE if DEBUG_CODE() macros are enabled.
+
+  This function returns TRUE if the DEBUG_PROPERTY_DEBUG_CODE_ENABLED bit of
+  PcdDebugProperyMask is set.  Otherwise FALSE is returned.
+
+  @retval  TRUE    The DEBUG_PROPERTY_DEBUG_CODE_ENABLED bit of PcdDebugProperyMask is set.
+  @retval  FALSE   The DEBUG_PROPERTY_DEBUG_CODE_ENABLED bit of PcdDebugProperyMask is clear.
+
+**/
+BOOLEAN
+EFIAPI
+DebugCodeEnabled (
+  VOID
+  )
+{
+  return (BOOLEAN) ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_DEBUG_CODE_ENABLED) != 0);
+}
+
+
+/**
+  Returns TRUE if DEBUG_CLEAR_MEMORY() macro is enabled.
+
+  This function returns TRUE if the DEBUG_PROPERTY_CLEAR_MEMORY_ENABLED bit of
+  PcdDebugProperyMask is set.  Otherwise FALSE is returned.
+
+  @retval  TRUE    The DEBUG_PROPERTY_CLEAR_MEMORY_ENABLED bit of PcdDebugProperyMask is set.
+  @retval  FALSE   The DEBUG_PROPERTY_CLEAR_MEMORY_ENABLED bit of PcdDebugProperyMask is clear.
+
+**/
+BOOLEAN
+EFIAPI
+DebugClearMemoryEnabled (
+  VOID
+  )
+{
+  return (BOOLEAN) ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_CLEAR_MEMORY_ENABLED) != 0);
+}
+
+/**
+  Returns TRUE if any one of the bit is set both in ErrorLevel and PcdFixedDebugPrintErrorLevel.
+
+  This function compares the bit mask of ErrorLevel and PcdFixedDebugPrintErrorLevel.
+
+  @retval  TRUE    Current ErrorLevel is supported.
+  @retval  FALSE   Current ErrorLevel is not supported.
+
+**/
+BOOLEAN
+EFIAPI
+DebugPrintLevelEnabled (
+  IN  CONST UINTN        ErrorLevel
+  )
+{
+  return (BOOLEAN) ((ErrorLevel & PcdGet32(PcdFixedDebugPrintErrorLevel)) != 0);
+}
diff --git a/TestPkg/Library/PlatformDebugLibIoPort/DebugLibDetect.c b/TestPkg/Library/PlatformDebugLibIoPort/DebugLibDetect.c
new file mode 100644
index 0000000000..ab94178fab
--- /dev/null
+++ b/TestPkg/Library/PlatformDebugLibIoPort/DebugLibDetect.c
@@ -0,0 +1,65 @@
+/** @file
+  Detection code for hypervisor debug port.
+  Non-SEC instance, caches the result of detection.
+
+  Copyright (c) 2017, Red Hat, Inc.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <Base.h>
+#include "DebugLibDetect.h"
+
+//
+// Set to TRUE if the debug I/O port has been checked
+//
+STATIC BOOLEAN mDebugIoPortChecked = FALSE;
+
+//
+// Set to TRUE if the debug I/O port is enabled
+//
+STATIC BOOLEAN mDebugIoPortFound = FALSE;
+
+/**
+  This constructor function must not do anything.
+
+  Some modules consuming this library instance, such as the DXE Core, invoke
+  the DEBUG() macro before they explicitly call
+  ProcessLibraryConstructorList(). Therefore the auto-generated call from
+  ProcessLibraryConstructorList() to this constructor function may be preceded
+  by some calls to PlatformDebugLibIoPortFound() below. Hence
+  PlatformDebugLibIoPortFound() must not rely on anything this constructor
+  could set up.
+
+  @retval RETURN_SUCCESS   The constructor always returns RETURN_SUCCESS.
+
+**/
+RETURN_STATUS
+EFIAPI
+PlatformDebugLibIoPortConstructor (
+  VOID
+  )
+{
+  return RETURN_SUCCESS;
+}
+
+/**
+  At the first call, check if the debug I/O port device is present, and cache
+  the result for later use. At subsequent calls, return the cached result.
+
+  @retval TRUE   if the debug I/O port device was detected.
+  @retval FALSE  otherwise
+
+**/
+BOOLEAN
+EFIAPI
+PlatformDebugLibIoPortFound (
+  VOID
+  )
+{
+  if (!mDebugIoPortChecked) {
+    mDebugIoPortFound = PlatformDebugLibIoPortDetect ();
+    mDebugIoPortChecked = TRUE;
+  }
+  return mDebugIoPortFound;
+}
diff --git a/TestPkg/Library/PlatformDebugLibIoPort/DebugLibDetect.h b/TestPkg/Library/PlatformDebugLibIoPort/DebugLibDetect.h
new file mode 100644
index 0000000000..29e6ed4851
--- /dev/null
+++ b/TestPkg/Library/PlatformDebugLibIoPort/DebugLibDetect.h
@@ -0,0 +1,45 @@
+/** @file
+  Base Debug library instance for hypervisor debug port.
+  It uses PrintLib to send debug messages to a fixed I/O port.
+
+  Copyright (c) 2017, Red Hat, Inc.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __DEBUG_IO_PORT_DETECT_H__
+#define __DEBUG_IO_PORT_DETECT_H__
+
+#include <Base.h>
+
+/**
+  Helper function to return whether the virtual machine has a debug I/O port.
+  PlatformDebugLibIoPortFound can call this function directly or cache the
+  result.
+
+  @retval TRUE   if the debug I/O port device was detected.
+  @retval FALSE  otherwise
+
+**/
+BOOLEAN
+EFIAPI
+PlatformDebugLibIoPortDetect (
+  VOID
+  );
+
+/**
+  Return whether the virtual machine has a debug I/O port.  DebugLib.c
+  calls this function instead of PlatformDebugLibIoPortDetect, to allow
+  caching if possible.
+
+  @retval TRUE   if the debug I/O port device was detected.
+  @retval FALSE  otherwise
+
+**/
+BOOLEAN
+EFIAPI
+PlatformDebugLibIoPortFound (
+  VOID
+  );
+
+#endif
diff --git a/TestPkg/Library/PlatformDebugLibIoPort/DebugLibDetectRom.c b/TestPkg/Library/PlatformDebugLibIoPort/DebugLibDetectRom.c
new file mode 100644
index 0000000000..e7d0817717
--- /dev/null
+++ b/TestPkg/Library/PlatformDebugLibIoPort/DebugLibDetectRom.c
@@ -0,0 +1,42 @@
+/** @file
+  Detection code for hypervisor debug port.
+  SEC instance, cannot cache the result of detection.
+
+  Copyright (c) 2017, Red Hat, Inc.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <Base.h>
+#include "DebugLibDetect.h"
+
+/**
+  This constructor function does not have anything to do.
+
+  @retval RETURN_SUCCESS   The constructor always returns RETURN_SUCCESS.
+
+**/
+RETURN_STATUS
+EFIAPI
+PlatformRomDebugLibIoPortConstructor (
+  VOID
+  )
+{
+  return RETURN_SUCCESS;
+}
+
+/**
+  Return the result of detecting the debug I/O port device.
+
+  @retval TRUE   if the debug I/O port device was detected.
+  @retval FALSE  otherwise
+
+**/
+BOOLEAN
+EFIAPI
+PlatformDebugLibIoPortFound (
+  VOID
+  )
+{
+  return PlatformDebugLibIoPortDetect ();
+}
diff --git a/TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf b/TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
new file mode 100644
index 0000000000..bb695ba6d5
--- /dev/null
+++ b/TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
@@ -0,0 +1,49 @@
+## @file
+#  Instance of Debug Library for the QEMU debug console port.
+#  It uses Print Library to produce formatted output strings.
+#
+#  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+#  Copyright (c) 2012, Red Hat, Inc.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformDebugLibIoPort
+  FILE_GUID                      = DF934DA3-CD31-49FE-AF50-B3C87C79325F
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = DebugLib|PEI_CORE PEIM DXE_CORE DXE_DRIVER DXE_RUNTIME_DRIVER SMM_CORE DXE_SMM_DRIVER UEFI_DRIVER UEFI_APPLICATION
+  CONSTRUCTOR                    = PlatformDebugLibIoPortConstructor
+
+#
+#  VALID_ARCHITECTURES           = IA32 X64 EBC
+#
+
+[Sources]
+  DebugIoPortQemu.c
+  DebugLib.c
+  DebugLibDetect.c
+  DebugLibDetect.h
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  BaseMemoryLib
+  IoLib
+  PcdLib
+  PrintLib
+  BaseLib
+  DebugPrintErrorLevelLib
+
+[Pcd]
+  gUefiOvmfPkgTokenSpaceGuid.PcdDebugIoPort                ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdDebugClearMemoryValue        ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask            ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdFixedDebugPrintErrorLevel    ## CONSUMES
+
diff --git a/TestPkg/Library/PlatformDebugLibIoPort/PlatformRomDebugLibIoPort.inf b/TestPkg/Library/PlatformDebugLibIoPort/PlatformRomDebugLibIoPort.inf
new file mode 100644
index 0000000000..ad7f9af9ca
--- /dev/null
+++ b/TestPkg/Library/PlatformDebugLibIoPort/PlatformRomDebugLibIoPort.inf
@@ -0,0 +1,49 @@
+## @file
+#  Instance of Debug Library for the QEMU debug console port.
+#  It uses Print Library to produce formatted output strings.
+#
+#  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+#  Copyright (c) 2017, Red Hat, Inc.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformRomDebugLibIoPort
+  FILE_GUID                      = CEB0D9D3-328F-4C24-8C02-28FA1986AE1B
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = DebugLib|SEC
+  CONSTRUCTOR                    = PlatformRomDebugLibIoPortConstructor
+
+#
+#  VALID_ARCHITECTURES           = IA32 X64 EBC
+#
+
+[Sources]
+  DebugIoPortQemu.c
+  DebugLib.c
+  DebugLibDetect.h
+  DebugLibDetectRom.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  BaseMemoryLib
+  IoLib
+  PcdLib
+  PrintLib
+  BaseLib
+  DebugPrintErrorLevelLib
+
+[Pcd]
+  gUefiOvmfPkgTokenSpaceGuid.PcdDebugIoPort                ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdDebugClearMemoryValue        ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask            ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdFixedDebugPrintErrorLevel    ## CONSUMES
+
diff --git a/TestPkg/Library/PlatformDebugLibIoPort/PlatformRomDebugLibIoPortNocheck.inf b/TestPkg/Library/PlatformDebugLibIoPort/PlatformRomDebugLibIoPortNocheck.inf
new file mode 100644
index 0000000000..17ec4122a2
--- /dev/null
+++ b/TestPkg/Library/PlatformDebugLibIoPort/PlatformRomDebugLibIoPortNocheck.inf
@@ -0,0 +1,48 @@
+## @file
+#  Instance of Debug Library for an hypervisor debug console port.
+#  It uses Print Library to produce formatted output strings.
+#
+#  Copyright (c) 2020, Citrix Systems, Inc.
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformRomDebugLibIoPortNocheck
+  FILE_GUID                      = 92AEB68E-C2CF-466E-9AB2-3F5E713F7DE6
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = DebugLib
+  CONSTRUCTOR                    = PlatformRomDebugLibIoPortConstructor
+
+#
+#  VALID_ARCHITECTURES           = IA32 X64 EBC
+#
+
+[Sources]
+  DebugIoPortNocheck.c
+  DebugLib.c
+  DebugLibDetect.h
+  DebugLibDetectRom.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  BaseMemoryLib
+  IoLib
+  PcdLib
+  PrintLib
+  BaseLib
+  DebugPrintErrorLevelLib
+
+[Pcd]
+  gUefiOvmfPkgTokenSpaceGuid.PcdDebugIoPort                ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdDebugClearMemoryValue        ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask            ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdFixedDebugPrintErrorLevel    ## CONSUMES
+
diff --git a/TestPkg/Library/ResetSystemLib/BaseResetShutdown.c b/TestPkg/Library/ResetSystemLib/BaseResetShutdown.c
new file mode 100644
index 0000000000..ea7703bb60
--- /dev/null
+++ b/TestPkg/Library/ResetSystemLib/BaseResetShutdown.c
@@ -0,0 +1,51 @@
+/** @file
+  Base Reset System Library Shutdown API implementation for OVMF.
+
+  Copyright (C) 2020, Red Hat, Inc.
+  Copyright (c) 2006 - 2019, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#include <Base.h>                   // BIT13
+
+#include <Library/BaseLib.h>        // CpuDeadLoop()
+#include <Library/DebugLib.h>       // ASSERT()
+#include <Library/IoLib.h>          // IoOr16()
+#include <Library/PciLib.h>         // PciRead16()
+#include <Library/ResetSystemLib.h> // ResetShutdown()
+#include <OvmfPlatforms.h>          // OVMF_HOSTBRIDGE_DID
+
+/**
+  Calling this function causes the system to enter a power state equivalent
+  to the ACPI G2/S5 or G3 states.
+
+  System shutdown should not return, if it returns, it means the system does
+  not support shut down reset.
+**/
+VOID
+EFIAPI
+ResetShutdown (
+  VOID
+  )
+{
+  UINT16 AcpiPmBaseAddress;
+  UINT16 HostBridgeDevId;
+
+  AcpiPmBaseAddress = 0;
+  HostBridgeDevId = PciRead16 (OVMF_HOSTBRIDGE_DID);
+  switch (HostBridgeDevId) {
+  case INTEL_82441_DEVICE_ID:
+    AcpiPmBaseAddress = PIIX4_PMBA_VALUE;
+    break;
+  case INTEL_Q35_MCH_DEVICE_ID:
+    AcpiPmBaseAddress = ICH9_PMBASE_VALUE;
+    break;
+  default:
+    ASSERT (FALSE);
+    CpuDeadLoop ();
+  }
+
+  IoBitFieldWrite16 (AcpiPmBaseAddress + 4, 10, 13, 0);
+  IoOr16 (AcpiPmBaseAddress + 4, BIT13);
+  CpuDeadLoop ();
+}
diff --git a/TestPkg/Library/ResetSystemLib/BaseResetShutdownBhyve.c b/TestPkg/Library/ResetSystemLib/BaseResetShutdownBhyve.c
new file mode 100644
index 0000000000..d1ce13f1a6
--- /dev/null
+++ b/TestPkg/Library/ResetSystemLib/BaseResetShutdownBhyve.c
@@ -0,0 +1,34 @@
+/** @file
+  Base Reset System Library Shutdown API implementation for bhyve.
+
+  Copyright (C) 2020, Rebecca Cran <rebecca@bsdio.com>
+  Copyright (C) 2020, Red Hat, Inc.
+  Copyright (c) 2006 - 2019, Intel Corporation. All rights reserved.<BR>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#include <Base.h>                   // BIT13
+
+#include <IndustryStandard/Bhyve.h> // BHYVE_PM_REG
+#include <Library/BaseLib.h>        // CpuDeadLoop()
+#include <Library/IoLib.h>          // IoOr16()
+#include <Library/ResetSystemLib.h> // ResetShutdown()
+
+/**
+  Calling this function causes the system to enter a power state equivalent
+  to the ACPI G2/S5 or G3 states.
+
+  System shutdown should not return, if it returns, it means the system does
+  not support shut down reset.
+**/
+VOID
+EFIAPI
+ResetShutdown (
+  VOID
+  )
+{
+  IoBitFieldWrite16 (BHYVE_PM_REG, 10, 13, 5);
+  IoOr16 (BHYVE_PM_REG, BIT13);
+  CpuDeadLoop ();
+}
diff --git a/TestPkg/Library/ResetSystemLib/BaseResetSystemLib.inf b/TestPkg/Library/ResetSystemLib/BaseResetSystemLib.inf
new file mode 100644
index 0000000000..93cf16a232
--- /dev/null
+++ b/TestPkg/Library/ResetSystemLib/BaseResetSystemLib.inf
@@ -0,0 +1,38 @@
+## @file
+#  Base library instance for ResetSystem library class for OVMF
+#
+#  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = BaseResetSystemLib
+  FILE_GUID                      = 66564872-21d4-4d2a-a68b-1e844f980820
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = ResetSystemLib|SEC PEI_CORE PEIM DXE_CORE
+
+#
+# The following information is for reference only and not required by the build
+# tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64
+#
+
+[Sources]
+  BaseResetShutdown.c
+  ResetSystemLib.c
+
+[Packages]
+  MdeModulePkg/MdeModulePkg.dec
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  DebugLib
+  IoLib
+  PciLib
+  TimerLib
diff --git a/TestPkg/Library/ResetSystemLib/BaseResetSystemLibBhyve.inf b/TestPkg/Library/ResetSystemLib/BaseResetSystemLibBhyve.inf
new file mode 100644
index 0000000000..bdde9a5ff1
--- /dev/null
+++ b/TestPkg/Library/ResetSystemLib/BaseResetSystemLibBhyve.inf
@@ -0,0 +1,40 @@
+## @file
+#  Base library instance for ResetSystem library class for bhyve
+#
+#  Copyright (C) 2020, Rebecca Cran <rebecca@bsdio.com>
+#  Copyright (C) 2020, Red Hat, Inc.
+#  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+[Defines]
+  INF_VERSION                    = 1.29
+  BASE_NAME                      = BaseResetSystemLibBhyve
+  FILE_GUID                      = 5c71b08f-0ade-4607-8b9d-946c2757fee8
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = ResetSystemLib
+
+#
+# The following information is for reference only and not required by the build
+# tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64
+#
+
+[Sources]
+  BaseResetShutdownBhyve.c
+  ResetSystemLib.c
+
+[Packages]
+  MdeModulePkg/MdeModulePkg.dec
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  IoLib
+  TimerLib
+
diff --git a/TestPkg/Library/ResetSystemLib/DxeResetShutdown.c b/TestPkg/Library/ResetSystemLib/DxeResetShutdown.c
new file mode 100644
index 0000000000..a6e9ed73c4
--- /dev/null
+++ b/TestPkg/Library/ResetSystemLib/DxeResetShutdown.c
@@ -0,0 +1,62 @@
+/** @file
+  DXE Reset System Library Shutdown API implementation for OVMF.
+
+  Copyright (C) 2020, Red Hat, Inc.
+  Copyright (c) 2006 - 2019, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#include <Base.h>                   // BIT13
+
+#include <Library/BaseLib.h>        // CpuDeadLoop()
+#include <Library/DebugLib.h>       // ASSERT()
+#include <Library/IoLib.h>          // IoOr16()
+#include <Library/PcdLib.h>         // PcdGet16()
+#include <Library/ResetSystemLib.h> // ResetShutdown()
+#include <OvmfPlatforms.h>          // PIIX4_PMBA_VALUE
+
+STATIC UINT16 mAcpiPmBaseAddress;
+
+EFI_STATUS
+EFIAPI
+DxeResetInit (
+  IN EFI_HANDLE       ImageHandle,
+  IN EFI_SYSTEM_TABLE *SystemTable
+  )
+{
+  UINT16 HostBridgeDevId;
+
+  HostBridgeDevId = PcdGet16 (PcdOvmfHostBridgePciDevId);
+  switch (HostBridgeDevId) {
+  case INTEL_82441_DEVICE_ID:
+    mAcpiPmBaseAddress = PIIX4_PMBA_VALUE;
+    break;
+  case INTEL_Q35_MCH_DEVICE_ID:
+    mAcpiPmBaseAddress = ICH9_PMBASE_VALUE;
+    break;
+  default:
+    ASSERT (FALSE);
+    CpuDeadLoop ();
+    return EFI_UNSUPPORTED;
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Calling this function causes the system to enter a power state equivalent
+  to the ACPI G2/S5 or G3 states.
+
+  System shutdown should not return, if it returns, it means the system does
+  not support shut down reset.
+**/
+VOID
+EFIAPI
+ResetShutdown (
+  VOID
+  )
+{
+  IoBitFieldWrite16 (mAcpiPmBaseAddress + 4, 10, 13, 0);
+  IoOr16 (mAcpiPmBaseAddress + 4, BIT13);
+  CpuDeadLoop ();
+}
diff --git a/TestPkg/Library/ResetSystemLib/DxeResetSystemLib.inf b/TestPkg/Library/ResetSystemLib/DxeResetSystemLib.inf
new file mode 100644
index 0000000000..125baf7700
--- /dev/null
+++ b/TestPkg/Library/ResetSystemLib/DxeResetSystemLib.inf
@@ -0,0 +1,43 @@
+## @file
+#  DXE library instance for ResetSystem library class for OVMF
+#
+#  Copyright (C) 2020, Red Hat, Inc.
+#  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+[Defines]
+  INF_VERSION                    = 1.29
+  BASE_NAME                      = DxeResetSystemLib
+  FILE_GUID                      = bc7835ea-4094-41fe-b770-bad9e6c479b2
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = ResetSystemLib|DXE_DRIVER DXE_RUNTIME_DRIVER SMM_CORE DXE_SMM_DRIVER UEFI_DRIVER UEFI_APPLICATION
+  CONSTRUCTOR                    = DxeResetInit
+
+#
+# The following information is for reference only and not required by the build
+# tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64
+#
+
+[Sources]
+  DxeResetShutdown.c
+  ResetSystemLib.c
+
+[Packages]
+  MdeModulePkg/MdeModulePkg.dec
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  DebugLib
+  IoLib
+  PcdLib
+  TimerLib
+
+[Pcd]
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfHostBridgePciDevId ## CONSUMES
diff --git a/TestPkg/Library/ResetSystemLib/ResetSystemLib.c b/TestPkg/Library/ResetSystemLib/ResetSystemLib.c
new file mode 100644
index 0000000000..54a07de273
--- /dev/null
+++ b/TestPkg/Library/ResetSystemLib/ResetSystemLib.c
@@ -0,0 +1,120 @@
+/** @file
+  Reset System Library functions for OVMF
+
+  Copyright (c) 2006 - 2019, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <Base.h>                   // BIT1
+
+#include <Library/BaseLib.h>        // CpuDeadLoop()
+#include <Library/IoLib.h>          // IoWrite8()
+#include <Library/ResetSystemLib.h> // ResetCold()
+#include <Library/TimerLib.h>       // MicroSecondDelay()
+
+/**
+  Calling this function causes a system-wide reset. This sets
+  all circuitry within the system to its initial state. This type of reset
+  is asynchronous to system operation and operates without regard to
+  cycle boundaries.
+
+  System reset should not return, if it returns, it means the system does
+  not support cold reset.
+**/
+VOID
+EFIAPI
+ResetCold (
+  VOID
+  )
+{
+  IoWrite8 (0xCF9, BIT2 | BIT1); // 1st choice: PIIX3 RCR, RCPU|SRST
+  MicroSecondDelay (50);
+
+  IoWrite8 (0x64, 0xfe);         // 2nd choice: keyboard controller
+  CpuDeadLoop ();
+}
+
+/**
+  Calling this function causes a system-wide initialization. The processors
+  are set to their initial state, and pending cycles are not corrupted.
+
+  System reset should not return, if it returns, it means the system does
+  not support warm reset.
+**/
+VOID
+EFIAPI
+ResetWarm (
+  VOID
+  )
+{
+  IoWrite8 (0x64, 0xfe);
+  CpuDeadLoop ();
+}
+
+
+/**
+  This function causes a systemwide reset. The exact type of the reset is
+  defined by the EFI_GUID that follows the Null-terminated Unicode string
+  passed into ResetData. If the platform does not recognize the EFI_GUID in
+  ResetData the platform must pick a supported reset type to perform.The
+  platform may optionally log the parameters from any non-normal reset that
+  occurs.
+
+  @param[in]  DataSize   The size, in bytes, of ResetData.
+  @param[in]  ResetData  The data buffer starts with a Null-terminated string,
+                         followed by the EFI_GUID.
+**/
+VOID
+EFIAPI
+ResetPlatformSpecific (
+  IN UINTN   DataSize,
+  IN VOID    *ResetData
+  )
+{
+  ResetCold ();
+}
+
+/**
+  The ResetSystem function resets the entire platform.
+
+  @param[in] ResetType      The type of reset to perform.
+  @param[in] ResetStatus    The status code for the reset.
+  @param[in] DataSize       The size, in bytes, of ResetData.
+  @param[in] ResetData      For a ResetType of EfiResetCold, EfiResetWarm, or
+                            EfiResetShutdown the data buffer starts with a
+                            Null-terminated string, optionally followed by
+                            additional binary data. The string is a description
+                            that the caller may use to further indicate the
+                            reason for the system reset.
+**/
+VOID
+EFIAPI
+ResetSystem (
+  IN EFI_RESET_TYPE               ResetType,
+  IN EFI_STATUS                   ResetStatus,
+  IN UINTN                        DataSize,
+  IN VOID                         *ResetData OPTIONAL
+  )
+{
+  switch (ResetType) {
+  case EfiResetWarm:
+    ResetWarm ();
+    break;
+
+  case EfiResetCold:
+    ResetCold ();
+    break;
+
+  case EfiResetShutdown:
+    ResetShutdown ();
+    break;
+
+  case EfiResetPlatformSpecific:
+    ResetPlatformSpecific (DataSize, ResetData);
+    break;
+
+  default:
+    break;
+  }
+}
diff --git a/TestPkg/LibraryClass.dsc b/TestPkg/LibraryClass.dsc
new file mode 100644
index 0000000000..6f09564e2a
--- /dev/null
+++ b/TestPkg/LibraryClass.dsc
@@ -0,0 +1,204 @@
+################################################################################
+#
+# Library Class section - list of all Library Classes needed by this Platform.
+#
+################################################################################
+[LibraryClasses]
+  VmgExitLib|UefiCpuPkg/Library/VmgExitLibNull/VmgExitLibNull.inf
+NvVarsFileLib|TestPkg/Library/NvVarsFileLib/NvVarsFileLib.inf
+  BaseLib|MdePkg/Library/BaseLib/BaseLib.inf
+  PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
+  BaseMemoryLib|MdePkg/Library/BaseMemoryLibRepStr/BaseMemoryLibRepStr.inf
+  DebugPrintErrorLevelLib|MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.inf
+  IoLib|MdePkg/Library/BaseIoLibIntrinsic/BaseIoLibIntrinsicSev.inf
+  PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf
+  UefiBootServicesTableLib|MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf
+  PciCf8Lib|MdePkg/Library/BasePciCf8Lib/BasePciCf8Lib.inf
+  PciLib|MdePkg/Library/BasePciLibCf8/BasePciLibCf8.inf
+  UefiRuntimeServicesTableLib|MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf
+  TimerLib|TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLib.inf
+  PeCoffExtraActionLib|MdePkg/Library/BasePeCoffExtraActionLibNull/BasePeCoffExtraActionLibNull.inf
+  UefiLib|MdePkg/Library/UefiLib/UefiLib.inf
+  LocalApicLib|UefiCpuPkg/Library/BaseXApicX2ApicLib/BaseXApicX2ApicLib.inf
+  SynchronizationLib|MdePkg/Library/BaseSynchronizationLib/BaseSynchronizationLib.inf
+  SerialPortLib|PcAtChipsetPkg/Library/SerialIoLib/SerialIoLib.inf
+  PeCoffGetEntryPointLib|MdePkg/Library/BasePeCoffGetEntryPointLib/BasePeCoffGetEntryPointLib.inf
+  CacheMaintenanceLib|MdePkg/Library/BaseCacheMaintenanceLib/BaseCacheMaintenanceLib.inf
+  UefiDecompressLib|MdePkg/Library/BaseUefiDecompressLib/BaseUefiDecompressLib.inf
+  PerformanceLib|MdePkg/Library/BasePerformanceLibNull/BasePerformanceLibNull.inf
+  PeCoffLib|MdePkg/Library/BasePeCoffLib/BasePeCoffLib.inf
+  DxeServicesLib|MdePkg/Library/DxeServicesLib/DxeServicesLib.inf
+  DebugAgentLib|MdeModulePkg/Library/DebugAgentLibNull/DebugAgentLibNull.inf
+  UefiCpuLib|UefiCpuPkg/Library/BaseUefiCpuLib/BaseUefiCpuLib.inf
+    UefiDriverEntryPoint|MdePkg/Library/UefiDriverEntryPoint/UefiDriverEntryPoint.inf
+  DevicePathLib|MdePkg/Library/UefiDevicePathLibDevicePathProtocol/UefiDevicePathLibDevicePathProtocol.inf
+  PciExpressLib|MdePkg/Library/BasePciExpressLib/BasePciExpressLib.inf
+  SecurityManagementLib|MdeModulePkg/Library/DxeSecurityManagementLib/DxeSecurityManagementLib.inf
+  HiiLib|MdeModulePkg/Library/UefiHiiLib/UefiHiiLib.inf
+  UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf
+  UefiHiiServicesLib|MdeModulePkg/Library/UefiHiiServicesLib/UefiHiiServicesLib.inf
+  UefiBootManagerLib|MdeModulePkg/Library/UefiBootManagerLib/UefiBootManagerLib.inf
+  FileExplorerLib|MdeModulePkg/Library/FileExplorerLib/FileExplorerLib.inf
+  DxeServicesTableLib|MdePkg/Library/DxeServicesTableLib/DxeServicesTableLib.inf
+  SortLib|MdeModulePkg/Library/UefiSortLib/UefiSortLib.inf
+  CpuLib|MdePkg/Library/BaseCpuLib/BaseCpuLib.inf
+  MtrrLib|UefiCpuPkg/Library/MtrrLib/MtrrLib.inf
+  FakeLibraryLib|TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.inf
+  LockBoxLib|MdeModulePkg\Library\LockBoxNullLib\LockBoxNullLib.inf
+
+[LibraryClasses.common.SEC]
+  TimerLib|TestPkg/Library/AcpiTimerLib/BaseRomAcpiTimerLib.inf
+  PpiListLib|EmulatorPkg/Library/SecPpiListLib/SecPpiListLib.inf
+  
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformRomDebugLibIoPort.inf
+!endif
+  ReportStatusCodeLib|MdeModulePkg/Library/PeiReportStatusCodeLib/PeiReportStatusCodeLib.inf
+  ExtractGuidedSectionLib|MdePkg/Library/BaseExtractGuidedSectionLib/BaseExtractGuidedSectionLib.inf
+!if $(SOURCE_DEBUG_ENABLE) == TRUE
+  DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/SecPeiDebugAgentLib.inf
+!endif
+  HobLib|MdePkg/Library/PeiHobLib/PeiHobLib.inf
+  PeiServicesLib|MdePkg/Library/PeiServicesLib/PeiServicesLib.inf
+  PeiServicesTablePointerLib|MdePkg/Library/PeiServicesTablePointerLibIdt/PeiServicesTablePointerLibIdt.inf
+  MemoryAllocationLib|MdePkg/Library/PeiMemoryAllocationLib/PeiMemoryAllocationLib.inf
+!if $(TOOL_CHAIN_TAG) == "XCODE5"
+  CpuExceptionHandlerLib|UefiCpuPkg/Library/CpuExceptionHandlerLib/Xcode5SecPeiCpuExceptionHandlerLib.inf
+!else
+  CpuExceptionHandlerLib|UefiCpuPkg/Library/CpuExceptionHandlerLib/SecPeiCpuExceptionHandlerLib.inf
+!endif
+
+[LibraryClasses.common.PEI_CORE]
+  HobLib|MdePkg/Library/PeiHobLib/PeiHobLib.inf
+  PeiServicesTablePointerLib|MdePkg/Library/PeiServicesTablePointerLibIdt/PeiServicesTablePointerLibIdt.inf
+  PeiServicesLib|MdePkg/Library/PeiServicesLib/PeiServicesLib.inf
+  MemoryAllocationLib|MdePkg/Library/PeiMemoryAllocationLib/PeiMemoryAllocationLib.inf
+  PeiCoreEntryPoint|MdePkg/Library/PeiCoreEntryPoint/PeiCoreEntryPoint.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/PeiReportStatusCodeLib/PeiReportStatusCodeLib.inf
+  OemHookStatusCodeLib|MdeModulePkg/Library/OemHookStatusCodeLibNull/OemHookStatusCodeLibNull.inf
+  PeCoffGetEntryPointLib|MdePkg/Library/BasePeCoffGetEntryPointLib/BasePeCoffGetEntryPointLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  PeCoffLib|MdePkg/Library/BasePeCoffLib/BasePeCoffLib.inf
+
+[LibraryClasses.common.PEIM]
+  HobLib|MdePkg/Library/PeiHobLib/PeiHobLib.inf
+  PeiServicesTablePointerLib|MdePkg/Library/PeiServicesTablePointerLibIdt/PeiServicesTablePointerLibIdt.inf
+  PeiServicesLib|MdePkg/Library/PeiServicesLib/PeiServicesLib.inf
+  MemoryAllocationLib|MdePkg/Library/PeiMemoryAllocationLib/PeiMemoryAllocationLib.inf
+  PeimEntryPoint|MdePkg/Library/PeimEntryPoint/PeimEntryPoint.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/PeiReportStatusCodeLib/PeiReportStatusCodeLib.inf
+  OemHookStatusCodeLib|MdeModulePkg/Library/OemHookStatusCodeLibNull/OemHookStatusCodeLibNull.inf
+  PeCoffGetEntryPointLib|MdePkg/Library/BasePeCoffGetEntryPointLib/BasePeCoffGetEntryPointLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  PeCoffLib|MdePkg/Library/BasePeCoffLib/BasePeCoffLib.inf
+
+  ExtractGuidedSectionLib|MdePkg/Library/PeiExtractGuidedSectionLib/PeiExtractGuidedSectionLib.inf
+!if $(SOURCE_DEBUG_ENABLE) == TRUE
+  DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/SecPeiDebugAgentLib.inf
+!endif
+  CpuExceptionHandlerLib|UefiCpuPkg/Library/CpuExceptionHandlerLib/PeiCpuExceptionHandlerLib.inf
+  MpInitLib|UefiCpuPkg/Library/MpInitLib/PeiMpInitLib.inf
+  PcdLib|MdePkg/Library/PeiPcdLib/PeiPcdLib.inf
+
+
+[LibraryClasses.common.DXE_CORE]
+  HobLib|MdePkg/Library/DxeCoreHobLib/DxeCoreHobLib.inf
+  DxeCoreEntryPoint|MdePkg/Library/DxeCoreEntryPoint/DxeCoreEntryPoint.inf
+  MemoryAllocationLib|MdeModulePkg/Library/DxeCoreMemoryAllocationLib/DxeCoreMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
+  ExtractGuidedSectionLib|MdePkg/Library/BaseExtractGuidedSectionLib/BaseExtractGuidedSectionLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+
+!if $(SOURCE_DEBUG_ENABLE) == TRUE
+  DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/DxeDebugAgentLib.inf
+!endif
+  CpuExceptionHandlerLib|UefiCpuPkg/Library/CpuExceptionHandlerLib/DxeCpuExceptionHandlerLib.inf
+  PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
+
+[LibraryClasses.common.DXE_RUNTIME_DRIVER]
+  PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
+  TimerLib|TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.inf
+ 
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  DxeCoreEntryPoint|MdePkg/Library/DxeCoreEntryPoint/DxeCoreEntryPoint.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/RuntimeDxeReportStatusCodeLib/RuntimeDxeReportStatusCodeLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  UefiRuntimeLib|MdePkg/Library/UefiRuntimeLib/UefiRuntimeLib.inf
+
+  PciLib|TestPkg/Library/DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf
+
+
+[LibraryClasses.common.UEFI_DRIVER]
+  PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
+  TimerLib|TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.inf
+  ResetSystemLib|TestPkg/Library/ResetSystemLib/DxeResetSystemLib.inf
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  DxeCoreEntryPoint|MdePkg/Library/DxeCoreEntryPoint/DxeCoreEntryPoint.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+
+  PciLib|TestPkg/Library/DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf
+
+[LibraryClasses.common.DXE_DRIVER]
+  PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
+  TimerLib|TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.inf
+
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
+  UefiScsiLib|MdePkg/Library/UefiScsiLib/UefiScsiLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+
+  CpuExceptionHandlerLib|UefiCpuPkg/Library/CpuExceptionHandlerLib/DxeCpuExceptionHandlerLib.inf
+
+!if $(SOURCE_DEBUG_ENABLE) == TRUE
+  DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/DxeDebugAgentLib.inf
+!endif
+  PciLib|TestPkg/Library/DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf
+  MpInitLib|UefiCpuPkg/Library/MpInitLib/DxeMpInitLib.inf
+
+
+[LibraryClasses.common.UEFI_APPLICATION]
+  PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
+  TimerLib|TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.inf
+  
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  PciLib|TestPkg/Library/DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf
+
+
+
diff --git a/TestPkg/License.txt b/TestPkg/License.txt
new file mode 100644
index 0000000000..1abc818d8c
--- /dev/null
+++ b/TestPkg/License.txt
@@ -0,0 +1,79 @@
+Copyright (c) 2012 - 2019, Intel Corporation. All rights reserved.
+
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice,
+   this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+Subject to the terms and conditions of this license, each copyright holder
+and contributor hereby grants to those receiving rights under this license
+a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+(except for failure to satisfy the conditions of this license) patent
+license to make, have made, use, offer to sell, sell, import, and otherwise
+transfer this software, where such license applies only to those patent
+claims, already acquired or hereafter acquired, licensable by such copyright
+holder or contributor that are necessarily infringed by:
+
+(a) their Contribution(s) (the licensed copyrights of copyright holders and
+    non-copyrightable additions of contributors, in source or binary form)
+    alone; or
+
+(b) combination of their Contribution(s) with the work of authorship to
+    which such Contribution(s) was added by such copyright holder or
+    contributor, if, at the time the Contribution is added, such addition
+    causes such combination to be necessarily infringed. The patent license
+    shall not apply to any other combinations which include the
+    Contribution.
+
+Except as expressly stated above, no rights or licenses from any copyright
+holder or contributor is granted under this license, whether expressly, by
+implication, estoppel or otherwise.
+
+DISCLAIMER
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+================================================================================
+
+Some files are subject to the following license, the MIT license. Those files
+are located in:
+- OvmfPkg/Include/IndustryStandard/Xen/
+- OvmfPkg/XenBusDxe/
+
+SPDX-License-Identifier: MIT
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice (including the next
+paragraph) shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/TestPkg/NetworkLibs.dsc b/TestPkg/NetworkLibs.dsc
new file mode 100644
index 0000000000..1810f5c889
--- /dev/null
+++ b/TestPkg/NetworkLibs.dsc
@@ -0,0 +1,210 @@
+################################################################################
+#
+# Library Class section - list of all Library Classes needed by this Platform.
+#
+################################################################################
+[LibraryClasses]
+  NvVarsFileLib|TestPkg/Library/NvVarsFileLib/NvVarsFileLib.inf
+  BaseLib|MdePkg/Library/BaseLib/BaseLib.inf
+  PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
+  BaseMemoryLib|MdePkg/Library/BaseMemoryLibRepStr/BaseMemoryLibRepStr.inf
+  DebugPrintErrorLevelLib|MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.inf
+  IoLib|MdePkg/Library/BaseIoLibIntrinsic/BaseIoLibIntrinsicSev.inf
+  PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf
+  UefiBootServicesTableLib|MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf
+  PciCf8Lib|MdePkg/Library/BasePciCf8Lib/BasePciCf8Lib.inf
+  PciLib|MdePkg/Library/BasePciLibCf8/BasePciLibCf8.inf
+  UefiRuntimeServicesTableLib|MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf
+  TimerLib|TestPkg/Library/AcpiTimerLib/BaseAcpiTimerLib.inf
+  PeCoffExtraActionLib|MdePkg/Library/BasePeCoffExtraActionLibNull/BasePeCoffExtraActionLibNull.inf
+  UefiLib|MdePkg/Library/UefiLib/UefiLib.inf
+  LocalApicLib|UefiCpuPkg/Library/BaseXApicX2ApicLib/BaseXApicX2ApicLib.inf
+  SynchronizationLib|MdePkg/Library/BaseSynchronizationLib/BaseSynchronizationLib.inf
+  SerialPortLib|PcAtChipsetPkg/Library/SerialIoLib/SerialIoLib.inf
+  PeCoffGetEntryPointLib|MdePkg/Library/BasePeCoffGetEntryPointLib/BasePeCoffGetEntryPointLib.inf
+  CacheMaintenanceLib|MdePkg/Library/BaseCacheMaintenanceLib/BaseCacheMaintenanceLib.inf
+  UefiDecompressLib|MdePkg/Library/BaseUefiDecompressLib/BaseUefiDecompressLib.inf
+  PerformanceLib|MdePkg/Library/BasePerformanceLibNull/BasePerformanceLibNull.inf
+  PeCoffLib|MdePkg/Library/BasePeCoffLib/BasePeCoffLib.inf
+  DxeServicesLib|MdePkg/Library/DxeServicesLib/DxeServicesLib.inf
+  DebugAgentLib|MdeModulePkg/Library/DebugAgentLibNull/DebugAgentLibNull.inf
+  UefiCpuLib|UefiCpuPkg/Library/BaseUefiCpuLib/BaseUefiCpuLib.inf
+  UefiDriverEntryPoint|MdePkg/Library/UefiDriverEntryPoint/UefiDriverEntryPoint.inf
+  DevicePathLib|MdePkg/Library/UefiDevicePathLibDevicePathProtocol/UefiDevicePathLibDevicePathProtocol.inf
+  PciExpressLib|MdePkg/Library/BasePciExpressLib/BasePciExpressLib.inf
+  SecurityManagementLib|MdeModulePkg/Library/DxeSecurityManagementLib/DxeSecurityManagementLib.inf
+  HiiLib|MdeModulePkg/Library/UefiHiiLib/UefiHiiLib.inf
+  UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf
+  UefiHiiServicesLib|MdeModulePkg/Library/UefiHiiServicesLib/UefiHiiServicesLib.inf
+  UefiBootManagerLib|MdeModulePkg/Library/UefiBootManagerLib/UefiBootManagerLib.inf
+  FileExplorerLib|MdeModulePkg/Library/FileExplorerLib/FileExplorerLib.inf
+  DxeServicesTableLib|MdePkg/Library/DxeServicesTableLib/DxeServicesTableLib.inf
+  SortLib|MdeModulePkg/Library/UefiSortLib/UefiSortLib.inf
+  CpuLib|MdePkg/Library/BaseCpuLib/BaseCpuLib.inf
+  MtrrLib|UefiCpuPkg/Library/MtrrLib/MtrrLib.inf
+  FakeLibraryLib|TestPkg/Library/BaseFakeLibraryLib/BaseFakeLibraryLib.inf
+  LockBoxLib|MdeModulePkg\Library\LockBoxNullLib\LockBoxNullLib.inf
+  DpcLib|NetworkPkg/Library/DxeDpcLib/DxeDpcLib.inf
+  NetLib|NetworkPkg/Library/DxeNetLib/DxeNetLib.inf
+  IpIoLib|NetworkPkg/Library/DxeIpIoLib/DxeIpIoLib.inf
+  UdpIoLib|NetworkPkg/Library/DxeUdpIoLib/DxeUdpIoLib.inf
+  TcpIoLib|NetworkPkg/Library/DxeTcpIoLib/DxeTcpIoLib.inf
+  # HttpLib is used for Http Boot
+  HttpLib|NetworkPkg/Library/DxeHttpLib/DxeHttpLib.inf
+
+[LibraryClasses.common.SEC]
+  TimerLib|TestPkg/Library/AcpiTimerLib/BaseRomAcpiTimerLib.inf
+  PpiListLib|EmulatorPkg/Library/SecPpiListLib/SecPpiListLib.inf
+  
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformRomDebugLibIoPort.inf
+!endif
+  ReportStatusCodeLib|MdeModulePkg/Library/PeiReportStatusCodeLib/PeiReportStatusCodeLib.inf
+  ExtractGuidedSectionLib|MdePkg/Library/BaseExtractGuidedSectionLib/BaseExtractGuidedSectionLib.inf
+!if $(SOURCE_DEBUG_ENABLE) == TRUE
+  DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/SecPeiDebugAgentLib.inf
+!endif
+  HobLib|MdePkg/Library/PeiHobLib/PeiHobLib.inf
+  PeiServicesLib|MdePkg/Library/PeiServicesLib/PeiServicesLib.inf
+  PeiServicesTablePointerLib|MdePkg/Library/PeiServicesTablePointerLibIdt/PeiServicesTablePointerLibIdt.inf
+  MemoryAllocationLib|MdePkg/Library/PeiMemoryAllocationLib/PeiMemoryAllocationLib.inf
+!if $(TOOL_CHAIN_TAG) == "XCODE5"
+  CpuExceptionHandlerLib|UefiCpuPkg/Library/CpuExceptionHandlerLib/Xcode5SecPeiCpuExceptionHandlerLib.inf
+!else
+  CpuExceptionHandlerLib|UefiCpuPkg/Library/CpuExceptionHandlerLib/SecPeiCpuExceptionHandlerLib.inf
+!endif
+
+[LibraryClasses.common.PEI_CORE]
+  HobLib|MdePkg/Library/PeiHobLib/PeiHobLib.inf
+  PeiServicesTablePointerLib|MdePkg/Library/PeiServicesTablePointerLibIdt/PeiServicesTablePointerLibIdt.inf
+  PeiServicesLib|MdePkg/Library/PeiServicesLib/PeiServicesLib.inf
+  MemoryAllocationLib|MdePkg/Library/PeiMemoryAllocationLib/PeiMemoryAllocationLib.inf
+  PeiCoreEntryPoint|MdePkg/Library/PeiCoreEntryPoint/PeiCoreEntryPoint.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/PeiReportStatusCodeLib/PeiReportStatusCodeLib.inf
+  OemHookStatusCodeLib|MdeModulePkg/Library/OemHookStatusCodeLibNull/OemHookStatusCodeLibNull.inf
+  PeCoffGetEntryPointLib|MdePkg/Library/BasePeCoffGetEntryPointLib/BasePeCoffGetEntryPointLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  PeCoffLib|MdePkg/Library/BasePeCoffLib/BasePeCoffLib.inf
+
+[LibraryClasses.common.PEIM]
+  HobLib|MdePkg/Library/PeiHobLib/PeiHobLib.inf
+  PeiServicesTablePointerLib|MdePkg/Library/PeiServicesTablePointerLibIdt/PeiServicesTablePointerLibIdt.inf
+  PeiServicesLib|MdePkg/Library/PeiServicesLib/PeiServicesLib.inf
+  MemoryAllocationLib|MdePkg/Library/PeiMemoryAllocationLib/PeiMemoryAllocationLib.inf
+  PeimEntryPoint|MdePkg/Library/PeimEntryPoint/PeimEntryPoint.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/PeiReportStatusCodeLib/PeiReportStatusCodeLib.inf
+  OemHookStatusCodeLib|MdeModulePkg/Library/OemHookStatusCodeLibNull/OemHookStatusCodeLibNull.inf
+  PeCoffGetEntryPointLib|MdePkg/Library/BasePeCoffGetEntryPointLib/BasePeCoffGetEntryPointLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  PeCoffLib|MdePkg/Library/BasePeCoffLib/BasePeCoffLib.inf
+
+  ExtractGuidedSectionLib|MdePkg/Library/PeiExtractGuidedSectionLib/PeiExtractGuidedSectionLib.inf
+!if $(SOURCE_DEBUG_ENABLE) == TRUE
+  DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/SecPeiDebugAgentLib.inf
+!endif
+  CpuExceptionHandlerLib|UefiCpuPkg/Library/CpuExceptionHandlerLib/PeiCpuExceptionHandlerLib.inf
+  MpInitLib|UefiCpuPkg/Library/MpInitLib/PeiMpInitLib.inf
+  PcdLib|MdePkg/Library/PeiPcdLib/PeiPcdLib.inf
+
+
+[LibraryClasses.common.DXE_CORE]
+  HobLib|MdePkg/Library/DxeCoreHobLib/DxeCoreHobLib.inf
+  DxeCoreEntryPoint|MdePkg/Library/DxeCoreEntryPoint/DxeCoreEntryPoint.inf
+  MemoryAllocationLib|MdeModulePkg/Library/DxeCoreMemoryAllocationLib/DxeCoreMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
+  ExtractGuidedSectionLib|MdePkg/Library/BaseExtractGuidedSectionLib/BaseExtractGuidedSectionLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+
+!if $(SOURCE_DEBUG_ENABLE) == TRUE
+  DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/DxeDebugAgentLib.inf
+!endif
+  CpuExceptionHandlerLib|UefiCpuPkg/Library/CpuExceptionHandlerLib/DxeCpuExceptionHandlerLib.inf
+  PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
+
+[LibraryClasses.common.DXE_RUNTIME_DRIVER]
+  PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
+  TimerLib|TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.inf
+ 
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  DxeCoreEntryPoint|MdePkg/Library/DxeCoreEntryPoint/DxeCoreEntryPoint.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/RuntimeDxeReportStatusCodeLib/RuntimeDxeReportStatusCodeLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  UefiRuntimeLib|MdePkg/Library/UefiRuntimeLib/UefiRuntimeLib.inf
+
+  PciLib|TestPkg/Library/DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf
+
+
+[LibraryClasses.common.UEFI_DRIVER]
+  PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
+  TimerLib|TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.inf
+  ResetSystemLib|TestPkg/Library/ResetSystemLib/DxeResetSystemLib.inf
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  DxeCoreEntryPoint|MdePkg/Library/DxeCoreEntryPoint/DxeCoreEntryPoint.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+
+  PciLib|TestPkg/Library/DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf
+
+[LibraryClasses.common.DXE_DRIVER]
+  PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
+  TimerLib|TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.inf
+
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
+  UefiScsiLib|MdePkg/Library/UefiScsiLib/UefiScsiLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+
+  CpuExceptionHandlerLib|UefiCpuPkg/Library/CpuExceptionHandlerLib/DxeCpuExceptionHandlerLib.inf
+
+!if $(SOURCE_DEBUG_ENABLE) == TRUE
+  DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/DxeDebugAgentLib.inf
+!endif
+  PciLib|TestPkg/Library/DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf
+  MpInitLib|UefiCpuPkg/Library/MpInitLib/DxeMpInitLib.inf
+
+
+[LibraryClasses.common.UEFI_APPLICATION]
+  PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
+  TimerLib|TestPkg/Library/AcpiTimerLib/DxeAcpiTimerLib.inf
+  
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
+!ifdef $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|TestPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  PciLib|TestPkg/Library/DxePciLibI440FxQ35/DxePciLibI440FxQ35.inf
+
+
+
diff --git a/TestPkg/OvmfPkg.ci.yaml b/TestPkg/OvmfPkg.ci.yaml
new file mode 100644
index 0000000000..31532c139e
--- /dev/null
+++ b/TestPkg/OvmfPkg.ci.yaml
@@ -0,0 +1,83 @@
+## @file
+# Core CI configuration for OvmfPkg
+#
+# OvmfPkg is part of Platform Ci for builds so this is only
+# used for code analysis.
+#
+# Copyright (c) Microsoft Corporation
+# SPDX-License-Identifier: BSD-2-Clause-Patent
+##
+{
+    ## options defined .pytool/Plugin/CompilerPlugin
+    "CompilerPlugin": {
+        "DscPath": "" # Don't support this test
+    },
+
+    ## options defined .pytool/Plugin/HostUnitTestCompilerPlugin
+    "HostUnitTestCompilerPlugin": {
+        "DscPath": "" # Don't support this test
+    },
+
+    ## options defined .pytool/Plugin/CharEncodingCheck
+    "CharEncodingCheck": {
+        "IgnoreFiles": []
+    },
+
+    ## options defined .pytool/Plugin/DependencyCheck
+    "DependencyCheck": {
+        "AcceptableDependencies": [
+            "MdePkg/MdePkg.dec",
+            "MdeModulePkg/MdeModulePkg.dec",
+            "OvmfPkg/OvmfPkg.dec",
+            "NetworkPkg/NetworkPkg.dec",
+            "SecurityPkg/SecurityPkg.dec",
+            "UefiCpuPkg/UefiCpuPkg.dec",
+            "ShellPkg/ShellPkg.dec",
+            "EmbeddedPkg/EmbeddedPkg.dec",
+            "SourceLevelDebugPkg/SourceLevelDebugPkg.dec"
+        ],
+        # For host based unit tests
+        "AcceptableDependencies-HOST_APPLICATION":[
+            "UnitTestFrameworkPkg/UnitTestFrameworkPkg.dec"
+        ],
+        # For UEFI shell based apps
+        "AcceptableDependencies-UEFI_APPLICATION":[],
+        "IgnoreInf": []
+    },
+
+    ## options defined .pytool/Plugin/DscCompleteCheck
+    "DscCompleteCheck": {
+        "IgnoreInf": [""],
+        "DscPath": ""  # Don't support this test
+    },
+
+    ## options defined .pytool/Plugin/HostUnitTestDscCompleteCheck
+    "HostUnitTestDscCompleteCheck": {
+        "IgnoreInf": [""],
+        "DscPath": "" # Don't support this test
+    },
+
+    ## options defined .pytool/Plugin/GuidCheck
+    "GuidCheck": {
+        "IgnoreGuidName": ["ResetVector", "XenResetVector"], # Expected duplication for gEfiFirmwareVolumeTopFileGuid
+        "IgnoreGuidValue": [],
+        "IgnoreFoldersAndFiles": [],
+        "IgnoreDuplicates": [],
+    },
+
+    ## options defined .pytool/Plugin/LibraryClassCheck
+    "LibraryClassCheck": {
+        "IgnoreHeaderFile": []
+    },
+
+    ## options defined .pytool/Plugin/SpellCheck
+    "SpellCheck": {
+        "AuditOnly": True,           # Fails right now with over 270 errors
+        "IgnoreFiles": [],           # use gitignore syntax to ignore errors in matching files
+        "ExtendWords": [
+
+        ],           # words to extend to the dictionary for this package
+        "IgnoreStandardPaths": [],   # Standard Plugin defined paths that should be ignore
+        "AdditionalIncludePaths": [] # Additional paths to spell check (wildcards supported)
+    }
+}
diff --git a/TestPkg/PcdSettings.dsc b/TestPkg/PcdSettings.dsc
new file mode 100644
index 0000000000..e6f6a91b58
--- /dev/null
+++ b/TestPkg/PcdSettings.dsc
@@ -0,0 +1,185 @@
+################################################################################
+#
+# Pcd Section - list of all EDK II PCD Entries defined by this Platform.
+#
+################################################################################
+[PcdsFeatureFlag]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdHiiOsRuntimeSupport|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdStatusCodeUseSerial|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdStatusCodeUseMemory|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdDxeIplSupportUefiDecompress|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdDxeIplSwitchToLongMode|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdConOutGopSupport|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdConOutUgaSupport|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdInstallAcpiSdtProtocol|TRUE
+!ifdef $(CSM_ENABLE)
+  gUefiOvmfPkgTokenSpaceGuid.PcdCsmEnable|TRUE
+!endif
+!if $(SMM_REQUIRE) == TRUE
+  gUefiOvmfPkgTokenSpaceGuid.PcdSmmSmramRequire|TRUE
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuHotPlugSupport|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdEnableVariableRuntimeCache|FALSE
+!endif
+
+[PcdsFixedAtBuild]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdStatusCodeMemorySize|1
+!if $(SMM_REQUIRE) == FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdResetOnMemoryTypeInformationChange|FALSE
+!endif
+  gEfiMdePkgTokenSpaceGuid.PcdMaximumGuidedExtractHandler|0x10
+!if ($(FD_SIZE_IN_KB) == 1024) || ($(FD_SIZE_IN_KB) == 2048)
+  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxVariableSize|0x2000
+  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxAuthVariableSize|0x2800
+!if $(NETWORK_TLS_ENABLE) == FALSE
+  # match PcdFlashNvStorageVariableSize purely for convenience
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVariableStoreSize|0xe000
+!endif
+!endif
+!if $(FD_SIZE_IN_KB) == 4096
+  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxVariableSize|0x8400
+  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxAuthVariableSize|0x8400
+!if $(NETWORK_TLS_ENABLE) == FALSE
+  # match PcdFlashNvStorageVariableSize purely for convenience
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVariableStoreSize|0x40000
+!endif
+!endif
+!if $(NETWORK_TLS_ENABLE) == TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVariableStoreSize|0x80000
+  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxVolatileVariableSize|0x40000
+!endif
+
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVpdBaseAddress|0x0
+
+  gEfiMdePkgTokenSpaceGuid.PcdReportStatusCodePropertyMask|0x07
+
+  # DEBUG_INIT      0x00000001  // Initialization
+  # DEBUG_WARN      0x00000002  // Warnings
+  # DEBUG_LOAD      0x00000004  // Load events
+  # DEBUG_FS        0x00000008  // EFI File system
+  # DEBUG_POOL      0x00000010  // Alloc & Free (pool)
+  # DEBUG_PAGE      0x00000020  // Alloc & Free (page)
+  # DEBUG_INFO      0x00000040  // Informational debug messages
+  # DEBUG_DISPATCH  0x00000080  // PEI/DXE/SMM Dispatchers
+  # DEBUG_VARIABLE  0x00000100  // Variable
+  # DEBUG_BM        0x00000400  // Boot Manager
+  # DEBUG_BLKIO     0x00001000  // BlkIo Driver
+  # DEBUG_NET       0x00004000  // SNP Driver
+  # DEBUG_UNDI      0x00010000  // UNDI Driver
+  # DEBUG_LOADFILE  0x00020000  // LoadFile
+  # DEBUG_EVENT     0x00080000  // Event messages
+  # DEBUG_GCD       0x00100000  // Global Coherency Database changes
+  # DEBUG_CACHE     0x00200000  // Memory range cachability changes
+  # DEBUG_VERBOSE   0x00400000  // Detailed debug messages that may
+  #                             // significantly impact boot performance
+  # DEBUG_ERROR     0x80000000  // Error
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel|0x8000004F
+
+!if $(SOURCE_DEBUG_ENABLE) == TRUE
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0x17
+!else
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0x2F
+!endif
+
+  # This PCD is used to set the base address of the PCI express hierarchy. It
+  # is only consulted when OVMF runs on Q35. In that case it is programmed into
+  # the PCIEXBAR register.
+  #
+  # On Q35 machine types that QEMU intends to support in the long term, QEMU
+  # never lets the RAM below 4 GB exceed 2816 MB.
+  gEfiMdePkgTokenSpaceGuid.PcdPciExpressBaseAddress|0xB0000000
+
+!if $(SOURCE_DEBUG_ENABLE) == TRUE
+  gEfiSourceLevelDebugPkgTokenSpaceGuid.PcdDebugLoadImageMethod|0x2
+!endif
+
+[PcdsFixedAtBuild.X64]
+  #
+  # Network Pcds
+  #
+!include NetworkPkg/NetworkPcds.dsc.inc
+
+!if $(SMM_REQUIRE) == TRUE
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuSmmStackSize|0x4000
+!endif
+
+  # IRQs 5, 9, 10, 11 are level-triggered
+  gUefiOvmfPkgTokenSpaceGuid.Pcd8259LegacyModeEdgeLevel|0x0E20
+
+  # Point to the MdeModulePkg/Application/UiApp/UiApp.inf
+  gEfiMdeModulePkgTokenSpaceGuid.PcdBootManagerMenuFile|{ 0x21, 0xaa, 0x2c, 0x46, 0x14, 0x76, 0x03, 0x45, 0x83, 0x6e, 0x8a, 0xb6, 0xf4, 0x66, 0x23, 0x31 }
+
+################################################################################
+#
+# Pcd Dynamic Section - list of all EDK II PCD Entries defined by this Platform
+#
+################################################################################
+
+[PcdsDynamicDefault]
+  # only set when
+  #   ($(SMM_REQUIRE) == FALSE)
+  gEfiMdeModulePkgTokenSpaceGuid.PcdEmuVariableNvStoreReserved|0
+
+!if $(SMM_REQUIRE) == FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableBase64|0
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingBase|0
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareBase|0
+!endif
+  gEfiMdeModulePkgTokenSpaceGuid.PcdPciDisableBusEnumeration|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVideoHorizontalResolution|800
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVideoVerticalResolution|600
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiS3Enable|FALSE
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfHostBridgePciDevId|0
+  gUefiOvmfPkgTokenSpaceGuid.PcdPciIoBase|0x0
+  gUefiOvmfPkgTokenSpaceGuid.PcdPciIoSize|0x0
+  gUefiOvmfPkgTokenSpaceGuid.PcdPciMmio32Base|0x0
+  gUefiOvmfPkgTokenSpaceGuid.PcdPciMmio32Size|0x0
+  gUefiOvmfPkgTokenSpaceGuid.PcdPciMmio64Base|0x0
+!ifdef $(CSM_ENABLE)
+  gUefiOvmfPkgTokenSpaceGuid.PcdPciMmio64Size|0x0
+!else
+  gUefiOvmfPkgTokenSpaceGuid.PcdPciMmio64Size|0x800000000
+!endif
+
+  gEfiMdePkgTokenSpaceGuid.PcdPlatformBootTimeOut|0
+
+  # Set video resolution for text setup.
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSetupVideoHorizontalResolution|640
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSetupVideoVerticalResolution|480
+
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSmbiosVersion|0x0208
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSmbiosDocRev|0x0
+  gUefiOvmfPkgTokenSpaceGuid.PcdQemuSmbiosValidated|FALSE
+
+  # Noexec settings for DXE.
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSetNxForStack|FALSE
+
+  # UefiCpuPkg PCDs related to initial AP bringup and general AP management.
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuMaxLogicalProcessorNumber|64
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuBootLogicalProcessorNumber|0
+
+  # Set memory encryption mask
+  gEfiMdeModulePkgTokenSpaceGuid.PcdPteMemoryEncryptionAddressOrMask|0x0
+
+!if $(SMM_REQUIRE) == TRUE
+  gUefiOvmfPkgTokenSpaceGuid.PcdQ35TsegMbytes|8
+  gUefiOvmfPkgTokenSpaceGuid.PcdQ35SmramAtDefaultSmbase|FALSE
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuSmmSyncMode|0x01
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuSmmApSyncTimeout|100000
+!endif
+
+  gEfiSecurityPkgTokenSpaceGuid.PcdOptionRomImageVerificationPolicy|0x00
+
+!if $(TPM_ENABLE) == TRUE
+  gEfiSecurityPkgTokenSpaceGuid.PcdTpmInstanceGuid|{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
+!endif
+
+[PcdsDynamicDefault.X64]
+  # IPv4 and IPv6 PXE Boot support.
+  gEfiNetworkPkgTokenSpaceGuid.PcdIPv4PXESupport|0x01
+  gEfiNetworkPkgTokenSpaceGuid.PcdIPv6PXESupport|0x01
+
+[PcdsDynamicHii]
+!if $(TPM_ENABLE) == TRUE && $(TPM_CONFIG_ENABLE) == TRUE
+  gEfiSecurityPkgTokenSpaceGuid.PcdTcgPhysicalPresenceInterfaceVer|L"TCG2_VERSION"|gTcg2ConfigFormSetGuid|0x0|"1.3"|NV,BS
+  gEfiSecurityPkgTokenSpaceGuid.PcdTpm2AcpiTableRev|L"TCG2_VERSION"|gTcg2ConfigFormSetGuid|0x8|3|NV,BS
+!endif
\ No newline at end of file
diff --git a/TestPkg/PlatformBuild.py b/TestPkg/PlatformBuild.py
new file mode 100644
index 0000000000..6b159d354d
--- /dev/null
+++ b/TestPkg/PlatformBuild.py
@@ -0,0 +1,156 @@
+﻿# @file
+# Script to Build OVMF UEFI firmware
+#
+# Copyright (c) Microsoft Corporation.
+# SPDX-License-Identifier: BSD-2-Clause-Patent
+##
+import os
+import logging
+
+from edk2toolext.environment import shell_environment
+from edk2toolext.environment.uefi_build import UefiBuilder
+from edk2toolext.invocables.edk2_platform_build import BuildSettingsManager
+from edk2toolext.invocables.edk2_setup import SetupSettingsManager, RequiredSubmodule
+from edk2toolext.invocables.edk2_update import UpdateSettingsManager
+
+
+    # ####################################################################################### #
+    #                                Common Configuration                                     #
+    # ####################################################################################### #
+class CommonPlatform():
+    ''' Common settings for this platform.  Define static data here and use
+        for the different parts of stuart
+    '''
+    PackagesSupported = ("TestPkg",)
+    ArchSupported = ("IA32", "X64")
+    TargetsSupported = ("DEBUG", "RELEASE", "NOOPT")
+    Scopes = ('testpkg', 'edk2-build')
+    WorkspaceRoot = os.path.realpath(os.path.join(
+        os.path.dirname(os.path.abspath(__file__)), ".."))
+
+
+    # ####################################################################################### #
+    #                         Configuration for Update & Setup                                #
+    # ####################################################################################### #
+class SettingsManager(UpdateSettingsManager, SetupSettingsManager):
+
+    def GetPackagesSupported(self):
+        ''' return iterable of edk2 packages supported by this build.
+        These should be edk2 workspace relative paths '''
+        return CommonPlatform.PackagesSupported
+
+    def GetArchitecturesSupported(self):
+        ''' return iterable of edk2 architectures supported by this build '''
+        return CommonPlatform.ArchSupported
+
+    def GetTargetsSupported(self):
+        ''' return iterable of edk2 target tags supported by this build '''
+        return CommonPlatform.TargetsSupported
+
+    def GetRequiredSubmodules(self):
+        ''' return iterable containing RequiredSubmodule objects.
+        If no RequiredSubmodules return an empty iterable
+        '''
+        rs = []
+        rs.append(RequiredSubmodule(
+            "ArmPkg/Library/ArmSoftFloatLib/berkeley-softfloat-3", False))
+        rs.append(RequiredSubmodule(
+            "CryptoPkg/Library/OpensslLib/openssl", False))
+        rs.append(RequiredSubmodule(
+            "UnitTestFrameworkPkg/Library/CmockaLib/cmocka", False))
+        rs.append(RequiredSubmodule(
+            "MdeModulePkg/Universal/RegularExpressionDxe/oniguruma", False))
+        rs.append(RequiredSubmodule(
+            "MdeModulePkg/Library/BrotliCustomDecompressLib/brotli", False))
+        rs.append(RequiredSubmodule(
+            "BaseTools/Source/C/BrotliCompress/brotli", False))
+        return rs
+
+    def SetArchitectures(self, list_of_requested_architectures):
+        ''' Confirm the requests architecture list is valid and configure SettingsManager
+        to run only the requested architectures.
+
+        Raise Exception if a list_of_requested_architectures is not supported
+        '''
+        unsupported = set(list_of_requested_architectures) - set(self.GetArchitecturesSupported())
+        if(len(unsupported) > 0):
+            errorString = ( "Unsupported Architecture Requested: " + " ".join(unsupported))
+            logging.critical( errorString )
+            raise Exception( errorString )
+        self.ActualArchitectures = list_of_requested_architectures
+
+    def GetWorkspaceRoot(self):
+        ''' get WorkspacePath '''
+        return CommonPlatform.WorkspaceRoot
+
+    def GetActiveScopes(self):
+        ''' return tuple containing scopes that should be active for this process '''
+        return CommonPlatform.Scopes
+
+
+    # ####################################################################################### #
+    #                         Actual Configuration for Platform Build                         #
+    # ####################################################################################### #
+class PlatformBuilder( UefiBuilder, BuildSettingsManager):
+    def __init__(self):
+        UefiBuilder.__init__(self)
+
+    def AddCommandLineOptions(self, parserObj):
+        ''' Add command line options to the argparser '''
+        parserObj.add_argument('-a', "--arch", dest="build_arch", type=str, default="IA32,X64",
+            help="Optional - CSV of architecture to build.  IA32 will use IA32 for Pei & Dxe. "
+            "X64 will use X64 for both PEI and DXE.  IA32,X64 will use IA32 for PEI and "
+            "X64 for DXE. default is IA32,X64")
+        super().AddCommandLineOptions(parserObj)
+
+    def RetrieveCommandLineOptions(self, args):
+        '''  Retrieve command line options from the argparser '''
+
+        shell_environment.GetBuildVars().SetValue("TARGET_ARCH"," ".join(args.build_arch.upper().split(",")), "From CmdLine")
+        
+        dsc = "TestPkg"
+        if "IA32" in args.build_arch.upper().split(","):
+            dsc += "Ia32"
+        if "X64" in args.build_arch.upper().split(","):
+            dsc += "X64"
+        dsc += ".dsc"
+
+        shell_environment.GetBuildVars().SetValue("ACTIVE_PLATFORM", f"TestPkg/{dsc}", "From CmdLine")
+#        UefiBuilder.RetrieveCommandLineOptions(self, args)
+
+    def GetWorkspaceRoot(self):
+        ''' get WorkspacePath '''
+        return CommonPlatform.WorkspaceRoot
+
+    def GetPackagesPath(self):
+        ''' Return a list of workspace relative paths that should be mapped as edk2 PackagesPath '''
+        return ()
+    
+    def GetActiveScopes(self):
+        ''' return tuple containing scopes that should be active for this process '''
+        return CommonPlatform.Scopes
+
+    def GetName(self):
+        ''' Get the name of the repo, platform, or product being build '''
+        ''' Used for naming the log file, among others '''
+        return "TestPkg"
+
+    def GetLoggingLevel(self, loggerType):
+        ''' Get the logging level for a given type
+        base == lowest logging level supported
+        con  == Screen logging
+        txt  == plain text file logging
+        md   == markdown file logging
+        '''
+        return logging.DEBUG
+
+    def SetPlatformEnv(self):
+        logging.debug("PlatformBuilder SetPlatformEnv")
+        self.env.SetValue("PRODUCT_NAME", "TestPkg", "Platform Hardcoded")        
+        return 0
+
+    def PlatformPreBuild(self):
+        return 0
+
+    def PlatformPostBuild(self):
+        return 0
diff --git a/TestPkg/PlatformDxe/FirstTestFile.h b/TestPkg/PlatformDxe/FirstTestFile.h
new file mode 100644
index 0000000000..5eb54f48de
--- /dev/null
+++ b/TestPkg/PlatformDxe/FirstTestFile.h
@@ -0,0 +1,9 @@
+/** @file
+Head file for front page.
+
+Copyright (c) 2004 - 2016, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define efi_guid_testaddr 0x136b3448
\ No newline at end of file
diff --git a/TestPkg/PlatformDxe/ForAddTest.hfr b/TestPkg/PlatformDxe/ForAddTest.hfr
new file mode 100644
index 0000000000..d44f2faeb7
--- /dev/null
+++ b/TestPkg/PlatformDxe/ForAddTest.hfr
@@ -0,0 +1,16 @@
+///** @file
+//  Boot Maintenance Utility Formset
+//
+//  Copyright (c) 2004 - 2018, Intel Corporation. All rights reserved.<BR>
+//  SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+//**/
+
+
+    form formid = FORM_DRV_CHG_ID,
+       title = STRING_TOKEN(STR_FORM_DRV_CHG_TITLE);
+
+       label FORM_DRV_CHG_ID;
+       label LABEL_END;
+
+    endform;
\ No newline at end of file
diff --git a/TestPkg/PlatformDxe/JustATest.uni b/TestPkg/PlatformDxe/JustATest.uni
new file mode 100644
index 0000000000000000000000000000000000000000..25c48dcb2d7a7d62ca39c844e3612d4a440b05ef
GIT binary patch
literal 904
zcmb7@+e*Vg5QhJ2!FO2dwZ4N54GKMxsJBIEdVttU4y8}8ezRdou_RHJ?ab_UcK-Qx
z^YyJe<$BjaTdkF8Bj-oP%DrBd5{)$R`?>ZiwIjaOO-J5F1$nU&pBEEx_Sy3KvaDKD
z*Q%weyrMO~1*+UX>-U{>t*Ggxq-H^X#=)WBg$`EqvB1uVC#<ZP&&(-Ns1a;Su}1Y4
zl8$-FaG^I&idkQJ;uWlq)cjy2!aES}$*euI3g6ZOwZG|mLfMq_gR0gJ>x;PA<{g;!
zlV@)lYVOX#A*lbnQeV<(#c1f2dKgeW(<2<`7ks<O4y$f;rN314lS?3#q9Edp+gt4(
m!y1;{n0+}J);xQ$3ATh@4!>}h4yF}*bN0^O8}pAN-slH7nT&q`

literal 0
HcmV?d00001

diff --git a/TestPkg/PlatformDxe/Platform.c b/TestPkg/PlatformDxe/Platform.c
new file mode 100644
index 0000000000..92e24ca00a
--- /dev/null
+++ b/TestPkg/PlatformDxe/Platform.c
@@ -0,0 +1,869 @@
+/** @file
+  This driver effectuates OVMF's platform configuration settings and exposes
+  them via HII.
+
+  Copyright (C) 2014, Red Hat, Inc.
+  Copyright (c) 2009 - 2014, Intel Corporation. All rights reserved.<BR>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#include <Library/BaseLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/DebugLib.h>
+#include <Library/DevicePathLib.h>
+#include <Library/HiiLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/PrintLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiHiiServicesLib.h>
+#include <Protocol/DevicePath.h>
+#include <Protocol/GraphicsOutput.h>
+#include <Protocol/HiiConfigAccess.h>
+#include <Guid/MdeModuleHii.h>
+#include <Guid/OvmfPlatformConfig.h>
+
+#include "Platform.h"
+#include "PlatformConfig.h"
+
+//
+// The HiiAddPackages() library function requires that any controller (or
+// image) handle, to be associated with the HII packages under installation, be
+// "decorated" with a device path. The tradition seems to be a vendor device
+// path.
+//
+// We'd like to associate our HII packages with the driver's image handle. The
+// first idea is to use the driver image's device path. Unfortunately, loaded
+// images only come with an EFI_LOADED_IMAGE_DEVICE_PATH_PROTOCOL (not the
+// usual EFI_DEVICE_PATH_PROTOCOL), ie. a different GUID. In addition, even the
+// EFI_LOADED_IMAGE_DEVICE_PATH_PROTOCOL interface may be NULL, if the image
+// has been loaded from an "unnamed" memory source buffer.
+//
+// Hence let's just stick with the tradition -- use a dedicated vendor device
+// path, with the driver's FILE_GUID.
+//
+#pragma pack(1)
+typedef struct {
+  VENDOR_DEVICE_PATH       VendorDevicePath;
+  EFI_DEVICE_PATH_PROTOCOL End;
+} PKG_DEVICE_PATH;
+#pragma pack()
+
+STATIC PKG_DEVICE_PATH mPkgDevicePath = {
+  {
+    {
+      HARDWARE_DEVICE_PATH,
+      HW_VENDOR_DP,
+      {
+        (UINT8) (sizeof (VENDOR_DEVICE_PATH)     ),
+        (UINT8) (sizeof (VENDOR_DEVICE_PATH) >> 8)
+      }
+    },
+    EFI_CALLER_ID_GUID
+  },
+  {
+    END_DEVICE_PATH_TYPE,
+    END_ENTIRE_DEVICE_PATH_SUBTYPE,
+    {
+      (UINT8) (END_DEVICE_PATH_LENGTH     ),
+      (UINT8) (END_DEVICE_PATH_LENGTH >> 8)
+    }
+  }
+};
+
+//
+// The configuration interface between the HII engine (form display etc) and
+// this driver.
+//
+STATIC EFI_HII_CONFIG_ACCESS_PROTOCOL mConfigAccess;
+
+//
+// The handle representing our list of packages after installation.
+//
+STATIC EFI_HII_HANDLE mInstalledPackages;
+
+//
+// The arrays below constitute our HII package list. They are auto-generated by
+// the VFR compiler and linked into the driver image during the build.
+//
+// - The strings package receives its C identifier from the driver's BASE_NAME,
+//   plus "Strings".
+//
+// - The forms package receives its C identifier from the VFR file's basename,
+//   plus "Bin".
+//
+//
+extern UINT8 PlatformDxeStrings[];
+extern UINT8 PlatformFormsBin[];
+
+//
+// We want to be notified about GOP installations until we find one GOP
+// interface that lets us populate the form.
+//
+STATIC EFI_EVENT mGopEvent;
+
+//
+// The registration record underneath this pointer allows us to iterate through
+// the GOP instances one by one.
+//
+STATIC VOID *mGopTracker;
+
+//
+// Cache the resolutions we get from the GOP.
+//
+typedef struct {
+  UINT32 X;
+  UINT32 Y;
+} GOP_MODE;
+
+STATIC UINTN    mNumGopModes;
+STATIC GOP_MODE *mGopModes;
+
+
+/**
+  Load the persistent platform configuration and translate it to binary form
+  state.
+
+  If the platform configuration is missing, then the function fills in a
+  default state.
+
+  @param[out] MainFormState  Binary form/widget state after translation.
+
+  @retval EFI_SUCCESS  Form/widget state ready.
+  @return              Error codes from underlying functions.
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+PlatformConfigToFormState (
+  OUT MAIN_FORM_STATE *MainFormState
+  )
+{
+  EFI_STATUS      Status;
+  PLATFORM_CONFIG PlatformConfig;
+  UINT64          OptionalElements;
+  UINTN           ModeNumber;
+
+  ZeroMem (MainFormState, sizeof *MainFormState);
+
+  Status = PlatformConfigLoad (&PlatformConfig, &OptionalElements);
+  switch (Status) {
+  case EFI_SUCCESS:
+    if (OptionalElements & PLATFORM_CONFIG_F_GRAPHICS_RESOLUTION) {
+      //
+      // Format the preferred resolution as text.
+      //
+      UnicodeSPrintAsciiFormat (
+        (CHAR16 *) MainFormState->CurrentPreferredResolution,
+        sizeof MainFormState->CurrentPreferredResolution,
+        "%Ldx%Ld",
+        (INT64) PlatformConfig.HorizontalResolution,
+        (INT64) PlatformConfig.VerticalResolution);
+
+      //
+      // Try to locate it in the drop-down list too. This may not succeed, but
+      // that's fine.
+      //
+      for (ModeNumber = 0; ModeNumber < mNumGopModes; ++ModeNumber) {
+        if (mGopModes[ModeNumber].X == PlatformConfig.HorizontalResolution &&
+            mGopModes[ModeNumber].Y == PlatformConfig.VerticalResolution) {
+          MainFormState->NextPreferredResolution = (UINT32) ModeNumber;
+          break;
+        }
+      }
+
+      break;
+    }
+    //
+    // fall through otherwise
+    //
+
+  case EFI_NOT_FOUND:
+    UnicodeSPrintAsciiFormat (
+      (CHAR16 *) MainFormState->CurrentPreferredResolution,
+      sizeof MainFormState->CurrentPreferredResolution,
+      "Unset");
+    break;
+
+  default:
+    return Status;
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function is called by the HII machinery when it fetches the form state.
+
+  See the precise documentation in the UEFI spec.
+
+  @param[in]  This      The Config Access Protocol instance.
+
+  @param[in]  Request   A <ConfigRequest> format UCS-2 string describing the
+                        query.
+
+  @param[out] Progress  A pointer into Request on output, identifying the query
+                        element where processing failed.
+
+  @param[out] Results   A <MultiConfigAltResp> format UCS-2 string that has
+                        all values filled in for the names in the Request
+                        string.
+
+  @retval EFI_SUCCESS  Extraction of form state in <MultiConfigAltResp>
+                       encoding successful.
+  @return              Status codes from underlying functions.
+
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+ExtractConfig (
+  IN CONST  EFI_HII_CONFIG_ACCESS_PROTOCOL  *This,
+  IN CONST  EFI_STRING                      Request,
+  OUT       EFI_STRING                      *Progress,
+  OUT       EFI_STRING                      *Results
+)
+{
+  MAIN_FORM_STATE MainFormState;
+  EFI_STATUS      Status;
+
+  DEBUG ((DEBUG_VERBOSE, "%a: Request=\"%s\"\n", __FUNCTION__, Request));
+
+  Status = PlatformConfigToFormState (&MainFormState);
+  if (EFI_ERROR (Status)) {
+    *Progress = Request;
+    return Status;
+  }
+
+  //
+  // Answer the textual request keying off the binary form state.
+  //
+  Status = gHiiConfigRouting->BlockToConfig (gHiiConfigRouting, Request,
+                                (VOID *) &MainFormState, sizeof MainFormState,
+                                Results, Progress);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "%a: BlockToConfig(): %r, Progress=\"%s\"\n",
+      __FUNCTION__, Status, (Status == EFI_DEVICE_ERROR) ? NULL : *Progress));
+  } else {
+    DEBUG ((DEBUG_VERBOSE, "%a: Results=\"%s\"\n", __FUNCTION__, *Results));
+  }
+  return Status;
+}
+
+
+/**
+  Interpret the binary form state and save it as persistent platform
+  configuration.
+
+  @param[in] MainFormState  Binary form/widget state to verify and save.
+
+  @retval EFI_SUCCESS  Platform configuration saved.
+  @return              Error codes from underlying functions.
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+FormStateToPlatformConfig (
+  IN CONST MAIN_FORM_STATE *MainFormState
+  )
+{
+  EFI_STATUS      Status;
+  PLATFORM_CONFIG PlatformConfig;
+  CONST GOP_MODE  *GopMode;
+
+  //
+  // There's nothing to do with the textual CurrentPreferredResolution field.
+  // We verify and translate the selection in the drop-down list.
+  //
+  if (MainFormState->NextPreferredResolution >= mNumGopModes) {
+    return EFI_INVALID_PARAMETER;
+  }
+  GopMode = mGopModes + MainFormState->NextPreferredResolution;
+
+  ZeroMem (&PlatformConfig, sizeof PlatformConfig);
+  PlatformConfig.HorizontalResolution = GopMode->X;
+  PlatformConfig.VerticalResolution   = GopMode->Y;
+
+  Status = PlatformConfigSave (&PlatformConfig);
+  return Status;
+}
+
+
+/**
+  This function is called by the HII machinery when it wants the driver to
+  interpret and persist the form state.
+
+  See the precise documentation in the UEFI spec.
+
+  @param[in]  This           The Config Access Protocol instance.
+
+  @param[in]  Configuration  A <ConfigResp> format UCS-2 string describing the
+                             form state.
+
+  @param[out] Progress       A pointer into Configuration on output,
+                             identifying the element where processing failed.
+
+  @retval EFI_SUCCESS  Configuration verified, state permanent.
+
+  @return              Status codes from underlying functions.
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+RouteConfig (
+  IN CONST  EFI_HII_CONFIG_ACCESS_PROTOCOL  *This,
+  IN CONST  EFI_STRING                      Configuration,
+  OUT       EFI_STRING                      *Progress
+)
+{
+  MAIN_FORM_STATE MainFormState;
+  UINTN           BlockSize;
+  EFI_STATUS      Status;
+
+  DEBUG ((DEBUG_VERBOSE, "%a: Configuration=\"%s\"\n", __FUNCTION__,
+    Configuration));
+
+  //
+  // the "read" step in RMW
+  //
+  Status = PlatformConfigToFormState (&MainFormState);
+  if (EFI_ERROR (Status)) {
+    *Progress = Configuration;
+    return Status;
+  }
+
+  //
+  // the "modify" step in RMW
+  //
+  // (Update the binary form state. This update may be partial, which is why in
+  // general we must pre-load the form state from the platform config.)
+  //
+  BlockSize = sizeof MainFormState;
+  Status = gHiiConfigRouting->ConfigToBlock (gHiiConfigRouting, Configuration,
+                                (VOID *) &MainFormState, &BlockSize, Progress);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "%a: ConfigToBlock(): %r, Progress=\"%s\"\n",
+      __FUNCTION__, Status,
+      (Status == EFI_BUFFER_TOO_SMALL) ? NULL : *Progress));
+    return Status;
+  }
+
+  //
+  // the "write" step in RMW
+  //
+  Status = FormStateToPlatformConfig (&MainFormState);
+  if (EFI_ERROR (Status)) {
+    *Progress = Configuration;
+  }
+  return Status;
+}
+
+
+STATIC
+EFI_STATUS
+EFIAPI
+Callback (
+  IN     CONST EFI_HII_CONFIG_ACCESS_PROTOCOL   *This,
+  IN     EFI_BROWSER_ACTION                     Action,
+  IN     EFI_QUESTION_ID                        QuestionId,
+  IN     UINT8                                  Type,
+  IN OUT EFI_IFR_TYPE_VALUE                     *Value,
+  OUT    EFI_BROWSER_ACTION_REQUEST             *ActionRequest
+  )
+{
+  DEBUG ((DEBUG_VERBOSE, "%a: Action=0x%Lx QuestionId=%d Type=%d\n",
+    __FUNCTION__, (UINT64) Action, QuestionId, Type));
+
+  if (Action != EFI_BROWSER_ACTION_CHANGED) {
+    return EFI_UNSUPPORTED;
+  }
+
+  switch (QuestionId) {
+  case QUESTION_SAVE_EXIT:
+    *ActionRequest = EFI_BROWSER_ACTION_REQUEST_FORM_SUBMIT_EXIT;
+    break;
+
+  case QUESTION_DISCARD_EXIT:
+    *ActionRequest = EFI_BROWSER_ACTION_REQUEST_FORM_DISCARD_EXIT;
+    break;
+
+  default:
+    break;
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Query and save all resolutions supported by the GOP.
+
+  @param[in]  Gop          The Graphics Output Protocol instance to query.
+
+  @param[out] NumGopModes  The number of modes supported by the GOP. On output,
+                           this parameter will be positive.
+
+  @param[out] GopModes     On output, a dynamically allocated array containing
+                           the resolutions returned by the GOP. The caller is
+                           responsible for freeing the array after use.
+
+  @retval EFI_UNSUPPORTED       No modes found.
+  @retval EFI_OUT_OF_RESOURCES  Failed to allocate GopModes.
+  @return                       Error codes from Gop->QueryMode().
+
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+QueryGopModes (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL *Gop,
+  OUT UINTN                        *NumGopModes,
+  OUT GOP_MODE                     **GopModes
+  )
+{
+  EFI_STATUS Status;
+  UINT32     ModeNumber;
+
+  if (Gop->Mode->MaxMode == 0) {
+    return EFI_UNSUPPORTED;
+  }
+  *NumGopModes = Gop->Mode->MaxMode;
+
+  *GopModes = AllocatePool (Gop->Mode->MaxMode * sizeof **GopModes);
+  if (*GopModes == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  for (ModeNumber = 0; ModeNumber < Gop->Mode->MaxMode; ++ModeNumber) {
+    EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *Info;
+    UINTN                                SizeOfInfo;
+
+    Status = Gop->QueryMode (Gop, ModeNumber, &SizeOfInfo, &Info);
+    if (EFI_ERROR (Status)) {
+      goto FreeGopModes;
+    }
+
+    (*GopModes)[ModeNumber].X = Info->HorizontalResolution;
+    (*GopModes)[ModeNumber].Y = Info->VerticalResolution;
+    FreePool (Info);
+  }
+
+  return EFI_SUCCESS;
+
+FreeGopModes:
+  FreePool (*GopModes);
+
+  return Status;
+}
+
+
+/**
+  Create a set of "one-of-many" (ie. "drop down list") option IFR opcodes,
+  based on available GOP resolutions, to be placed under a "one-of-many" (ie.
+  "drop down list") opcode.
+
+  @param[in]  PackageList   The package list with the formset and form for
+                            which the drop down options are produced. Option
+                            names are added as new strings to PackageList.
+
+  @param[out] OpCodeBuffer  On output, a dynamically allocated opcode buffer
+                            with drop down list options corresponding to GOP
+                            resolutions. The caller is responsible for freeing
+                            OpCodeBuffer with HiiFreeOpCodeHandle() after use.
+
+  @param[in]  NumGopModes   Number of entries in GopModes.
+
+  @param[in]  GopModes      Array of resolutions retrieved from the GOP.
+
+  @retval EFI_SUCESS  Opcodes have been successfully produced.
+
+  @return             Status codes from underlying functions. PackageList may
+                      have been extended with new strings. OpCodeBuffer is
+                      unchanged.
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+CreateResolutionOptions (
+  IN  EFI_HII_HANDLE  PackageList,
+  OUT VOID            **OpCodeBuffer,
+  IN  UINTN           NumGopModes,
+  IN  GOP_MODE        *GopModes
+  )
+{
+  EFI_STATUS Status;
+  VOID       *OutputBuffer;
+  UINTN      ModeNumber;
+
+  OutputBuffer = HiiAllocateOpCodeHandle ();
+  if (OutputBuffer == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  for (ModeNumber = 0; ModeNumber < NumGopModes; ++ModeNumber) {
+    CHAR16        Desc[MAXSIZE_RES_CUR];
+    EFI_STRING_ID NewString;
+    VOID          *OpCode;
+
+    UnicodeSPrintAsciiFormat (Desc, sizeof Desc, "%Ldx%Ld",
+      (INT64) GopModes[ModeNumber].X, (INT64) GopModes[ModeNumber].Y);
+    NewString = HiiSetString (PackageList, 0 /* new string */, Desc,
+                  NULL /* for all languages */);
+    if (NewString == 0) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto FreeOutputBuffer;
+    }
+    OpCode = HiiCreateOneOfOptionOpCode (OutputBuffer, NewString,
+               0 /* Flags */, EFI_IFR_NUMERIC_SIZE_4, ModeNumber);
+    if (OpCode == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto FreeOutputBuffer;
+    }
+  }
+
+  *OpCodeBuffer = OutputBuffer;
+  return EFI_SUCCESS;
+
+FreeOutputBuffer:
+  HiiFreeOpCodeHandle (OutputBuffer);
+
+  return Status;
+}
+
+
+/**
+  Populate the form identified by the (PackageList, FormSetGuid, FormId)
+  triplet.
+
+  The drop down list of video resolutions is generated from (NumGopModes,
+  GopModes).
+
+  @retval EFI_SUCESS  Form successfully updated.
+  @return             Status codes from underlying functions.
+
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+PopulateForm (
+  IN  EFI_HII_HANDLE  PackageList,
+  IN  EFI_GUID        *FormSetGuid,
+  IN  EFI_FORM_ID     FormId,
+  IN  UINTN           NumGopModes,
+  IN  GOP_MODE        *GopModes
+  )
+{
+  EFI_STATUS         Status;
+  VOID               *OpCodeBuffer;
+  VOID               *OpCode;
+  EFI_IFR_GUID_LABEL *Anchor;
+  VOID               *OpCodeBuffer2;
+
+  OpCodeBuffer2 = NULL;
+
+  //
+  // 1. Allocate an empty opcode buffer.
+  //
+  OpCodeBuffer = HiiAllocateOpCodeHandle ();
+  if (OpCodeBuffer == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  //
+  // 2. Create a label opcode (which is a Tiano extension) inside the buffer.
+  // The label's number must match the "anchor" label in the form.
+  //
+  OpCode = HiiCreateGuidOpCode (OpCodeBuffer, &gEfiIfrTianoGuid,
+             NULL /* optional copy origin */, sizeof *Anchor);
+  if (OpCode == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto FreeOpCodeBuffer;
+  }
+  Anchor               = OpCode;
+  Anchor->ExtendOpCode = EFI_IFR_EXTEND_OP_LABEL;
+  Anchor->Number       = LABEL_RES_NEXT;
+
+  //
+  // 3. Create the opcodes inside the buffer that are to be inserted into the
+  // form.
+  //
+  // 3.1. Get a list of resolutions.
+  //
+  Status = CreateResolutionOptions (PackageList, &OpCodeBuffer2,
+             NumGopModes, GopModes);
+  if (EFI_ERROR (Status)) {
+    goto FreeOpCodeBuffer;
+  }
+
+  //
+  // 3.2. Create a one-of-many question with the above options.
+  //
+  OpCode = HiiCreateOneOfOpCode (
+             OpCodeBuffer,                        // create opcode inside this
+                                                  //   opcode buffer,
+             QUESTION_RES_NEXT,                   // ID of question,
+             FORMSTATEID_MAIN_FORM,               // identifies form state
+                                                  //   storage,
+             (UINT16) OFFSET_OF (MAIN_FORM_STATE, // value of question stored
+                        NextPreferredResolution), //   at this offset,
+             STRING_TOKEN (STR_RES_NEXT),         // Prompt,
+             STRING_TOKEN (STR_RES_NEXT_HELP),    // Help,
+             0,                                   // QuestionFlags,
+             EFI_IFR_NUMERIC_SIZE_4,              // see sizeof
+                                                  //   NextPreferredResolution,
+             OpCodeBuffer2,                       // buffer with possible
+                                                  //   choices,
+             NULL                                 // DEFAULT opcodes
+             );
+  if (OpCode == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto FreeOpCodeBuffer2;
+  }
+
+  //
+  // 4. Update the form with the opcode buffer.
+  //
+  Status = HiiUpdateForm (PackageList, FormSetGuid, FormId,
+             OpCodeBuffer, // buffer with head anchor, and new contents to be
+                           // inserted at it
+             NULL          // buffer with tail anchor, for deleting old
+                           // contents up to it
+             );
+
+FreeOpCodeBuffer2:
+  HiiFreeOpCodeHandle (OpCodeBuffer2);
+
+FreeOpCodeBuffer:
+  HiiFreeOpCodeHandle (OpCodeBuffer);
+
+  return Status;
+}
+
+
+/**
+  Load and execute the platform configuration.
+
+  @retval EFI_SUCCESS            Configuration loaded and executed.
+  @return                        Status codes from PlatformConfigLoad().
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+ExecutePlatformConfig (
+  VOID
+  )
+{
+  EFI_STATUS      Status;
+  PLATFORM_CONFIG PlatformConfig;
+  UINT64          OptionalElements;
+  RETURN_STATUS   PcdStatus;
+
+  Status = PlatformConfigLoad (&PlatformConfig, &OptionalElements);
+  if (EFI_ERROR (Status)) {
+    DEBUG (((Status == EFI_NOT_FOUND) ? DEBUG_VERBOSE : DEBUG_ERROR,
+      "%a: failed to load platform config: %r\n", __FUNCTION__, Status));
+    return Status;
+  }
+
+  if (OptionalElements & PLATFORM_CONFIG_F_GRAPHICS_RESOLUTION) {
+    //
+    // Pass the preferred resolution to GraphicsConsoleDxe via dynamic PCDs.
+    //
+    PcdStatus = PcdSet32S (PcdVideoHorizontalResolution,
+      PlatformConfig.HorizontalResolution);
+    ASSERT_RETURN_ERROR (PcdStatus);
+
+    PcdStatus = PcdSet32S (PcdVideoVerticalResolution,
+      PlatformConfig.VerticalResolution);
+    ASSERT_RETURN_ERROR (PcdStatus);
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Notification callback for GOP interface installation.
+
+  @param[in] Event    Event whose notification function is being invoked.
+
+  @param[in] Context  The pointer to the notification function's context, which
+                      is implementation-dependent.
+**/
+STATIC
+VOID
+EFIAPI
+GopInstalled (
+  IN EFI_EVENT Event,
+  IN VOID      *Context
+  )
+{
+  EFI_STATUS                   Status;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL *Gop;
+
+  ASSERT (Event == mGopEvent);
+
+  //
+  // Check further GOPs.
+  //
+  for (;;) {
+    mNumGopModes = 0;
+    mGopModes = NULL;
+
+    Status = gBS->LocateProtocol (&gEfiGraphicsOutputProtocolGuid, mGopTracker,
+                    (VOID **) &Gop);
+    if (EFI_ERROR (Status)) {
+      return;
+    }
+
+    Status = QueryGopModes (Gop, &mNumGopModes, &mGopModes);
+    if (EFI_ERROR (Status)) {
+      continue;
+    }
+
+    Status = PopulateForm (mInstalledPackages, &gOvmfPlatformConfigGuid,
+               FORMID_MAIN_FORM, mNumGopModes, mGopModes);
+    if (EFI_ERROR (Status)) {
+      FreePool (mGopModes);
+      continue;
+    }
+
+    break;
+  }
+
+  //
+  // Success -- so uninstall this callback. Closing the event removes all
+  // pending notifications and all protocol registrations.
+  //
+  Status = gBS->CloseEvent (mGopEvent);
+  ASSERT_EFI_ERROR (Status);
+  mGopEvent = NULL;
+  mGopTracker = NULL;
+}
+
+
+/**
+  Entry point for this driver.
+
+  @param[in] ImageHandle  Image handle of this driver.
+  @param[in] SystemTable  Pointer to SystemTable.
+
+  @retval EFI_SUCESS            Driver has loaded successfully.
+  @retval EFI_OUT_OF_RESOURCES  Failed to install HII packages.
+  @return                       Error codes from lower level functions.
+
+**/
+EFI_STATUS
+EFIAPI
+PlatformInit (
+  IN  EFI_HANDLE        ImageHandle,
+  IN  EFI_SYSTEM_TABLE  *SystemTable
+  )
+{
+  EFI_STATUS Status;
+
+  ExecutePlatformConfig ();
+
+  mConfigAccess.ExtractConfig = &ExtractConfig;
+  mConfigAccess.RouteConfig   = &RouteConfig;
+  mConfigAccess.Callback      = &Callback;
+
+  //
+  // Declare ourselves suitable for HII communication.
+  //
+  Status = gBS->InstallMultipleProtocolInterfaces (&ImageHandle,
+                  &gEfiDevicePathProtocolGuid,      &mPkgDevicePath,
+                  &gEfiHiiConfigAccessProtocolGuid, &mConfigAccess,
+                  NULL);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Publish the HII package list to HII Database.
+  //
+  mInstalledPackages = HiiAddPackages (
+                         &gEfiCallerIdGuid,  // PackageListGuid
+                         ImageHandle,        // associated DeviceHandle
+                         PlatformDxeStrings, // 1st package
+                         PlatformFormsBin,   // 2nd package
+                         NULL                // terminator
+                         );
+  if (mInstalledPackages == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto UninstallProtocols;
+  }
+
+  Status = gBS->CreateEvent (EVT_NOTIFY_SIGNAL, TPL_CALLBACK, &GopInstalled,
+                  NULL /* Context */, &mGopEvent);
+  if (EFI_ERROR (Status)) {
+    goto RemovePackages;
+  }
+
+  Status = gBS->RegisterProtocolNotify (&gEfiGraphicsOutputProtocolGuid,
+                  mGopEvent, &mGopTracker);
+  if (EFI_ERROR (Status)) {
+    goto CloseGopEvent;
+  }
+
+  //
+  // Check already installed GOPs.
+  //
+  Status = gBS->SignalEvent (mGopEvent);
+  ASSERT_EFI_ERROR (Status);
+
+  return EFI_SUCCESS;
+
+CloseGopEvent:
+  gBS->CloseEvent (mGopEvent);
+
+RemovePackages:
+  HiiRemovePackages (mInstalledPackages);
+
+UninstallProtocols:
+  gBS->UninstallMultipleProtocolInterfaces (ImageHandle,
+         &gEfiDevicePathProtocolGuid,      &mPkgDevicePath,
+         &gEfiHiiConfigAccessProtocolGuid, &mConfigAccess,
+         NULL);
+  return Status;
+}
+
+/**
+  Unload the driver.
+
+  @param[in]  ImageHandle  Handle that identifies the image to evict.
+
+  @retval EFI_SUCCESS  The image has been unloaded.
+**/
+EFI_STATUS
+EFIAPI
+PlatformUnload (
+  IN  EFI_HANDLE  ImageHandle
+  )
+{
+  if (mGopEvent == NULL) {
+    //
+    // The GOP callback ran successfully and unregistered itself. Release the
+    // resources allocated there.
+    //
+    ASSERT (mGopModes != NULL);
+    FreePool (mGopModes);
+  } else {
+    //
+    // Otherwise we need to unregister the callback.
+    //
+    ASSERT (mGopModes == NULL);
+    gBS->CloseEvent (mGopEvent);
+  }
+
+  //
+  // Release resources allocated by the entry point.
+  //
+  HiiRemovePackages (mInstalledPackages);
+  gBS->UninstallMultipleProtocolInterfaces (ImageHandle,
+         &gEfiDevicePathProtocolGuid,      &mPkgDevicePath,
+         &gEfiHiiConfigAccessProtocolGuid, &mConfigAccess,
+         NULL);
+  return EFI_SUCCESS;
+}
diff --git a/TestPkg/PlatformDxe/Platform.h b/TestPkg/PlatformDxe/Platform.h
new file mode 100644
index 0000000000..dbc1aa26c6
--- /dev/null
+++ b/TestPkg/PlatformDxe/Platform.h
@@ -0,0 +1,37 @@
+/** @file
+  This driver effectuates OVMF's platform configuration settings and exposes
+  them via HII.
+
+  Copyright (C) 2014, Red Hat, Inc.
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _PLATFORM_H_
+#define _PLATFORM_H_
+
+//
+// Macro and type definitions that connect the form with the HII driver code.
+//
+#define FORMSTATEID_MAIN_FORM  1
+#define FORMID_MAIN_FORM       1
+
+#define QUESTION_RES_CUR       1
+#define MAXSIZE_RES_CUR       16
+
+#define LABEL_RES_NEXT         1
+#define QUESTION_RES_NEXT      2
+
+#define QUESTION_SAVE_EXIT     3
+#define QUESTION_DISCARD_EXIT  4
+
+//
+// This structure describes the form state. Its fields relate strictly to the
+// visual widgets on the form.
+//
+typedef struct {
+  UINT16 CurrentPreferredResolution[MAXSIZE_RES_CUR];
+  UINT32 NextPreferredResolution;
+} MAIN_FORM_STATE;
+
+#endif // _PLATFORM_H_
diff --git a/TestPkg/PlatformDxe/Platform.inf b/TestPkg/PlatformDxe/Platform.inf
new file mode 100644
index 0000000000..c1776282fa
--- /dev/null
+++ b/TestPkg/PlatformDxe/Platform.inf
@@ -0,0 +1,64 @@
+## @file
+#  This driver effectuates OVMF's platform configuration settings and exposes
+#  them via HII.
+#
+#  Copyright (C) 2014, Red Hat, Inc.
+#  Copyright (c) 2009 - 2010, Intel Corporation. All rights reserved.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformDxe
+  FILE_GUID                      = D9DCC5DF-4007-435E-9098-8970935504B2
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = PlatformInit
+  UNLOAD_IMAGE                   = PlatformUnload
+
+[Sources]
+  Platform.c
+  Platform.h
+  Platform.uni
+  PlatformConfig.c
+  PlatformConfig.h
+  PlatformForms.vfr
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  BaseMemoryLib
+  DebugLib
+  DevicePathLib
+  HiiLib
+  MemoryAllocationLib
+  PrintLib
+  UefiBootServicesTableLib
+  UefiHiiServicesLib
+  UefiLib
+  UefiRuntimeServicesTableLib
+  UefiDriverEntryPoint
+
+[Pcd]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVideoHorizontalResolution
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVideoVerticalResolution
+
+[Protocols]
+  gEfiDevicePathProtocolGuid      ## PRODUCES
+  gEfiGraphicsOutputProtocolGuid  ## CONSUMES
+  gEfiHiiConfigAccessProtocolGuid ## PRODUCES
+
+[Guids]
+  gEfiIfrTianoGuid
+  gOvmfPlatformConfigGuid
+
+[Depex]
+  gEfiHiiConfigRoutingProtocolGuid  AND
+  gEfiHiiDatabaseProtocolGuid       AND
+  gEfiVariableArchProtocolGuid      AND
+  gEfiVariableWriteArchProtocolGuid
diff --git a/TestPkg/PlatformDxe/Platform.uni b/TestPkg/PlatformDxe/Platform.uni
new file mode 100644
index 0000000000..2d4336ba95
--- /dev/null
+++ b/TestPkg/PlatformDxe/Platform.uni
@@ -0,0 +1,28 @@
+// *++
+//
+// Copyright (C) 2014, Red Hat, Inc.
+// Copyright (c) 2009, Intel Corporation. All rights reserved.<BR>
+//
+// SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+// Module Name:
+//
+//   Platform.uni
+//
+// Abstract:
+//
+//   String definitions for PlatformForms.vfr
+//
+// --*/
+
+/=#
+
+#langdef en-US "English"
+#include "JustATest.uni"
+
+#string STR_RES_CUR_HELP         #language en-US "The preferred resolution of the Graphics Console at next boot. It might be unset, or even invalid (hence ignored) wrt. the video RAM size."
+#string STR_RES_NEXT             #language en-US "Change Preferred Resolution for Next Boot"
+#string STR_RES_NEXT_HELP        #language en-US "You can specify a new preference for the Graphics Console here. The list is filtered against the video RAM size."
+#string STR_SAVE_EXIT            #language en-US "Commit Changes and Exit"
+#string STR_DISCARD_EXIT         #language en-US "Discard Changes and Exit"
+
diff --git a/TestPkg/PlatformDxe/PlatformConfig.c b/TestPkg/PlatformDxe/PlatformConfig.c
new file mode 100644
index 0000000000..fd518023b4
--- /dev/null
+++ b/TestPkg/PlatformDxe/PlatformConfig.c
@@ -0,0 +1,125 @@
+/** @file
+
+  Utility functions for serializing (persistently storing) and deserializing
+  OVMF's platform configuration.
+
+  Copyright (C) 2014, Red Hat, Inc.
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <Library/BaseMemoryLib.h>
+#include <Library/DebugLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/UefiLib.h>
+#include <Library/UefiRuntimeServicesTableLib.h>
+#include <Guid/OvmfPlatformConfig.h>
+
+#include "PlatformConfig.h"
+
+//
+// Name of the UEFI variable that we use for persistent storage.
+//
+STATIC CHAR16 mVariableName[] = L"PlatformConfig";
+
+
+/**
+  Serialize and persistently save platform configuration.
+
+  @param[in] PlatformConfig  The platform configuration to serialize and save.
+
+  @return  Status codes returned by gRT->SetVariable().
+**/
+EFI_STATUS
+EFIAPI
+PlatformConfigSave (
+  IN PLATFORM_CONFIG *PlatformConfig
+  )
+{
+  EFI_STATUS Status;
+
+  //
+  // We could implement any kind of translation here, as part of serialization.
+  // For example, we could expose the platform configuration in separate
+  // variables with human-readable contents, allowing other tools to access
+  // them more easily. For now, just save a binary dump.
+  //
+  Status = gRT->SetVariable (mVariableName, &gOvmfPlatformConfigGuid,
+                  EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS |
+                    EFI_VARIABLE_RUNTIME_ACCESS,
+                  sizeof *PlatformConfig, PlatformConfig);
+  return Status;
+}
+
+
+/**
+  Load and deserialize platform configuration.
+
+  When the function fails, output parameters are indeterminate.
+
+  @param[out] PlatformConfig    The platform configuration to receive the
+                                loaded data.
+
+  @param[out] OptionalElements  This bitmap describes the presence of optional
+                                configuration elements that have been loaded.
+                                PLATFORM_CONFIG_F_DOWNGRADE means that some
+                                unknown elements, present in the wire format,
+                                have been ignored.
+
+  @retval  EFI_SUCCESS         Loading & deserialization successful.
+  @return                      Error codes returned by GetVariable2().
+**/
+EFI_STATUS
+EFIAPI
+PlatformConfigLoad (
+  OUT PLATFORM_CONFIG *PlatformConfig,
+  OUT UINT64          *OptionalElements
+  )
+{
+  VOID       *Data;
+  UINTN      DataSize;
+  EFI_STATUS Status;
+
+  //
+  // Any translation done in PlatformConfigSave() would have to be mirrored
+  // here. For now, just load the binary dump.
+  //
+  // Versioning of the binary wire format is implemented based on size
+  // (only incremental changes, ie. new fields), and on GUID.
+  // (Incompatible changes require a GUID change.)
+  //
+  Status = GetVariable2 (mVariableName, &gOvmfPlatformConfigGuid, &Data,
+             &DataSize);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  *OptionalElements = 0;
+  if (DataSize > sizeof *PlatformConfig) {
+    //
+    // Handle firmware downgrade -- keep only leading part.
+    //
+    CopyMem (PlatformConfig, Data, sizeof *PlatformConfig);
+    *OptionalElements |= PLATFORM_CONFIG_F_DOWNGRADE;
+  } else {
+    CopyMem (PlatformConfig, Data, DataSize);
+
+    //
+    // Handle firmware upgrade -- zero out missing fields.
+    //
+    ZeroMem ((UINT8 *)PlatformConfig + DataSize,
+      sizeof *PlatformConfig - DataSize);
+  }
+
+  //
+  // Based on DataSize, report the optional features that we recognize.
+  //
+  if (DataSize >= (OFFSET_OF (PLATFORM_CONFIG, VerticalResolution) +
+                   sizeof PlatformConfig->VerticalResolution)) {
+    *OptionalElements |= PLATFORM_CONFIG_F_GRAPHICS_RESOLUTION;
+  }
+
+  FreePool (Data);
+  return EFI_SUCCESS;
+}
diff --git a/TestPkg/PlatformDxe/PlatformConfig.h b/TestPkg/PlatformDxe/PlatformConfig.h
new file mode 100644
index 0000000000..3ffdf6648b
--- /dev/null
+++ b/TestPkg/PlatformDxe/PlatformConfig.h
@@ -0,0 +1,53 @@
+/** @file
+
+  Utility functions for serializing (persistently storing) and deserializing
+  OVMF's platform configuration.
+
+  Copyright (C) 2014, Red Hat, Inc.
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _PLATFORM_CONFIG_H_
+#define _PLATFORM_CONFIG_H_
+
+#include <Base.h>
+
+//
+// This structure participates in driver configuration. It does not
+// (necessarily) reflect the wire format in the persistent store.
+//
+#pragma pack(1)
+typedef struct {
+  //
+  // preferred graphics console resolution when booting
+  //
+  UINT32 HorizontalResolution;
+  UINT32 VerticalResolution;
+} PLATFORM_CONFIG;
+#pragma pack()
+
+//
+// Please see the API documentation near the function definitions.
+//
+EFI_STATUS
+EFIAPI
+PlatformConfigSave (
+  IN PLATFORM_CONFIG *PlatformConfig
+  );
+
+EFI_STATUS
+EFIAPI
+PlatformConfigLoad (
+  OUT PLATFORM_CONFIG *PlatformConfig,
+  OUT UINT64          *OptionalElements
+  );
+
+//
+// Feature flags for OptionalElements.
+//
+#define PLATFORM_CONFIG_F_GRAPHICS_RESOLUTION BIT0
+#define PLATFORM_CONFIG_F_DOWNGRADE           BIT63
+
+#endif // _PLATFORM_CONFIG_H_
diff --git a/TestPkg/PlatformDxe/PlatformForms.vfr b/TestPkg/PlatformDxe/PlatformForms.vfr
new file mode 100644
index 0000000000..c1df9aa269
--- /dev/null
+++ b/TestPkg/PlatformDxe/PlatformForms.vfr
@@ -0,0 +1,67 @@
+// *++
+//
+// Copyright (C) 2014, Red Hat, Inc.
+// Copyright (c) 2009 - 2011, Intel Corporation. All rights reserved.<BR>
+//
+// SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+// Module Name:
+//
+//   PlatformForms.vfr
+//
+// Abstract:
+//
+//   Form definitions for exposing some of OVMF's platform knobs via HII.
+//
+// --*/
+
+#include <Guid/OvmfPlatformConfig.h>
+#include "Platform.h"
+
+formset
+  guid  = OVMF_PLATFORM_CONFIG_GUID,
+  title = STRING_TOKEN(STR_FORMSET_TITLE),
+  help  = STRING_TOKEN(STR_FORMSET_HELP),
+
+  varstore MAIN_FORM_STATE,
+    varid = FORMSTATEID_MAIN_FORM,
+    name  = MainFormState,
+    guid  = OVMF_PLATFORM_CONFIG_GUID;
+
+  form
+    formid = FORMID_MAIN_FORM,
+    title  = STRING_TOKEN(STR_MAIN_FORM_TITLE);
+
+    //
+    // Display the current preference in a read-only string field.
+    //
+    string
+      varid      = MainFormState.CurrentPreferredResolution,
+      questionid = QUESTION_RES_CUR,
+      prompt     = STRING_TOKEN(STR_RES_CUR),
+      help       = STRING_TOKEN(STR_RES_CUR_HELP),
+      flags      = READ_ONLY,
+      minsize    = 0,
+      maxsize    = MAXSIZE_RES_CUR,
+    endstring;
+
+    //
+    // We'll dynamically generate a one-of-many selection at this label.
+    //
+    label LABEL_RES_NEXT;
+
+    text
+      help  = STRING_TOKEN(STR_SAVE_EXIT),
+      text  = STRING_TOKEN(STR_SAVE_EXIT),
+      flags = INTERACTIVE,
+      key   = QUESTION_SAVE_EXIT;
+
+    text
+      help  = STRING_TOKEN(STR_DISCARD_EXIT),
+      text  = STRING_TOKEN(STR_DISCARD_EXIT),
+      flags = INTERACTIVE,
+      key   = QUESTION_DISCARD_EXIT;
+
+  endform;
+
+endformset;
diff --git a/TestPkg/PlatformDxe/SecondTestFile.h b/TestPkg/PlatformDxe/SecondTestFile.h
new file mode 100644
index 0000000000..9f4a47b688
--- /dev/null
+++ b/TestPkg/PlatformDxe/SecondTestFile.h
@@ -0,0 +1,9 @@
+/** @file
+Head file for front page.
+
+Copyright (c) 2004 - 2016, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define front_page_guid 0x9e0c30ab
\ No newline at end of file
diff --git a/TestPkg/PlatformDxe/ThirdTestFile.uni b/TestPkg/PlatformDxe/ThirdTestFile.uni
new file mode 100644
index 0000000000000000000000000000000000000000..dc37c295b4aa4118d4b9f60be9da2a4a28fda6c0
GIT binary patch
literal 950
zcmb`FTT22_6ouDw(0>^0r6jc^dWeWp3xqQ90=<cN83mnU9Hahx_3d+<v1pJUVwgE+
z_GPWL*Et`bs<@}9q5@rOs<{@LXkU9So~{Aet`f!MBZd5psj}*bH{pF|w<11e7qix=
zSg8%#ki3sBv;30Wgm^iZsSd`A-W^-08FhgUHPR7lRVO@W>`I%zQ=RLWeG>%<s0;Rn
z5QAY~<M;Z?WNye?g-znIO?6D4DT?*VcZ{w}Cg|uY)8`#%tDz^D@97><X){mwZ#qAW
zf9_l{qziCsxYi(F<*hp})|-yD(`5)r#*w;hr%`cHiyXK<bKQGxN&?4SQXl+41>M0n
zRP;6nz2G|YyQb8YsP4F~Ti8R;t!uWk&vbfTW3!t88+wM|jmi8S$rS8D`aOyFU<K#)
z_I1@`h5?>Fs>Qy^w~vYeH?BkMfwh<Mq<rbR^=8ckAzuFU(`K|A<j*tGnhNh~its;c
No{sM)l&2$B;R^uKhz9@w

literal 0
HcmV?d00001

diff --git a/TestPkg/README b/TestPkg/README
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/TestPkg/ResetVector/Ia32/PageTables64.asm b/TestPkg/ResetVector/Ia32/PageTables64.asm
new file mode 100644
index 0000000000..67c4404ed7
--- /dev/null
+++ b/TestPkg/ResetVector/Ia32/PageTables64.asm
@@ -0,0 +1,148 @@
+;------------------------------------------------------------------------------
+; @file
+; Sets the CR3 register for 64-bit paging
+;
+; Copyright (c) 2008 - 2013, Intel Corporation. All rights reserved.<BR>
+; SPDX-License-Identifier: BSD-2-Clause-Patent
+;
+;------------------------------------------------------------------------------
+
+BITS    32
+
+%define PAGE_PRESENT            0x01
+%define PAGE_READ_WRITE         0x02
+%define PAGE_USER_SUPERVISOR    0x04
+%define PAGE_WRITE_THROUGH      0x08
+%define PAGE_CACHE_DISABLE     0x010
+%define PAGE_ACCESSED          0x020
+%define PAGE_DIRTY             0x040
+%define PAGE_PAT               0x080
+%define PAGE_GLOBAL           0x0100
+%define PAGE_2M_MBO            0x080
+%define PAGE_2M_PAT          0x01000
+
+%define PAGE_2M_PDE_ATTR (PAGE_2M_MBO + \
+                          PAGE_ACCESSED + \
+                          PAGE_DIRTY + \
+                          PAGE_READ_WRITE + \
+                          PAGE_PRESENT)
+
+%define PAGE_PDP_ATTR (PAGE_ACCESSED + \
+                       PAGE_READ_WRITE + \
+                       PAGE_PRESENT)
+
+; Check if Secure Encrypted Virtualization (SEV) feature is enabled
+;
+; If SEV is enabled then EAX will be at least 32
+; If SEV is disabled then EAX will be zero.
+;
+CheckSevFeature:
+    ; Check if we have a valid (0x8000_001F) CPUID leaf
+    mov       eax, 0x80000000
+    cpuid
+
+    ; This check should fail on Intel or Non SEV AMD CPUs. In future if
+    ; Intel CPUs supports this CPUID leaf then we are guranteed to have exact
+    ; same bit definition.
+    cmp       eax, 0x8000001f
+    jl        NoSev
+
+    ; Check for memory encryption feature:
+    ;  CPUID  Fn8000_001F[EAX] - Bit 1
+    ;
+    mov       eax,  0x8000001f
+    cpuid
+    bt        eax, 1
+    jnc       NoSev
+
+    ; Check if memory encryption is enabled
+    ;  MSR_0xC0010131 - Bit 0 (SEV enabled)
+    mov       ecx, 0xc0010131
+    rdmsr
+    bt        eax, 0
+    jnc       NoSev
+
+    ; Get pte bit position to enable memory encryption
+    ; CPUID Fn8000_001F[EBX] - Bits 5:0
+    ;
+    mov       eax, ebx
+    and       eax, 0x3f
+    jmp       SevExit
+
+NoSev:
+    xor       eax, eax
+
+SevExit:
+    OneTimeCallRet CheckSevFeature
+
+;
+; Modified:  EAX, EBX, ECX, EDX
+;
+SetCr3ForPageTables64:
+
+    OneTimeCall   CheckSevFeature
+    xor     edx, edx
+    test    eax, eax
+    jz      SevNotActive
+
+    ; If SEV is enabled, C-bit is always above 31
+    sub     eax, 32
+    bts     edx, eax
+
+SevNotActive:
+
+    ;
+    ; For OVMF, build some initial page tables at
+    ; PcdOvmfSecPageTablesBase - (PcdOvmfSecPageTablesBase + 0x6000).
+    ;
+    ; This range should match with PcdOvmfSecPageTablesSize which is
+    ; declared in the FDF files.
+    ;
+    ; At the end of PEI, the pages tables will be rebuilt into a
+    ; more permanent location by DxeIpl.
+    ;
+
+    mov     ecx, 6 * 0x1000 / 4
+    xor     eax, eax
+clearPageTablesMemoryLoop:
+    mov     dword[ecx * 4 + PT_ADDR (0) - 4], eax
+    loop    clearPageTablesMemoryLoop
+
+    ;
+    ; Top level Page Directory Pointers (1 * 512GB entry)
+    ;
+    mov     dword[PT_ADDR (0)], PT_ADDR (0x1000) + PAGE_PDP_ATTR
+    mov     dword[PT_ADDR (4)], edx
+
+    ;
+    ; Next level Page Directory Pointers (4 * 1GB entries => 4GB)
+    ;
+    mov     dword[PT_ADDR (0x1000)], PT_ADDR (0x2000) + PAGE_PDP_ATTR
+    mov     dword[PT_ADDR (0x1004)], edx
+    mov     dword[PT_ADDR (0x1008)], PT_ADDR (0x3000) + PAGE_PDP_ATTR
+    mov     dword[PT_ADDR (0x100C)], edx
+    mov     dword[PT_ADDR (0x1010)], PT_ADDR (0x4000) + PAGE_PDP_ATTR
+    mov     dword[PT_ADDR (0x1014)], edx
+    mov     dword[PT_ADDR (0x1018)], PT_ADDR (0x5000) + PAGE_PDP_ATTR
+    mov     dword[PT_ADDR (0x101C)], edx
+
+    ;
+    ; Page Table Entries (2048 * 2MB entries => 4GB)
+    ;
+    mov     ecx, 0x800
+pageTableEntriesLoop:
+    mov     eax, ecx
+    dec     eax
+    shl     eax, 21
+    add     eax, PAGE_2M_PDE_ATTR
+    mov     [ecx * 8 + PT_ADDR (0x2000 - 8)], eax
+    mov     [(ecx * 8 + PT_ADDR (0x2000 - 8)) + 4], edx
+    loop    pageTableEntriesLoop
+
+    ;
+    ; Set CR3 now that the paging structures are available
+    ;
+    mov     eax, PT_ADDR (0)
+    mov     cr3, eax
+
+    OneTimeCallRet SetCr3ForPageTables64
diff --git a/TestPkg/ResetVector/ResetVector.inf b/TestPkg/ResetVector/ResetVector.inf
new file mode 100644
index 0000000000..7f8562b5ed
--- /dev/null
+++ b/TestPkg/ResetVector/ResetVector.inf
@@ -0,0 +1,37 @@
+## @file
+#  Reset Vector
+#
+#  Copyright (c) 2006 - 2014, Intel Corporation. All rights reserved.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = ResetVector
+  FILE_GUID                      = 1BA0062E-C779-4582-8566-336AE8F78F09
+  MODULE_TYPE                    = SEC
+  VERSION_STRING                 = 1.1
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64
+#
+
+[Sources]
+  ResetVector.nasmb
+
+[Packages]
+  OvmfPkg/OvmfPkg.dec
+  MdePkg/MdePkg.dec
+  UefiCpuPkg/UefiCpuPkg.dec
+
+[BuildOptions]
+   *_*_IA32_NASMB_FLAGS = -I$(WORKSPACE)/UefiCpuPkg/ResetVector/Vtf0/
+   *_*_X64_NASMB_FLAGS = -I$(WORKSPACE)/UefiCpuPkg/ResetVector/Vtf0/
+
+[Pcd]
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPageTablesBase
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPageTablesSize
diff --git a/TestPkg/ResetVector/ResetVector.nasmb b/TestPkg/ResetVector/ResetVector.nasmb
new file mode 100644
index 0000000000..f652226dbf
--- /dev/null
+++ b/TestPkg/ResetVector/ResetVector.nasmb
@@ -0,0 +1,67 @@
+;------------------------------------------------------------------------------
+; @file
+; This file includes all other code files to assemble the reset vector code
+;
+; Copyright (c) 2008 - 2013, Intel Corporation. All rights reserved.<BR>
+; SPDX-License-Identifier: BSD-2-Clause-Patent
+;
+;------------------------------------------------------------------------------
+
+;
+; If neither ARCH_IA32 nor ARCH_X64 are defined, then try to include
+; Base.h to use the C pre-processor to determine the architecture.
+;
+%ifndef ARCH_IA32
+  %ifndef ARCH_X64
+    #include <Base.h>
+    #if defined (MDE_CPU_IA32)
+      %define ARCH_IA32
+    #elif defined (MDE_CPU_X64)
+      %define ARCH_X64
+    #endif
+  %endif
+%endif
+
+%ifdef ARCH_IA32
+  %ifdef ARCH_X64
+    %error "Only one of ARCH_IA32 or ARCH_X64 can be defined."
+  %endif
+%elifdef ARCH_X64
+%else
+  %error "Either ARCH_IA32 or ARCH_X64 must be defined."
+%endif
+
+%include "CommonMacros.inc"
+
+%include "PostCodes.inc"
+
+%ifdef DEBUG_PORT80
+  %include "Port80Debug.asm"
+%elifdef DEBUG_SERIAL
+  %include "SerialDebug.asm"
+%else
+  %include "DebugDisabled.asm"
+%endif
+
+%include "Ia32/SearchForBfvBase.asm"
+%include "Ia32/SearchForSecEntry.asm"
+
+%ifdef ARCH_X64
+  #include <AutoGen.h>
+
+  %if (FixedPcdGet32 (PcdOvmfSecPageTablesSize) != 0x6000)
+    %error "This implementation inherently depends on PcdOvmfSecPageTablesSize"
+  %endif
+
+  %define PT_ADDR(Offset) (FixedPcdGet32 (PcdOvmfSecPageTablesBase) + (Offset))
+%include "Ia32/Flat32ToFlat64.asm"
+%include "Ia32/PageTables64.asm"
+%endif
+
+%include "Ia16/Real16ToFlat32.asm"
+%include "Ia16/Init16.asm"
+
+%include "Main.asm"
+
+%include "Ia16/ResetVectorVtf0.asm"
+
diff --git a/TestPkg/Sec/Ia32/ForHAddTest.h b/TestPkg/Sec/Ia32/ForHAddTest.h
new file mode 100644
index 0000000000..09a1b4931b
--- /dev/null
+++ b/TestPkg/Sec/Ia32/ForHAddTest.h
@@ -0,0 +1,9 @@
+/** @file
+  Exception definitions.
+
+  Copyright (c) 2010, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define NumForTest 4
\ No newline at end of file
diff --git a/TestPkg/Sec/Ia32/ForHAddTest.inc b/TestPkg/Sec/Ia32/ForHAddTest.inc
new file mode 100644
index 0000000000..3fc2a8a56c
--- /dev/null
+++ b/TestPkg/Sec/Ia32/ForHAddTest.inc
@@ -0,0 +1,9 @@
+/** @file
+  Exception definitions.
+
+  Copyright (c) 2010, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+NumForTest equ 4
\ No newline at end of file
diff --git a/TestPkg/Sec/Ia32/ForNASMIncludeH.h b/TestPkg/Sec/Ia32/ForNASMIncludeH.h
new file mode 100644
index 0000000000..2192c54f06
--- /dev/null
+++ b/TestPkg/Sec/Ia32/ForNASMIncludeH.h
@@ -0,0 +1,10 @@
+/** @file
+  Platform specific defines for constructing ACPI tables
+
+  Copyright (c) 2012, 2013, Red Hat, Inc.
+  Copyright (c) 2008, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define divnumber 4
diff --git a/TestPkg/Sec/Ia32/SecEntry.nasm b/TestPkg/Sec/Ia32/SecEntry.nasm
new file mode 100644
index 0000000000..24b1c20ca8
--- /dev/null
+++ b/TestPkg/Sec/Ia32/SecEntry.nasm
@@ -0,0 +1,68 @@
+;------------------------------------------------------------------------------
+;*
+;*   Copyright (c) 2006 - 2013, Intel Corporation. All rights reserved.<BR>
+;*   SPDX-License-Identifier: BSD-2-Clause-Patent
+;*
+;*    CpuAsm.asm
+;*
+;*   Abstract:
+;*
+;------------------------------------------------------------------------------
+
+#include <Base.h>
+
+    SECTION .text
+
+extern ASM_PFX(SecCoreStartupWithStack)
+
+;
+; SecCore Entry Point
+;
+; Processor is in flat protected mode
+;
+; @param[in]  EAX   Initial value of the EAX register (BIST: Built-in Self Test)
+; @param[in]  DI    'BP': boot-strap processor, or 'AP': application processor
+; @param[in]  EBP   Pointer to the start of the Boot Firmware Volume
+; @param[in]  DS    Selector allowing flat access to all addresses
+; @param[in]  ES    Selector allowing flat access to all addresses
+; @param[in]  FS    Selector allowing flat access to all addresses
+; @param[in]  GS    Selector allowing flat access to all addresses
+; @param[in]  SS    Selector allowing flat access to all addresses
+;
+; @return     None  This routine does not return
+;
+global ASM_PFX(_ModuleEntryPoint)
+ASM_PFX(_ModuleEntryPoint):
+
+    ;
+    ; Fill the temporary RAM with the initial stack value.
+    ; The loop below will seed the heap as well, but that's harmless.
+    ;
+    mov     eax, FixedPcdGet32 (PcdInitValueInTempStack)      ; dword to store
+    mov     edi, FixedPcdGet32 (PcdOvmfSecPeiTempRamBase)     ; base address,
+                                                              ;   relative to
+                                                              ;   ES
+    mov     ecx, FixedPcdGet32 (PcdOvmfSecPeiTempRamSize) / 4 ; dword count
+    cld                                                       ; store from base
+                                                              ;   up
+    rep stosd
+
+    ;
+    ; Load temporary RAM stack based on PCDs
+    ;
+    %define SEC_TOP_OF_STACK (FixedPcdGet32 (PcdOvmfSecPeiTempRamBase) + \
+                          FixedPcdGet32 (PcdOvmfSecPeiTempRamSize))
+    mov     eax, SEC_TOP_OF_STACK
+    mov     esp, eax
+    nop
+
+    ;
+    ; Setup parameters and call SecCoreStartupWithStack
+    ;   [esp]   return address for call
+    ;   [esp+4] BootFirmwareVolumePtr
+    ;   [esp+8] TopOfCurrentStack
+    ;
+    push    eax
+    push    ebp
+    call    ASM_PFX(SecCoreStartupWithStack)
+
diff --git a/TestPkg/Sec/SecMain.c b/TestPkg/Sec/SecMain.c
new file mode 100644
index 0000000000..bc88132a56
--- /dev/null
+++ b/TestPkg/Sec/SecMain.c
@@ -0,0 +1,941 @@
+/** @file
+  Main SEC phase code.  Transitions to PEI.
+
+  Copyright (c) 2008 - 2015, Intel Corporation. All rights reserved.<BR>
+  (C) Copyright 2016 Hewlett Packard Enterprise Development LP<BR>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <PiPei.h>
+
+#include <Library/PeimEntryPoint.h>
+#include <Library/BaseLib.h>
+#include <Library/DebugLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/PeiServicesLib.h>
+#include <Library/PcdLib.h>
+#include <Library/UefiCpuLib.h>
+#include <Library/DebugAgentLib.h>
+#include <Library/IoLib.h>
+#include <Library/PeCoffLib.h>
+#include <Library/PeCoffGetEntryPointLib.h>
+#include <Library/PeCoffExtraActionLib.h>
+#include <Library/ExtractGuidedSectionLib.h>
+#include <Library/LocalApicLib.h>
+
+#include <Ppi/TemporaryRamSupport.h>
+
+#define SEC_IDT_ENTRY_COUNT  34
+
+typedef struct _SEC_IDT_TABLE {
+  EFI_PEI_SERVICES          *PeiService;
+  IA32_IDT_GATE_DESCRIPTOR  IdtTable[SEC_IDT_ENTRY_COUNT];
+} SEC_IDT_TABLE;
+
+VOID
+EFIAPI
+SecStartupPhase2 (
+  IN VOID                     *Context
+  );
+
+EFI_STATUS
+EFIAPI
+TemporaryRamMigration (
+  IN CONST EFI_PEI_SERVICES   **PeiServices,
+  IN EFI_PHYSICAL_ADDRESS     TemporaryMemoryBase,
+  IN EFI_PHYSICAL_ADDRESS     PermanentMemoryBase,
+  IN UINTN                    CopySize
+  );
+
+//
+//
+//
+EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI mTemporaryRamSupportPpi = {
+  TemporaryRamMigration
+};
+
+EFI_PEI_PPI_DESCRIPTOR mPrivateDispatchTable[] = {
+  {
+    (EFI_PEI_PPI_DESCRIPTOR_PPI | EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST),
+    &gEfiTemporaryRamSupportPpiGuid,
+    &mTemporaryRamSupportPpi
+  },
+};
+
+//
+// Template of an IDT entry pointing to 10:FFFFFFE4h.
+//
+IA32_IDT_GATE_DESCRIPTOR  mIdtEntryTemplate = {
+  {                                      // Bits
+    0xffe4,                              // OffsetLow
+    0x10,                                // Selector
+    0x0,                                 // Reserved_0
+    IA32_IDT_GATE_TYPE_INTERRUPT_32,     // GateType
+    0xffff                               // OffsetHigh
+  }
+};
+
+/**
+  Locates the main boot firmware volume.
+
+  @param[in,out]  BootFv  On input, the base of the BootFv
+                          On output, the decompressed main firmware volume
+
+  @retval EFI_SUCCESS    The main firmware volume was located and decompressed
+  @retval EFI_NOT_FOUND  The main firmware volume was not found
+
+**/
+EFI_STATUS
+FindMainFv (
+  IN OUT  EFI_FIRMWARE_VOLUME_HEADER   **BootFv
+  )
+{
+  EFI_FIRMWARE_VOLUME_HEADER  *Fv;
+  UINTN                       Distance;
+
+  ASSERT (((UINTN) *BootFv & EFI_PAGE_MASK) == 0);
+
+  Fv = *BootFv;
+  Distance = (UINTN) (*BootFv)->FvLength;
+  do {
+    Fv = (EFI_FIRMWARE_VOLUME_HEADER*) ((UINT8*) Fv - EFI_PAGE_SIZE);
+    Distance += EFI_PAGE_SIZE;
+    if (Distance > SIZE_32MB) {
+      return EFI_NOT_FOUND;
+    }
+
+    if (Fv->Signature != EFI_FVH_SIGNATURE) {
+      continue;
+    }
+
+    if ((UINTN) Fv->FvLength > Distance) {
+      continue;
+    }
+
+    *BootFv = Fv;
+    return EFI_SUCCESS;
+
+  } while (TRUE);
+}
+
+/**
+  Locates a section within a series of sections
+  with the specified section type.
+
+  The Instance parameter indicates which instance of the section
+  type to return. (0 is first instance, 1 is second...)
+
+  @param[in]   Sections        The sections to search
+  @param[in]   SizeOfSections  Total size of all sections
+  @param[in]   SectionType     The section type to locate
+  @param[in]   Instance        The section instance number
+  @param[out]  FoundSection    The FFS section if found
+
+  @retval EFI_SUCCESS           The file and section was found
+  @retval EFI_NOT_FOUND         The file and section was not found
+  @retval EFI_VOLUME_CORRUPTED  The firmware volume was corrupted
+
+**/
+EFI_STATUS
+FindFfsSectionInstance (
+  IN  VOID                             *Sections,
+  IN  UINTN                            SizeOfSections,
+  IN  EFI_SECTION_TYPE                 SectionType,
+  IN  UINTN                            Instance,
+  OUT EFI_COMMON_SECTION_HEADER        **FoundSection
+  )
+{
+  EFI_PHYSICAL_ADDRESS        CurrentAddress;
+  UINT32                      Size;
+  EFI_PHYSICAL_ADDRESS        EndOfSections;
+  EFI_COMMON_SECTION_HEADER   *Section;
+  EFI_PHYSICAL_ADDRESS        EndOfSection;
+
+  //
+  // Loop through the FFS file sections within the PEI Core FFS file
+  //
+  EndOfSection = (EFI_PHYSICAL_ADDRESS)(UINTN) Sections;
+  EndOfSections = EndOfSection + SizeOfSections;
+  for (;;) {
+    if (EndOfSection == EndOfSections) {
+      break;
+    }
+    CurrentAddress = (EndOfSection + 3) & ~(3ULL);
+    if (CurrentAddress >= EndOfSections) {
+      return EFI_VOLUME_CORRUPTED;
+    }
+
+    Section = (EFI_COMMON_SECTION_HEADER*)(UINTN) CurrentAddress;
+
+    Size = SECTION_SIZE (Section);
+    if (Size < sizeof (*Section)) {
+      return EFI_VOLUME_CORRUPTED;
+    }
+
+    EndOfSection = CurrentAddress + Size;
+    if (EndOfSection > EndOfSections) {
+      return EFI_VOLUME_CORRUPTED;
+    }
+
+    //
+    // Look for the requested section type
+    //
+    if (Section->Type == SectionType) {
+      if (Instance == 0) {
+        *FoundSection = Section;
+        return EFI_SUCCESS;
+      } else {
+        Instance--;
+      }
+    }
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+/**
+  Locates a section within a series of sections
+  with the specified section type.
+
+  @param[in]   Sections        The sections to search
+  @param[in]   SizeOfSections  Total size of all sections
+  @param[in]   SectionType     The section type to locate
+  @param[out]  FoundSection    The FFS section if found
+
+  @retval EFI_SUCCESS           The file and section was found
+  @retval EFI_NOT_FOUND         The file and section was not found
+  @retval EFI_VOLUME_CORRUPTED  The firmware volume was corrupted
+
+**/
+EFI_STATUS
+FindFfsSectionInSections (
+  IN  VOID                             *Sections,
+  IN  UINTN                            SizeOfSections,
+  IN  EFI_SECTION_TYPE                 SectionType,
+  OUT EFI_COMMON_SECTION_HEADER        **FoundSection
+  )
+{
+  return FindFfsSectionInstance (
+           Sections,
+           SizeOfSections,
+           SectionType,
+           0,
+           FoundSection
+           );
+}
+
+/**
+  Locates a FFS file with the specified file type and a section
+  within that file with the specified section type.
+
+  @param[in]   Fv            The firmware volume to search
+  @param[in]   FileType      The file type to locate
+  @param[in]   SectionType   The section type to locate
+  @param[out]  FoundSection  The FFS section if found
+
+  @retval EFI_SUCCESS           The file and section was found
+  @retval EFI_NOT_FOUND         The file and section was not found
+  @retval EFI_VOLUME_CORRUPTED  The firmware volume was corrupted
+
+**/
+EFI_STATUS
+FindFfsFileAndSection (
+  IN  EFI_FIRMWARE_VOLUME_HEADER       *Fv,
+  IN  EFI_FV_FILETYPE                  FileType,
+  IN  EFI_SECTION_TYPE                 SectionType,
+  OUT EFI_COMMON_SECTION_HEADER        **FoundSection
+  )
+{
+  EFI_STATUS                  Status;
+  EFI_PHYSICAL_ADDRESS        CurrentAddress;
+  EFI_PHYSICAL_ADDRESS        EndOfFirmwareVolume;
+  EFI_FFS_FILE_HEADER         *File;
+  UINT32                      Size;
+  EFI_PHYSICAL_ADDRESS        EndOfFile;
+
+  if (Fv->Signature != EFI_FVH_SIGNATURE) {
+    DEBUG ((DEBUG_ERROR, "FV at %p does not have FV header signature\n", Fv));
+    return EFI_VOLUME_CORRUPTED;
+  }
+
+  CurrentAddress = (EFI_PHYSICAL_ADDRESS)(UINTN) Fv;
+  EndOfFirmwareVolume = CurrentAddress + Fv->FvLength;
+
+  //
+  // Loop through the FFS files in the Boot Firmware Volume
+  //
+  for (EndOfFile = CurrentAddress + Fv->HeaderLength; ; ) {
+
+    CurrentAddress = (EndOfFile + 7) & ~(7ULL);
+    if (CurrentAddress > EndOfFirmwareVolume) {
+      return EFI_VOLUME_CORRUPTED;
+    }
+
+    File = (EFI_FFS_FILE_HEADER*)(UINTN) CurrentAddress;
+    Size = FFS_FILE_SIZE (File);
+    if (Size < (sizeof (*File) + sizeof (EFI_COMMON_SECTION_HEADER))) {
+      return EFI_VOLUME_CORRUPTED;
+    }
+
+    EndOfFile = CurrentAddress + Size;
+    if (EndOfFile > EndOfFirmwareVolume) {
+      return EFI_VOLUME_CORRUPTED;
+    }
+
+    //
+    // Look for the request file type
+    //
+    if (File->Type != FileType) {
+      continue;
+    }
+
+    Status = FindFfsSectionInSections (
+               (VOID*) (File + 1),
+               (UINTN) EndOfFile - (UINTN) (File + 1),
+               SectionType,
+               FoundSection
+               );
+    if (!EFI_ERROR (Status) || (Status == EFI_VOLUME_CORRUPTED)) {
+      return Status;
+    }
+  }
+}
+
+/**
+  Locates the compressed main firmware volume and decompresses it.
+
+  @param[in,out]  Fv            On input, the firmware volume to search
+                                On output, the decompressed BOOT/PEI FV
+
+  @retval EFI_SUCCESS           The file and section was found
+  @retval EFI_NOT_FOUND         The file and section was not found
+  @retval EFI_VOLUME_CORRUPTED  The firmware volume was corrupted
+
+**/
+EFI_STATUS
+DecompressMemFvs (
+  IN OUT EFI_FIRMWARE_VOLUME_HEADER       **Fv
+  )
+{
+  EFI_STATUS                        Status;
+  EFI_GUID_DEFINED_SECTION          *Section;
+  UINT32                            OutputBufferSize;
+  UINT32                            ScratchBufferSize;
+  UINT16                            SectionAttribute;
+  UINT32                            AuthenticationStatus;
+  VOID                              *OutputBuffer;
+  VOID                              *ScratchBuffer;
+  EFI_COMMON_SECTION_HEADER         *FvSection;
+  EFI_FIRMWARE_VOLUME_HEADER        *PeiMemFv;
+  EFI_FIRMWARE_VOLUME_HEADER        *DxeMemFv;
+  UINT32                            FvHeaderSize;
+  UINT32                            FvSectionSize;
+
+  FvSection = (EFI_COMMON_SECTION_HEADER*) NULL;
+
+  Status = FindFfsFileAndSection (
+             *Fv,
+             EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE,
+             EFI_SECTION_GUID_DEFINED,
+             (EFI_COMMON_SECTION_HEADER**) &Section
+             );
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "Unable to find GUID defined section\n"));
+    return Status;
+  }
+
+  Status = ExtractGuidedSectionGetInfo (
+             Section,
+             &OutputBufferSize,
+             &ScratchBufferSize,
+             &SectionAttribute
+             );
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "Unable to GetInfo for GUIDed section\n"));
+    return Status;
+  }
+
+  OutputBuffer = (VOID*) ((UINT8*)(UINTN) PcdGet32 (PcdOvmfDxeMemFvBase) + SIZE_1MB);
+  ScratchBuffer = ALIGN_POINTER ((UINT8*) OutputBuffer + OutputBufferSize, SIZE_1MB);
+
+  DEBUG ((DEBUG_VERBOSE, "%a: OutputBuffer@%p+0x%x ScratchBuffer@%p+0x%x "
+    "PcdOvmfDecompressionScratchEnd=0x%x\n", __FUNCTION__, OutputBuffer,
+    OutputBufferSize, ScratchBuffer, ScratchBufferSize,
+    PcdGet32 (PcdOvmfDecompressionScratchEnd)));
+  ASSERT ((UINTN)ScratchBuffer + ScratchBufferSize ==
+    PcdGet32 (PcdOvmfDecompressionScratchEnd));
+
+  Status = ExtractGuidedSectionDecode (
+             Section,
+             &OutputBuffer,
+             ScratchBuffer,
+             &AuthenticationStatus
+             );
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "Error during GUID section decode\n"));
+    return Status;
+  }
+
+  Status = FindFfsSectionInstance (
+             OutputBuffer,
+             OutputBufferSize,
+             EFI_SECTION_FIRMWARE_VOLUME_IMAGE,
+             0,
+             &FvSection
+             );
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "Unable to find PEI FV section\n"));
+    return Status;
+  }
+
+  ASSERT (SECTION_SIZE (FvSection) ==
+          (PcdGet32 (PcdOvmfPeiMemFvSize) + sizeof (*FvSection)));
+  ASSERT (FvSection->Type == EFI_SECTION_FIRMWARE_VOLUME_IMAGE);
+
+  PeiMemFv = (EFI_FIRMWARE_VOLUME_HEADER*)(UINTN) PcdGet32 (PcdOvmfPeiMemFvBase);
+  CopyMem (PeiMemFv, (VOID*) (FvSection + 1), PcdGet32 (PcdOvmfPeiMemFvSize));
+
+  if (PeiMemFv->Signature != EFI_FVH_SIGNATURE) {
+    DEBUG ((DEBUG_ERROR, "Extracted FV at %p does not have FV header signature\n", PeiMemFv));
+    CpuDeadLoop ();
+    return EFI_VOLUME_CORRUPTED;
+  }
+
+  Status = FindFfsSectionInstance (
+             OutputBuffer,
+             OutputBufferSize,
+             EFI_SECTION_FIRMWARE_VOLUME_IMAGE,
+             1,
+             &FvSection
+             );
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "Unable to find DXE FV section\n"));
+    return Status;
+  }
+
+  ASSERT (FvSection->Type == EFI_SECTION_FIRMWARE_VOLUME_IMAGE);
+
+  if (IS_SECTION2 (FvSection)) {
+    FvSectionSize = SECTION2_SIZE (FvSection);
+    FvHeaderSize = sizeof (EFI_COMMON_SECTION_HEADER2);
+  } else {
+    FvSectionSize = SECTION_SIZE (FvSection);
+    FvHeaderSize = sizeof (EFI_COMMON_SECTION_HEADER);
+  }
+
+  ASSERT (FvSectionSize == (PcdGet32 (PcdOvmfDxeMemFvSize) + FvHeaderSize));
+
+  DxeMemFv = (EFI_FIRMWARE_VOLUME_HEADER*)(UINTN) PcdGet32 (PcdOvmfDxeMemFvBase);
+  CopyMem (DxeMemFv, (VOID*) ((UINTN)FvSection + FvHeaderSize), PcdGet32 (PcdOvmfDxeMemFvSize));
+
+  if (DxeMemFv->Signature != EFI_FVH_SIGNATURE) {
+    DEBUG ((DEBUG_ERROR, "Extracted FV at %p does not have FV header signature\n", DxeMemFv));
+    CpuDeadLoop ();
+    return EFI_VOLUME_CORRUPTED;
+  }
+
+  *Fv = PeiMemFv;
+  return EFI_SUCCESS;
+}
+
+/**
+  Locates the PEI Core entry point address
+
+  @param[in]  Fv                 The firmware volume to search
+  @param[out] PeiCoreEntryPoint  The entry point of the PEI Core image
+
+  @retval EFI_SUCCESS           The file and section was found
+  @retval EFI_NOT_FOUND         The file and section was not found
+  @retval EFI_VOLUME_CORRUPTED  The firmware volume was corrupted
+
+**/
+EFI_STATUS
+FindPeiCoreImageBaseInFv (
+  IN  EFI_FIRMWARE_VOLUME_HEADER       *Fv,
+  OUT  EFI_PHYSICAL_ADDRESS             *PeiCoreImageBase
+  )
+{
+  EFI_STATUS                  Status;
+  EFI_COMMON_SECTION_HEADER   *Section;
+
+  Status = FindFfsFileAndSection (
+             Fv,
+             EFI_FV_FILETYPE_PEI_CORE,
+             EFI_SECTION_PE32,
+             &Section
+             );
+  if (EFI_ERROR (Status)) {
+    Status = FindFfsFileAndSection (
+               Fv,
+               EFI_FV_FILETYPE_PEI_CORE,
+               EFI_SECTION_TE,
+               &Section
+               );
+    if (EFI_ERROR (Status)) {
+      DEBUG ((DEBUG_ERROR, "Unable to find PEI Core image\n"));
+      return Status;
+    }
+  }
+
+  *PeiCoreImageBase = (EFI_PHYSICAL_ADDRESS)(UINTN)(Section + 1);
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Reads 8-bits of CMOS data.
+
+  Reads the 8-bits of CMOS data at the location specified by Index.
+  The 8-bit read value is returned.
+
+  @param  Index  The CMOS location to read.
+
+  @return The value read.
+
+**/
+STATIC
+UINT8
+CmosRead8 (
+  IN      UINTN                     Index
+  )
+{
+  IoWrite8 (0x70, (UINT8) Index);
+  return IoRead8 (0x71);
+}
+
+
+STATIC
+BOOLEAN
+IsS3Resume (
+  VOID
+  )
+{
+  return (CmosRead8 (0xF) == 0xFE);
+}
+
+
+STATIC
+EFI_STATUS
+GetS3ResumePeiFv (
+  IN OUT EFI_FIRMWARE_VOLUME_HEADER       **PeiFv
+  )
+{
+  *PeiFv = (EFI_FIRMWARE_VOLUME_HEADER*)(UINTN) PcdGet32 (PcdOvmfPeiMemFvBase);
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Locates the PEI Core entry point address
+
+  @param[in,out]  Fv                 The firmware volume to search
+  @param[out]     PeiCoreEntryPoint  The entry point of the PEI Core image
+
+  @retval EFI_SUCCESS           The file and section was found
+  @retval EFI_NOT_FOUND         The file and section was not found
+  @retval EFI_VOLUME_CORRUPTED  The firmware volume was corrupted
+
+**/
+VOID
+FindPeiCoreImageBase (
+  IN OUT  EFI_FIRMWARE_VOLUME_HEADER       **BootFv,
+     OUT  EFI_PHYSICAL_ADDRESS             *PeiCoreImageBase
+  )
+{
+  BOOLEAN S3Resume;
+
+  *PeiCoreImageBase = 0;
+
+  S3Resume = IsS3Resume ();
+  if (S3Resume && !FeaturePcdGet (PcdSmmSmramRequire)) {
+    //
+    // A malicious runtime OS may have injected something into our previously
+    // decoded PEI FV, but we don't care about that unless SMM/SMRAM is required.
+    //
+    DEBUG ((DEBUG_VERBOSE, "SEC: S3 resume\n"));
+    GetS3ResumePeiFv (BootFv);
+  } else {
+    //
+    // We're either not resuming, or resuming "securely" -- we'll decompress
+    // both PEI FV and DXE FV from pristine flash.
+    //
+    DEBUG ((DEBUG_VERBOSE, "SEC: %a\n",
+      S3Resume ? "S3 resume (with PEI decompression)" : "Normal boot"));
+    FindMainFv (BootFv);
+
+    DecompressMemFvs (BootFv);
+  }
+
+  FindPeiCoreImageBaseInFv (*BootFv, PeiCoreImageBase);
+}
+
+/**
+  Find core image base.
+
+**/
+EFI_STATUS
+FindImageBase (
+  IN  EFI_FIRMWARE_VOLUME_HEADER       *BootFirmwareVolumePtr,
+  OUT EFI_PHYSICAL_ADDRESS             *SecCoreImageBase
+  )
+{
+  EFI_PHYSICAL_ADDRESS        CurrentAddress;
+  EFI_PHYSICAL_ADDRESS        EndOfFirmwareVolume;
+  EFI_FFS_FILE_HEADER         *File;
+  UINT32                      Size;
+  EFI_PHYSICAL_ADDRESS        EndOfFile;
+  EFI_COMMON_SECTION_HEADER   *Section;
+  EFI_PHYSICAL_ADDRESS        EndOfSection;
+
+  *SecCoreImageBase = 0;
+
+  CurrentAddress = (EFI_PHYSICAL_ADDRESS)(UINTN) BootFirmwareVolumePtr;
+  EndOfFirmwareVolume = CurrentAddress + BootFirmwareVolumePtr->FvLength;
+
+  //
+  // Loop through the FFS files in the Boot Firmware Volume
+  //
+  for (EndOfFile = CurrentAddress + BootFirmwareVolumePtr->HeaderLength; ; ) {
+
+    CurrentAddress = (EndOfFile + 7) & 0xfffffffffffffff8ULL;
+    if (CurrentAddress > EndOfFirmwareVolume) {
+      return EFI_NOT_FOUND;
+    }
+
+    File = (EFI_FFS_FILE_HEADER*)(UINTN) CurrentAddress;
+    Size = FFS_FILE_SIZE (File);
+    if (Size < sizeof (*File)) {
+      return EFI_NOT_FOUND;
+    }
+
+    EndOfFile = CurrentAddress + Size;
+    if (EndOfFile > EndOfFirmwareVolume) {
+      return EFI_NOT_FOUND;
+    }
+
+    //
+    // Look for SEC Core
+    //
+    if (File->Type != EFI_FV_FILETYPE_SECURITY_CORE) {
+      continue;
+    }
+
+    //
+    // Loop through the FFS file sections within the FFS file
+    //
+    EndOfSection = (EFI_PHYSICAL_ADDRESS)(UINTN) (File + 1);
+    for (;;) {
+      CurrentAddress = (EndOfSection + 3) & 0xfffffffffffffffcULL;
+      Section = (EFI_COMMON_SECTION_HEADER*)(UINTN) CurrentAddress;
+
+      Size = SECTION_SIZE (Section);
+      if (Size < sizeof (*Section)) {
+        return EFI_NOT_FOUND;
+      }
+
+      EndOfSection = CurrentAddress + Size;
+      if (EndOfSection > EndOfFile) {
+        return EFI_NOT_FOUND;
+      }
+
+      //
+      // Look for executable sections
+      //
+      if (Section->Type == EFI_SECTION_PE32 || Section->Type == EFI_SECTION_TE) {
+        if (File->Type == EFI_FV_FILETYPE_SECURITY_CORE) {
+          *SecCoreImageBase = (PHYSICAL_ADDRESS) (UINTN) (Section + 1);
+        }
+        break;
+      }
+    }
+
+    //
+    // SEC Core image found
+    //
+    if (*SecCoreImageBase != 0) {
+      return EFI_SUCCESS;
+    }
+  }
+}
+
+/*
+  Find and return Pei Core entry point.
+
+  It also find SEC and PEI Core file debug information. It will report them if
+  remote debug is enabled.
+
+**/
+VOID
+FindAndReportEntryPoints (
+  IN  EFI_FIRMWARE_VOLUME_HEADER       **BootFirmwareVolumePtr,
+  OUT EFI_PEI_CORE_ENTRY_POINT         *PeiCoreEntryPoint
+  )
+{
+  EFI_STATUS                       Status;
+  EFI_PHYSICAL_ADDRESS             SecCoreImageBase;
+  EFI_PHYSICAL_ADDRESS             PeiCoreImageBase;
+  PE_COFF_LOADER_IMAGE_CONTEXT     ImageContext;
+
+  //
+  // Find SEC Core and PEI Core image base
+   //
+  Status = FindImageBase (*BootFirmwareVolumePtr, &SecCoreImageBase);
+  ASSERT_EFI_ERROR (Status);
+
+  FindPeiCoreImageBase (BootFirmwareVolumePtr, &PeiCoreImageBase);
+
+  ZeroMem ((VOID *) &ImageContext, sizeof (PE_COFF_LOADER_IMAGE_CONTEXT));
+  //
+  // Report SEC Core debug information when remote debug is enabled
+  //
+  ImageContext.ImageAddress = SecCoreImageBase;
+  ImageContext.PdbPointer = PeCoffLoaderGetPdbPointer ((VOID*) (UINTN) ImageContext.ImageAddress);
+  PeCoffLoaderRelocateImageExtraAction (&ImageContext);
+
+  //
+  // Report PEI Core debug information when remote debug is enabled
+  //
+  ImageContext.ImageAddress = (EFI_PHYSICAL_ADDRESS)(UINTN)PeiCoreImageBase;
+  ImageContext.PdbPointer = PeCoffLoaderGetPdbPointer ((VOID*) (UINTN) ImageContext.ImageAddress);
+  PeCoffLoaderRelocateImageExtraAction (&ImageContext);
+
+  //
+  // Find PEI Core entry point
+  //
+  Status = PeCoffLoaderGetEntryPoint ((VOID *) (UINTN) PeiCoreImageBase, (VOID**) PeiCoreEntryPoint);
+  if (EFI_ERROR (Status)) {
+    *PeiCoreEntryPoint = 0;
+  }
+
+  return;
+}
+
+VOID
+EFIAPI
+SecCoreStartupWithStack (
+  IN EFI_FIRMWARE_VOLUME_HEADER       *BootFv,
+  IN VOID                             *TopOfCurrentStack
+  )
+{
+  EFI_SEC_PEI_HAND_OFF        SecCoreData;
+  SEC_IDT_TABLE               IdtTableInStack;
+  IA32_DESCRIPTOR             IdtDescriptor;
+  UINT32                      Index;
+  volatile UINT8              *Table;
+
+  //
+  // To ensure SMM can't be compromised on S3 resume, we must force re-init of
+  // the BaseExtractGuidedSectionLib. Since this is before library contructors
+  // are called, we must use a loop rather than SetMem.
+  //
+  Table = (UINT8*)(UINTN)FixedPcdGet64 (PcdGuidedExtractHandlerTableAddress);
+  for (Index = 0;
+       Index < FixedPcdGet32 (PcdGuidedExtractHandlerTableSize);
+       ++Index) {
+    Table[Index] = 0;
+  }
+
+  ProcessLibraryConstructorList (NULL, NULL);
+
+  DEBUG ((DEBUG_INFO,
+    "SecCoreStartupWithStack(0x%x, 0x%x)\n",
+    (UINT32)(UINTN)BootFv,
+    (UINT32)(UINTN)TopOfCurrentStack
+    ));
+
+  //
+  // Initialize floating point operating environment
+  // to be compliant with UEFI spec.
+  //
+  InitializeFloatingPointUnits ();
+
+  //
+  // Initialize IDT
+  //
+  IdtTableInStack.PeiService = NULL;
+  for (Index = 0; Index < SEC_IDT_ENTRY_COUNT; Index ++) {
+    CopyMem (&IdtTableInStack.IdtTable[Index], &mIdtEntryTemplate, sizeof (mIdtEntryTemplate));
+  }
+
+  IdtDescriptor.Base  = (UINTN)&IdtTableInStack.IdtTable;
+  IdtDescriptor.Limit = (UINT16)(sizeof (IdtTableInStack.IdtTable) - 1);
+
+  AsmWriteIdtr (&IdtDescriptor);
+
+#if defined (MDE_CPU_X64)
+  //
+  // ASSERT that the Page Tables were set by the reset vector code to
+  // the address we expect.
+  //
+  ASSERT (AsmReadCr3 () == (UINTN) PcdGet32 (PcdOvmfSecPageTablesBase));
+#endif
+
+  //
+  // |-------------|       <-- TopOfCurrentStack
+  // |   Stack     | 32k
+  // |-------------|
+  // |    Heap     | 32k
+  // |-------------|       <-- SecCoreData.TemporaryRamBase
+  //
+
+  ASSERT ((UINTN) (PcdGet32 (PcdOvmfSecPeiTempRamBase) +
+                   PcdGet32 (PcdOvmfSecPeiTempRamSize)) ==
+          (UINTN) TopOfCurrentStack);
+
+  //
+  // Initialize SEC hand-off state
+  //
+  SecCoreData.DataSize = sizeof(EFI_SEC_PEI_HAND_OFF);
+
+  SecCoreData.TemporaryRamSize       = (UINTN) PcdGet32 (PcdOvmfSecPeiTempRamSize);
+  SecCoreData.TemporaryRamBase       = (VOID*)((UINT8 *)TopOfCurrentStack - SecCoreData.TemporaryRamSize);
+
+  SecCoreData.PeiTemporaryRamBase    = SecCoreData.TemporaryRamBase;
+  SecCoreData.PeiTemporaryRamSize    = SecCoreData.TemporaryRamSize >> 1;
+
+  SecCoreData.StackBase              = (UINT8 *)SecCoreData.TemporaryRamBase + SecCoreData.PeiTemporaryRamSize;
+  SecCoreData.StackSize              = SecCoreData.TemporaryRamSize >> 1;
+
+  SecCoreData.BootFirmwareVolumeBase = BootFv;
+  SecCoreData.BootFirmwareVolumeSize = (UINTN) BootFv->FvLength;
+
+  //
+  // Make sure the 8259 is masked before initializing the Debug Agent and the debug timer is enabled
+  //
+  IoWrite8 (0x21, 0xff);
+  IoWrite8 (0xA1, 0xff);
+
+  //
+  // Initialize Local APIC Timer hardware and disable Local APIC Timer
+  // interrupts before initializing the Debug Agent and the debug timer is
+  // enabled.
+  //
+  InitializeApicTimer (0, MAX_UINT32, TRUE, 5);
+  DisableApicTimerInterrupt ();
+
+  //
+  // Initialize Debug Agent to support source level debug in SEC/PEI phases before memory ready.
+  //
+  InitializeDebugAgent (DEBUG_AGENT_INIT_PREMEM_SEC, &SecCoreData, SecStartupPhase2);
+}
+
+/**
+  Caller provided function to be invoked at the end of InitializeDebugAgent().
+
+  Entry point to the C language phase of SEC. After the SEC assembly
+  code has initialized some temporary memory and set up the stack,
+  the control is transferred to this function.
+
+  @param[in] Context    The first input parameter of InitializeDebugAgent().
+
+**/
+VOID
+EFIAPI
+SecStartupPhase2(
+  IN VOID                     *Context
+  )
+{
+  EFI_SEC_PEI_HAND_OFF        *SecCoreData;
+  EFI_FIRMWARE_VOLUME_HEADER  *BootFv;
+  EFI_PEI_CORE_ENTRY_POINT    PeiCoreEntryPoint;
+
+  SecCoreData = (EFI_SEC_PEI_HAND_OFF *) Context;
+
+  //
+  // Find PEI Core entry point. It will report SEC and Pei Core debug information if remote debug
+  // is enabled.
+  //
+  BootFv = (EFI_FIRMWARE_VOLUME_HEADER *)SecCoreData->BootFirmwareVolumeBase;
+  FindAndReportEntryPoints (&BootFv, &PeiCoreEntryPoint);
+  SecCoreData->BootFirmwareVolumeBase = BootFv;
+  SecCoreData->BootFirmwareVolumeSize = (UINTN) BootFv->FvLength;
+
+  //
+  // Transfer the control to the PEI core
+  //
+  (*PeiCoreEntryPoint) (SecCoreData, (EFI_PEI_PPI_DESCRIPTOR *)&mPrivateDispatchTable);
+
+  //
+  // If we get here then the PEI Core returned, which is not recoverable.
+  //
+  ASSERT (FALSE);
+  CpuDeadLoop ();
+}
+
+EFI_STATUS
+EFIAPI
+TemporaryRamMigration (
+  IN CONST EFI_PEI_SERVICES   **PeiServices,
+  IN EFI_PHYSICAL_ADDRESS     TemporaryMemoryBase,
+  IN EFI_PHYSICAL_ADDRESS     PermanentMemoryBase,
+  IN UINTN                    CopySize
+  )
+{
+  IA32_DESCRIPTOR                  IdtDescriptor;
+  VOID                             *OldHeap;
+  VOID                             *NewHeap;
+  VOID                             *OldStack;
+  VOID                             *NewStack;
+  DEBUG_AGENT_CONTEXT_POSTMEM_SEC  DebugAgentContext;
+  BOOLEAN                          OldStatus;
+  BASE_LIBRARY_JUMP_BUFFER         JumpBuffer;
+
+  DEBUG ((DEBUG_INFO,
+    "TemporaryRamMigration(0x%Lx, 0x%Lx, 0x%Lx)\n",
+    TemporaryMemoryBase,
+    PermanentMemoryBase,
+    (UINT64)CopySize
+    ));
+
+  OldHeap = (VOID*)(UINTN)TemporaryMemoryBase;
+  NewHeap = (VOID*)((UINTN)PermanentMemoryBase + (CopySize >> 1));
+
+  OldStack = (VOID*)((UINTN)TemporaryMemoryBase + (CopySize >> 1));
+  NewStack = (VOID*)(UINTN)PermanentMemoryBase;
+
+  DebugAgentContext.HeapMigrateOffset = (UINTN)NewHeap - (UINTN)OldHeap;
+  DebugAgentContext.StackMigrateOffset = (UINTN)NewStack - (UINTN)OldStack;
+
+  OldStatus = SaveAndSetDebugTimerInterrupt (FALSE);
+  InitializeDebugAgent (DEBUG_AGENT_INIT_POSTMEM_SEC, (VOID *) &DebugAgentContext, NULL);
+
+  //
+  // Migrate Heap
+  //
+  CopyMem (NewHeap, OldHeap, CopySize >> 1);
+
+  //
+  // Migrate Stack
+  //
+  CopyMem (NewStack, OldStack, CopySize >> 1);
+
+  //
+  // Rebase IDT table in permanent memory
+  //
+  AsmReadIdtr (&IdtDescriptor);
+  IdtDescriptor.Base = IdtDescriptor.Base - (UINTN)OldStack + (UINTN)NewStack;
+
+  AsmWriteIdtr (&IdtDescriptor);
+
+  //
+  // Use SetJump()/LongJump() to switch to a new stack.
+  //
+  if (SetJump (&JumpBuffer) == 0) {
+#if defined (MDE_CPU_IA32)
+    JumpBuffer.Esp = JumpBuffer.Esp + DebugAgentContext.StackMigrateOffset;
+    JumpBuffer.Ebp = JumpBuffer.Ebp + DebugAgentContext.StackMigrateOffset;
+#endif
+#if defined (MDE_CPU_X64)
+    JumpBuffer.Rsp = JumpBuffer.Rsp + DebugAgentContext.StackMigrateOffset;
+    JumpBuffer.Rbp = JumpBuffer.Rbp + DebugAgentContext.StackMigrateOffset;
+#endif
+    LongJump (&JumpBuffer, (UINTN)-1);
+  }
+
+  SaveAndSetDebugTimerInterrupt (OldStatus);
+
+  return EFI_SUCCESS;
+}
+
diff --git a/TestPkg/Sec/SecMain.inf b/TestPkg/Sec/SecMain.inf
new file mode 100644
index 0000000000..3066e0d102
--- /dev/null
+++ b/TestPkg/Sec/SecMain.inf
@@ -0,0 +1,73 @@
+## @file
+#  SEC Driver
+#
+#  Copyright (c) 2008 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = SecMain
+  FILE_GUID                      = df1ccef6-f301-4a63-9661-fc6030dcc880
+  MODULE_TYPE                    = SEC
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = SecMain
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 EBC
+#
+
+[Sources]
+  SecMain.c
+
+[Sources.IA32]
+  Ia32/SecEntry.nasm
+
+[Sources.X64]
+  X64/SecEntry.nasm
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  UefiCpuPkg/UefiCpuPkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  DebugLib
+  BaseMemoryLib
+  PeiServicesLib
+  PcdLib
+  UefiCpuLib
+  DebugAgentLib
+  IoLib
+  PeCoffLib
+  PeCoffGetEntryPointLib
+  PeCoffExtraActionLib
+  ExtractGuidedSectionLib
+  LocalApicLib
+  FakeLibraryLib
+  LockBoxLib
+
+[Ppis]
+  gEfiTemporaryRamSupportPpiGuid                # PPI ALWAYS_PRODUCED
+
+[Pcd]
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfPeiMemFvBase
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfPeiMemFvSize
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfDxeMemFvBase
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfDxeMemFvSize
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPageTablesBase
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPeiTempRamBase
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPeiTempRamSize
+  gEfiMdePkgTokenSpaceGuid.PcdGuidedExtractHandlerTableAddress
+  gUefiOvmfPkgTokenSpaceGuid.PcdGuidedExtractHandlerTableSize
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfDecompressionScratchEnd
+  gEfiMdeModulePkgTokenSpaceGuid.PcdInitValueInTempStack
+
+[FeaturePcd]
+  gUefiOvmfPkgTokenSpaceGuid.PcdSmmSmramRequire
diff --git a/TestPkg/Sec/X64/SecEntry.nasm b/TestPkg/Sec/X64/SecEntry.nasm
new file mode 100644
index 0000000000..19b18921c0
--- /dev/null
+++ b/TestPkg/Sec/X64/SecEntry.nasm
@@ -0,0 +1,69 @@
+;------------------------------------------------------------------------------
+;*
+;*   Copyright (c) 2006 - 2013, Intel Corporation. All rights reserved.<BR>
+;*   SPDX-License-Identifier: BSD-2-Clause-Patent
+;*
+;*    CpuAsm.asm
+;*
+;*   Abstract:
+;*
+;------------------------------------------------------------------------------
+
+#include <Base.h>
+
+DEFAULT REL
+SECTION .text
+
+extern ASM_PFX(SecCoreStartupWithStack)
+
+;
+; SecCore Entry Point
+;
+; Processor is in flat protected mode
+;
+; @param[in]  RAX   Initial value of the EAX register (BIST: Built-in Self Test)
+; @param[in]  DI    'BP': boot-strap processor, or 'AP': application processor
+; @param[in]  RBP   Pointer to the start of the Boot Firmware Volume
+; @param[in]  DS    Selector allowing flat access to all addresses
+; @param[in]  ES    Selector allowing flat access to all addresses
+; @param[in]  FS    Selector allowing flat access to all addresses
+; @param[in]  GS    Selector allowing flat access to all addresses
+; @param[in]  SS    Selector allowing flat access to all addresses
+;
+; @return     None  This routine does not return
+;
+global ASM_PFX(_ModuleEntryPoint)
+ASM_PFX(_ModuleEntryPoint):
+
+    ;
+    ; Fill the temporary RAM with the initial stack value.
+    ; The loop below will seed the heap as well, but that's harmless.
+    ;
+    mov     rax, (FixedPcdGet32 (PcdInitValueInTempStack) << 32) | FixedPcdGet32 (PcdInitValueInTempStack)
+                                                              ; qword to store
+    mov     rdi, FixedPcdGet32 (PcdOvmfSecPeiTempRamBase)     ; base address,
+                                                              ;   relative to
+                                                              ;   ES
+    mov     rcx, FixedPcdGet32 (PcdOvmfSecPeiTempRamSize) / 8 ; qword count
+    cld                                                       ; store from base
+                                                              ;   up
+    rep stosq
+
+    ;
+    ; Load temporary RAM stack based on PCDs
+    ;
+    %define SEC_TOP_OF_STACK (FixedPcdGet32 (PcdOvmfSecPeiTempRamBase) + \
+                          FixedPcdGet32 (PcdOvmfSecPeiTempRamSize))
+    mov     rsp, SEC_TOP_OF_STACK
+    nop
+
+    ;
+    ; Setup parameters and call SecCoreStartupWithStack
+    ;   rcx: BootFirmwareVolumePtr
+    ;   rdx: TopOfCurrentStack
+    ;
+    mov     rcx, rbp
+    mov     rdx, rsp
+    sub     rsp, 0x20
+    call    ASM_PFX(SecCoreStartupWithStack)
+
diff --git a/TestPkg/TestIa32X64.fdf b/TestPkg/TestIa32X64.fdf
new file mode 100644
index 0000000000..71dfeccb9a
--- /dev/null
+++ b/TestPkg/TestIa32X64.fdf
@@ -0,0 +1,348 @@
+## @file
+#  Open Virtual Machine Firmware: FDF
+#
+#  Copyright (c) 2006 - 2019, Intel Corporation. All rights reserved.<BR>
+#  (C) Copyright 2016 Hewlett Packard Enterprise Development LP<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+################################################################################
+
+[Defines]
+!include TestPkgDefines.fdf.inc
+
+#
+# Build the variable store and the firmware code as one unified flash device
+# image.
+#
+[FD.OVMF]
+BaseAddress   = $(FW_BASE_ADDRESS)
+Size          = $(FW_SIZE)
+ErasePolarity = 1
+BlockSize     = $(BLOCK_SIZE)
+NumBlocks     = $(FW_BLOCKS)
+
+!include VarStore.fdf.inc
+
+$(VARS_SIZE)|$(FVMAIN_SIZE)
+FV = FVMAIN_COMPACT
+
+$(SECFV_OFFSET)|$(SECFV_SIZE)
+FV = SECFV
+
+#
+# Build the variable store and the firmware code as separate flash device
+# images.
+#
+[FD.OVMF_VARS]
+BaseAddress   = $(FW_BASE_ADDRESS)
+Size          = $(VARS_SIZE)
+ErasePolarity = 1
+BlockSize     = $(BLOCK_SIZE)
+NumBlocks     = $(VARS_BLOCKS)
+
+!include VarStore.fdf.inc
+
+[FD.OVMF_CODE]
+BaseAddress   = $(CODE_BASE_ADDRESS)
+Size          = $(CODE_SIZE)
+ErasePolarity = 1
+BlockSize     = $(BLOCK_SIZE)
+NumBlocks     = $(CODE_BLOCKS)
+
+0x00000000|$(FVMAIN_SIZE)
+FV = FVMAIN_COMPACT
+
+$(FVMAIN_SIZE)|$(SECFV_SIZE)
+FV = SECFV
+
+################################################################################
+
+[FD.MEMFD]
+BaseAddress   = $(MEMFD_BASE_ADDRESS)
+Size          = 0xD00000
+ErasePolarity = 1
+BlockSize     = 0x10000
+NumBlocks     = 0xD0
+
+0x000000|0x006000
+gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPageTablesBase|gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPageTablesSize
+
+0x006000|0x001000
+gUefiOvmfPkgTokenSpaceGuid.PcdOvmfLockBoxStorageBase|gUefiOvmfPkgTokenSpaceGuid.PcdOvmfLockBoxStorageSize
+
+0x007000|0x001000
+gEfiMdePkgTokenSpaceGuid.PcdGuidedExtractHandlerTableAddress|gUefiOvmfPkgTokenSpaceGuid.PcdGuidedExtractHandlerTableSize
+
+0x010000|0x010000
+gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPeiTempRamBase|gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPeiTempRamSize
+
+0x020000|0x0E0000
+gUefiOvmfPkgTokenSpaceGuid.PcdOvmfPeiMemFvBase|gUefiOvmfPkgTokenSpaceGuid.PcdOvmfPeiMemFvSize
+FV = PEIFV
+
+0x100000|0xC00000
+gUefiOvmfPkgTokenSpaceGuid.PcdOvmfDxeMemFvBase|gUefiOvmfPkgTokenSpaceGuid.PcdOvmfDxeMemFvSize
+FV = DXEFV
+
+################################################################################
+
+[FV.SECFV]
+FvNameGuid         = 763BED0D-DE9F-48F5-81F1-3E90E1B1A015
+BlockSize          = 0x1000
+FvAlignment        = 16
+ERASE_POLARITY     = 1
+MEMORY_MAPPED      = TRUE
+STICKY_WRITE       = TRUE
+LOCK_CAP           = TRUE
+LOCK_STATUS        = TRUE
+WRITE_DISABLED_CAP = TRUE
+WRITE_ENABLED_CAP  = TRUE
+WRITE_STATUS       = TRUE
+WRITE_LOCK_CAP     = TRUE
+WRITE_LOCK_STATUS  = TRUE
+READ_DISABLED_CAP  = TRUE
+READ_ENABLED_CAP   = TRUE
+READ_STATUS        = TRUE
+READ_LOCK_CAP      = TRUE
+READ_LOCK_STATUS   = TRUE
+
+#
+# SEC Phase modules
+#
+# The code in this FV handles the initial firmware startup, and
+# decompresses the PEI and DXE FVs which handles the rest of the boot sequence.
+#
+INF  TestPkg/Sec/SecMain.inf
+INF  TestPkg\FakeEmuSec\Sec.inf
+
+INF  RuleOverride=RESET_VECTOR TestPkg/ResetVector/ResetVector.inf
+
+################################################################################
+[FV.PEIFV]
+FvNameGuid         = 6938079B-B503-4E3D-9D24-B28337A25806
+BlockSize          = 0x10000
+FvAlignment        = 16
+ERASE_POLARITY     = 1
+MEMORY_MAPPED      = TRUE
+STICKY_WRITE       = TRUE
+LOCK_CAP           = TRUE
+LOCK_STATUS        = TRUE
+WRITE_DISABLED_CAP = TRUE
+WRITE_ENABLED_CAP  = TRUE
+WRITE_STATUS       = TRUE
+WRITE_LOCK_CAP     = TRUE
+WRITE_LOCK_STATUS  = TRUE
+READ_DISABLED_CAP  = TRUE
+READ_ENABLED_CAP   = TRUE
+READ_STATUS        = TRUE
+READ_LOCK_CAP      = TRUE
+READ_LOCK_STATUS   = TRUE
+
+APRIORI PEI {
+  INF  MdeModulePkg/Universal/PCD/Pei/Pcd.inf
+}
+
+#
+#  PEI Phase modules
+#
+INF  MdeModulePkg/Core/Pei/PeiMain.inf
+INF  MdeModulePkg/Universal/PCD/Pei/Pcd.inf
+INF  MdeModulePkg\Core\DxeIplPeim\DxeIpl.inf
+INF UefiCpuPkg\CpuMpPei\CpuMpPei.inf
+
+
+################################################################################
+
+[FV.DXEFV]
+FvForceRebase      = FALSE
+FvNameGuid         = 7CB8BDC9-F8EB-4F34-AAEA-3EE4AF6516A1
+BlockSize          = 0x10000
+FvAlignment        = 16
+ERASE_POLARITY     = 1
+MEMORY_MAPPED      = TRUE
+STICKY_WRITE       = TRUE
+LOCK_CAP           = TRUE
+LOCK_STATUS        = TRUE
+WRITE_DISABLED_CAP = TRUE
+WRITE_ENABLED_CAP  = TRUE
+WRITE_STATUS       = TRUE
+WRITE_LOCK_CAP     = TRUE
+WRITE_LOCK_STATUS  = TRUE
+READ_DISABLED_CAP  = TRUE
+READ_ENABLED_CAP   = TRUE
+READ_STATUS        = TRUE
+READ_LOCK_CAP      = TRUE
+READ_LOCK_STATUS   = TRUE
+
+#
+# DXE Phase modules
+#
+INF  MdeModulePkg/Core/Dxe/DxeMain.inf
+INF  MdeModulePkg/Universal/PCD/Dxe/Pcd.inf
+INF  MdeModulePkg/Application/UiApp/UiApp.inf
+INF  MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+INF  FatPkg/EnhancedFatDxe/Fat.inf
+INF  RuleOverride=ACPITABLE TestPkg/AcpiTables/AcpiTables.inf
+
+INF  UefiCpuPkg\CpuDxe\CpuDxe.inf
+#INF  MdeModulePkg/Universal/ReportStatusCodeRouter/RuntimeDxe/ReportStatusCodeRouterRuntimeDxe.inf
+#INF  MdeModulePkg/Universal/StatusCodeHandler/RuntimeDxe/StatusCodeHandlerRuntimeDxe.inf
+
+INF  MdeModulePkg/Logo/LogoDxe.inf
+INF  TestPkg\FakeLogo\JpegLogoDxe.inf
+INF  TestPkg/PlatformDxe/Platform.inf
+
+################################################################################
+
+[FV.FVMAIN_COMPACT]
+FvNameGuid         = 48DB5E17-707C-472D-91CD-1613E7EF51B0
+FvAlignment        = 16
+ERASE_POLARITY     = 1
+MEMORY_MAPPED      = TRUE
+STICKY_WRITE       = TRUE
+LOCK_CAP           = TRUE
+LOCK_STATUS        = TRUE
+WRITE_DISABLED_CAP = TRUE
+WRITE_ENABLED_CAP  = TRUE
+WRITE_STATUS       = TRUE
+WRITE_LOCK_CAP     = TRUE
+WRITE_LOCK_STATUS  = TRUE
+READ_DISABLED_CAP  = TRUE
+READ_ENABLED_CAP   = TRUE
+READ_STATUS        = TRUE
+READ_LOCK_CAP      = TRUE
+READ_LOCK_STATUS   = TRUE
+
+FILE FV_IMAGE = 9E21FD93-9C72-4c15-8C4B-E77F1DB2D792 {
+   SECTION GUIDED EE4E5898-3914-4259-9D6E-DC7BD79403CF PROCESSING_REQUIRED = TRUE {
+     #
+     # These firmware volumes will have files placed in them uncompressed,
+     # and then both firmware volumes will be compressed in a single
+     # compression operation in order to achieve better overall compression.
+     #
+     SECTION FV_IMAGE = PEIFV
+     SECTION FV_IMAGE = DXEFV
+   }
+ }
+
+!include FvmainCompactScratchEnd.fdf.inc
+
+FILE RAW = 7BB24689-61AB-11D5-9A5D-0090DE4CC14D {
+    SECTION RAW = TestPkg\FakeBinary\FakeBinary.txt
+}
+################################################################################
+
+[Rule.Common.SEC]
+  FILE SEC = $(NAMED_GUID) {
+    PE32     PE32           $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING ="$(MODULE_NAME)" Optional
+    VERSION  STRING ="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.PEI_CORE]
+  FILE PEI_CORE = $(NAMED_GUID) {
+    PE32     PE32   Align=Auto    $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING ="$(MODULE_NAME)" Optional
+    VERSION  STRING ="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.PEIM]
+  FILE PEIM = $(NAMED_GUID) {
+     PEI_DEPEX PEI_DEPEX Optional        $(INF_OUTPUT)/$(MODULE_NAME).depex
+     PE32      PE32   Align=Auto         $(INF_OUTPUT)/$(MODULE_NAME).efi
+     UI       STRING="$(MODULE_NAME)" Optional
+     VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.DXE_CORE]
+  FILE DXE_CORE = $(NAMED_GUID) {
+    PE32     PE32           $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.DXE_DRIVER]
+  FILE DRIVER = $(NAMED_GUID) {
+    DXE_DEPEX    DXE_DEPEX Optional      $(INF_OUTPUT)/$(MODULE_NAME).depex
+    PE32     PE32                    $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+    RAW ACPI  Optional               |.acpi
+    RAW ASL   Optional               |.aml
+  }
+
+[Rule.Common.DXE_RUNTIME_DRIVER]
+  FILE DRIVER = $(NAMED_GUID) {
+    DXE_DEPEX    DXE_DEPEX Optional      $(INF_OUTPUT)/$(MODULE_NAME).depex
+    PE32     PE32                    $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.UEFI_DRIVER]
+  FILE DRIVER = $(NAMED_GUID) {
+    DXE_DEPEX    DXE_DEPEX Optional      $(INF_OUTPUT)/$(MODULE_NAME).depex
+    PE32     PE32                    $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.UEFI_DRIVER.BINARY]
+  FILE DRIVER = $(NAMED_GUID) {
+    DXE_DEPEX DXE_DEPEX Optional      |.depex
+    PE32      PE32                    |.efi
+    UI        STRING="$(MODULE_NAME)" Optional
+    VERSION   STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.UEFI_APPLICATION]
+  FILE APPLICATION = $(NAMED_GUID) {
+    PE32     PE32                    $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.UEFI_APPLICATION.BINARY]
+  FILE APPLICATION = $(NAMED_GUID) {
+    PE32      PE32                    |.efi
+    UI        STRING="$(MODULE_NAME)" Optional
+    VERSION   STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.USER_DEFINED.ACPITABLE]
+  FILE FREEFORM = $(NAMED_GUID) {
+    RAW ACPI               |.acpi
+    RAW ASL                |.aml
+  }
+
+[Rule.Common.USER_DEFINED.CSM]
+  FILE FREEFORM = $(NAMED_GUID) {
+    RAW BIN                |.bin
+  }
+
+[Rule.Common.SEC.RESET_VECTOR]
+  FILE RAW = $(NAMED_GUID) {
+    RAW BIN   Align = 16   |.bin
+  }
+
+[Rule.Common.SMM_CORE]
+  FILE SMM_CORE = $(NAMED_GUID) {
+    PE32     PE32           $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.DXE_SMM_DRIVER]
+  FILE SMM = $(NAMED_GUID) {
+    SMM_DEPEX    SMM_DEPEX Optional      $(INF_OUTPUT)/$(MODULE_NAME).depex
+    PE32     PE32                    $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+[Rule.Common.USER_DEFINED.FAKEBINARY]
+  FILE FREEFORM = $(NAMED_GUID) {
+    RAW BIN               |.txt
+  }
\ No newline at end of file
diff --git a/TestPkg/TestPkg.dec b/TestPkg/TestPkg.dec
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/TestPkg/TestPkgDefines.fdf.inc b/TestPkg/TestPkgDefines.fdf.inc
new file mode 100644
index 0000000000..ae26cdcbdb
--- /dev/null
+++ b/TestPkg/TestPkgDefines.fdf.inc
@@ -0,0 +1,91 @@
+## @file
+#  FDF include file that defines the main macros and sets the dependent PCDs.
+#
+#  Copyright (C) 2014, Red Hat, Inc.
+#  Copyright (c) 2006 - 2013, Intel Corporation. All rights reserved.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+DEFINE BLOCK_SIZE        = 0x1000
+
+#
+# A firmware binary built with FD_SIZE_IN_KB=1024, and a firmware binary built
+# with FD_SIZE_IN_KB=2048, use the same variable store layout.
+#
+# Setting FD_SIZE_IN_KB to 4096 results in a different (much larger) variable
+# store structure that is incompatible with both of the above-mentioned
+# firmware binaries.
+#
+!if ($(FD_SIZE_IN_KB) == 1024) || ($(FD_SIZE_IN_KB) == 2048)
+DEFINE VARS_SIZE         = 0x20000
+DEFINE VARS_BLOCKS       = 0x20
+DEFINE VARS_LIVE_SIZE    = 0xE000
+DEFINE VARS_SPARE_SIZE   = 0x10000
+!endif
+
+!if $(FD_SIZE_IN_KB) == 1024
+DEFINE FW_BASE_ADDRESS   = 0xFFF00000
+DEFINE FW_SIZE           = 0x00100000
+DEFINE FW_BLOCKS         = 0x100
+DEFINE CODE_BASE_ADDRESS = 0xFFF20000
+DEFINE CODE_SIZE         = 0x000E0000
+DEFINE CODE_BLOCKS       = 0xE0
+DEFINE FVMAIN_SIZE       = 0x000CC000
+DEFINE SECFV_OFFSET      = 0x000EC000
+DEFINE SECFV_SIZE        = 0x14000
+!endif
+
+!if $(FD_SIZE_IN_KB) == 2048
+DEFINE FW_BASE_ADDRESS   = 0xFFE00000
+DEFINE FW_SIZE           = 0x00200000
+DEFINE FW_BLOCKS         = 0x200
+DEFINE CODE_BASE_ADDRESS = 0xFFE20000
+DEFINE CODE_SIZE         = 0x001E0000
+DEFINE CODE_BLOCKS       = 0x1E0
+DEFINE FVMAIN_SIZE       = 0x001AC000
+DEFINE SECFV_OFFSET      = 0x001CC000
+DEFINE SECFV_SIZE        = 0x34000
+!endif
+
+!if $(FD_SIZE_IN_KB) == 4096
+DEFINE VARS_SIZE         = 0x84000
+DEFINE VARS_BLOCKS       = 0x84
+DEFINE VARS_LIVE_SIZE    = 0x40000
+DEFINE VARS_SPARE_SIZE   = 0x42000
+
+DEFINE FW_BASE_ADDRESS   = 0xFFC00000
+DEFINE FW_SIZE           = 0x00400000
+DEFINE FW_BLOCKS         = 0x400
+DEFINE CODE_BASE_ADDRESS = 0xFFC84000
+DEFINE CODE_SIZE         = 0x0037C000
+DEFINE CODE_BLOCKS       = 0x37C
+DEFINE FVMAIN_SIZE       = 0x00348000
+DEFINE SECFV_OFFSET      = 0x003CC000
+DEFINE SECFV_SIZE        = 0x34000
+!endif
+
+SET gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFdBaseAddress     = $(FW_BASE_ADDRESS)
+SET gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFirmwareFdSize    = $(FW_SIZE)
+SET gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFirmwareBlockSize = $(BLOCK_SIZE)
+
+SET gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageVariableBase = $(FW_BASE_ADDRESS)
+SET gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize = $(VARS_LIVE_SIZE)
+
+SET gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageEventLogBase = gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageVariableBase + gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize
+SET gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageEventLogSize = $(BLOCK_SIZE)
+
+SET gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageFtwWorkingBase = gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageEventLogBase + gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageEventLogSize
+SET gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingSize = $(BLOCK_SIZE)
+
+SET gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageFtwSpareBase = gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageFtwWorkingBase + gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingSize
+SET gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareSize = $(VARS_SPARE_SIZE)
+
+!if $(SMM_REQUIRE) == TRUE
+SET gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableBase64 = gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageVariableBase
+SET gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingBase = gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageFtwWorkingBase
+SET gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareBase   = gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageFtwSpareBase
+!endif
+
+DEFINE MEMFD_BASE_ADDRESS = 0x800000
diff --git a/TestPkg/TestPkgIA32X64.dsc b/TestPkg/TestPkgIA32X64.dsc
new file mode 100644
index 0000000000..4015dcf745
--- /dev/null
+++ b/TestPkg/TestPkgIA32X64.dsc
@@ -0,0 +1,197 @@
+## @file
+#  EFI/Framework Open Virtual Machine Firmware (OVMF) platform
+#
+#  Copyright (c) 2006 - 2019, Intel Corporation. All rights reserved.<BR>
+#  (C) Copyright 2016 Hewlett Packard Enterprise Development LP<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+################################################################################
+#
+# Defines Section - statements that will be processed to create a Makefile.
+#
+################################################################################
+[Defines]
+  PLATFORM_NAME                  = Ovmf
+  PLATFORM_GUID                  = 5a9e7754-d81b-49ea-85ad-69eaa7b1539b
+  PLATFORM_VERSION               = 0.1
+  DSC_SPECIFICATION              = 0x00010005
+  VPD_TOOL_GUID                  = 8C3D856A-9BE6-468E-850A-24F7A8D38E08
+  OUTPUT_DIRECTORY               = Build/TestPkg3264
+  SUPPORTED_ARCHITECTURES        = IA32|X64
+  BUILD_TARGETS                  = NOOPT|DEBUG|RELEASE
+  SKUID_IDENTIFIER               = DEFAULT
+  FLASH_DEFINITION               = TestPkg/TestIa32X64.fdf
+
+  #
+  # Defines for default states.  These can be changed on the command line.
+  # -D FLAG=VALUE
+  #
+  DEFINE SECURE_BOOT_ENABLE      = FALSE
+  DEFINE SMM_REQUIRE             = FALSE
+  DEFINE SOURCE_DEBUG_ENABLE     = FALSE
+  DEFINE TPM_ENABLE              = FALSE
+  DEFINE TPM_CONFIG_ENABLE       = FALSE
+
+  #
+  # Network definition
+  #
+  DEFINE NETWORK_TLS_ENABLE             = FALSE
+  DEFINE NETWORK_IP6_ENABLE             = FALSE
+  DEFINE NETWORK_HTTP_BOOT_ENABLE       = FALSE
+  DEFINE NETWORK_ALLOW_HTTP_CONNECTIONS = TRUE
+
+!include NetworkPkg/NetworkDefines.dsc.inc
+
+  #
+  # Device drivers
+  #
+  DEFINE PVSCSI_ENABLE           = TRUE
+  DEFINE MPT_SCSI_ENABLE         = TRUE
+
+  #
+  # Flash size selection. Setting FD_SIZE_IN_KB on the command line directly to
+  # one of the supported values, in place of any of the convenience macros, is
+  # permitted.
+  #
+!ifdef $(FD_SIZE_1MB)
+  DEFINE FD_SIZE_IN_KB           = 1024
+!else
+!ifdef $(FD_SIZE_2MB)
+  DEFINE FD_SIZE_IN_KB           = 2048
+!else
+!ifdef $(FD_SIZE_4MB)
+  DEFINE FD_SIZE_IN_KB           = 4096
+!else
+  DEFINE FD_SIZE_IN_KB           = 4096
+!endif
+!endif
+!endif
+
+!include TestPkg/buildoptions.dsc
+
+################################################################################
+#
+# SKU Identification section - list of all SKU IDs supported by this Platform.
+#
+################################################################################
+[SkuIds]
+  0|DEFAULT
+
+!include TestPkg/LibraryClass.dsc
+
+[PcdsDynamicDefault]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSmbiosVersion|0x0208
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSmbiosDocRev|0x0
+  gUefiOvmfPkgTokenSpaceGuid.PcdQemuSmbiosValidated|FALSE
+  gEfiMdePkgTokenSpaceGuid.PcdPlatformBootTimeOut|0
+  # Set memory encryption mask
+  gEfiMdeModulePkgTokenSpaceGuid.PcdPteMemoryEncryptionAddressOrMask|0x0
+
+  # Noexec settings for DXE.
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSetNxForStack|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdEmuVariableNvStoreReserved|0
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuBootLogicalProcessorNumber|0
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuMaxLogicalProcessorNumber|64
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiS3Enable|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdPciDisableBusEnumeration|FALSE
+!if $(SMM_REQUIRE) == FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableBase64|0
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingBase|0
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareBase|0
+!endif
+
+################################################################################
+#
+# Components Section - list of all EDK II Modules needed by this Platform.
+#
+################################################################################
+[Components.IA32]
+  TestPkg/ResetVector/ResetVector.inf
+
+  #
+  # SEC Phase modules
+  #
+  TestPkg\FakeEmuSec\Sec.inf
+  TestPkg/Sec/SecMain.inf {
+    <LibraryClasses>
+    NULL|MdeModulePkg/Library/LzmaCustomDecompressLib/LzmaCustomDecompressLib.inf
+	LockBoxLib|MdeModulePkg\Library\LockBoxNullLib\LockBoxNullLib.inf
+  }
+
+  #
+  # PEI Phase modules
+  #
+  MdeModulePkg/Core/Pei/PeiMain.inf
+  MdeModulePkg/Universal/PCD/Pei/Pcd.inf  {
+    <LibraryClasses>
+      PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
+  }
+
+  MdeModulePkg/Core/DxeIplPeim/DxeIpl.inf
+  UefiCpuPkg\CpuMpPei\CpuMpPei.inf
+#  TestPkg/PlatformPei/PlatformPei.inf
+
+
+[Components.X64]
+  #
+  # DXE Phase modules
+  #
+  MdeModulePkg/Core/Dxe/DxeMain.inf {
+    <LibraryClasses>
+      NULL|MdeModulePkg/Library/LzmaCustomDecompressLib/LzmaCustomDecompressLib.inf
+      DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf
+  }
+  UefiCpuPkg\CpuDxe\CpuDxe.inf
+   
+  MdeModulePkg/Universal/PCD/Dxe/Pcd.inf  {
+   <LibraryClasses>
+      PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
+  }
+
+  MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+
+  MdeModulePkg/Logo/LogoDxe.inf
+  TestPkg\FakeLogo\JpegLogoDxe.inf
+  MdeModulePkg/Application/UiApp/UiApp.inf {
+    <LibraryClasses>
+      NULL|MdeModulePkg/Library/DeviceManagerUiLib/DeviceManagerUiLib.inf
+      NULL|MdeModulePkg/Library/BootManagerUiLib/BootManagerUiLib.inf
+      NULL|MdeModulePkg/Library/BootMaintenanceManagerUiLib/BootMaintenanceManagerUiLib.inf
+!ifdef $(CSM_ENABLE)
+      NULL|TestPkg/Csm/LegacyBootManagerLib/LegacyBootManagerLib.inf
+      NULL|TestPkg/Csm/LegacyBootMaintUiLib/LegacyBootMaintUiLib.inf
+!endif
+  }
+  FatPkg/EnhancedFatDxe/Fat.inf
+  TestPkg/AcpiTables/AcpiTables.inf
+  TestPkg/PlatformDxe/Platform.inf
+  MdeModulePkg\Universal\DevicePathDxe\DevicePathDxe.inf
+
+
+
+################################################################################
+#
+# Pcd Section - list of test EDK II PCD Entries defined by this Platform.
+#
+################################################################################
+[PcdsFeatureFlag]
+gUefiOvmfPkgTokenSpaceGuid.PcdSmmSmramRequire|TRUE
+gEfiMdeModulePkgTokenSpaceGuid.PcdPeiFullPcdDatabaseEnable|TRUE
+
+
+[PcdsFixedAtBuild]
+gEfiMdePkgTokenSpaceGuid.PcdUefiVariableDefaultPlatformLang|"en-US"|VOID*|0x0000001f
+
+[PcdsDynamicDefault]
+gUefiCpuPkgTokenSpaceGuid.PcdCpuMaxLogicalProcessorNumber|64
+
+[PcdsDynamicVpd]
+gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableBase64|0x8000001
+
+[PcdsDynamicHii]
+gEfiMdeModulePkgTokenSpaceGuid.PcdUse1GPageTable|L"1GPageTable"|gEfiGenericVariableGuid|0x0|TRUE
+
+[PcdsDynamicExVpd.common.DEFAULT]
+ gEfiMdeModulePkgTokenSpaceGuid.PcdNvStoreDefaultValueBuffer|*
\ No newline at end of file
diff --git a/TestPkg/VarStore.fdf.inc b/TestPkg/VarStore.fdf.inc
new file mode 100644
index 0000000000..9fcc9eda65
--- /dev/null
+++ b/TestPkg/VarStore.fdf.inc
@@ -0,0 +1,115 @@
+## @file
+#  FDF include file with Layout Regions that define an empty variable store.
+#
+#  Copyright (C) 2014, Red Hat, Inc.
+#  Copyright (c) 2006 - 2013, Intel Corporation. All rights reserved.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+!if ($(FD_SIZE_IN_KB) == 1024) || ($(FD_SIZE_IN_KB) == 2048)
+0x00000000|0x0000e000
+!endif
+!if $(FD_SIZE_IN_KB) == 4096
+0x00000000|0x00040000
+!endif
+#NV_VARIABLE_STORE
+DATA = {
+  ## This is the EFI_FIRMWARE_VOLUME_HEADER
+  # ZeroVector []
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  # FileSystemGuid: gEfiSystemNvDataFvGuid         =
+  #   { 0xFFF12B8D, 0x7696, 0x4C8B,
+  #     { 0xA9, 0x85, 0x27, 0x47, 0x07, 0x5B, 0x4F, 0x50 }}
+  0x8D, 0x2B, 0xF1, 0xFF, 0x96, 0x76, 0x8B, 0x4C,
+  0xA9, 0x85, 0x27, 0x47, 0x07, 0x5B, 0x4F, 0x50,
+!if ($(FD_SIZE_IN_KB) == 1024) || ($(FD_SIZE_IN_KB) == 2048)
+  # FvLength: 0x20000
+  0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
+!endif
+!if $(FD_SIZE_IN_KB) == 4096
+  # FvLength: 0x84000
+  0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
+!endif
+  # Signature "_FVH"       # Attributes
+  0x5f, 0x46, 0x56, 0x48, 0xff, 0xfe, 0x04, 0x00,
+  # HeaderLength
+  0x48, 0x00,
+!if ($(FD_SIZE_IN_KB) == 1024) || ($(FD_SIZE_IN_KB) == 2048)
+  # CheckSum
+  0x19, 0xF9,
+!endif
+!if $(FD_SIZE_IN_KB) == 4096
+  # CheckSum
+  0xAF, 0xB8,
+!endif
+  # ExtHeaderOffset #Reserved #Revision
+  0x00, 0x00, 0x00, 0x02,
+!if ($(FD_SIZE_IN_KB) == 1024) || ($(FD_SIZE_IN_KB) == 2048)
+  # Blockmap[0]: 0x20 Blocks * 0x1000 Bytes / Block
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
+!endif
+!if $(FD_SIZE_IN_KB) == 4096
+  # Blockmap[0]: 0x84 Blocks * 0x1000 Bytes / Block
+  0x84, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
+!endif
+  # Blockmap[1]: End
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  ## This is the VARIABLE_STORE_HEADER
+  # It is compatible with SECURE_BOOT_ENABLE == FALSE as well.
+  # Signature: gEfiAuthenticatedVariableGuid =
+  #   { 0xaaf32c78, 0x947b, 0x439a,
+  #     { 0xa1, 0x80, 0x2e, 0x14, 0x4e, 0xc3, 0x77, 0x92 }}
+  0x78, 0x2c, 0xf3, 0xaa, 0x7b, 0x94, 0x9a, 0x43,
+  0xa1, 0x80, 0x2e, 0x14, 0x4e, 0xc3, 0x77, 0x92,
+!if ($(FD_SIZE_IN_KB) == 1024) || ($(FD_SIZE_IN_KB) == 2048)
+  # Size: 0xe000 (gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize) -
+  #         0x48 (size of EFI_FIRMWARE_VOLUME_HEADER) = 0xdfb8
+  # This can speed up the Variable Dispatch a bit.
+  0xB8, 0xDF, 0x00, 0x00,
+!endif
+!if $(FD_SIZE_IN_KB) == 4096
+  # Size: 0x40000 (gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize) -
+  #          0x48 (size of EFI_FIRMWARE_VOLUME_HEADER) = 0x3ffb8
+  # This can speed up the Variable Dispatch a bit.
+  0xB8, 0xFF, 0x03, 0x00,
+!endif
+  # FORMATTED: 0x5A #HEALTHY: 0xFE #Reserved: UINT16 #Reserved1: UINT32
+  0x5A, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+}
+
+!if ($(FD_SIZE_IN_KB) == 1024) || ($(FD_SIZE_IN_KB) == 2048)
+0x0000e000|0x00001000
+!endif
+!if $(FD_SIZE_IN_KB) == 4096
+0x00040000|0x00001000
+!endif
+#NV_EVENT_LOG
+
+!if ($(FD_SIZE_IN_KB) == 1024) || ($(FD_SIZE_IN_KB) == 2048)
+0x0000f000|0x00001000
+!endif
+!if $(FD_SIZE_IN_KB) == 4096
+0x00041000|0x00001000
+!endif
+#NV_FTW_WORKING
+DATA = {
+  # EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER->Signature = gEdkiiWorkingBlockSignatureGuid         =
+  #  { 0x9e58292b, 0x7c68, 0x497d, { 0xa0, 0xce, 0x65,  0x0, 0xfd, 0x9f, 0x1b, 0x95 }}
+  0x2b, 0x29, 0x58, 0x9e, 0x68, 0x7c, 0x7d, 0x49,
+  0xa0, 0xce, 0x65,  0x0, 0xfd, 0x9f, 0x1b, 0x95,
+  # Crc:UINT32            #WorkingBlockValid:1, WorkingBlockInvalid:1, Reserved
+  0x2c, 0xaf, 0x2c, 0x64, 0xFE, 0xFF, 0xFF, 0xFF,
+  # WriteQueueSize: UINT64
+  0xE0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+}
+
+!if ($(FD_SIZE_IN_KB) == 1024) || ($(FD_SIZE_IN_KB) == 2048)
+0x00010000|0x00010000
+!endif
+!if $(FD_SIZE_IN_KB) == 4096
+0x00042000|0x00042000
+!endif
+#NV_FTW_SPARE
diff --git a/TestPkg/buildoptions.dsc b/TestPkg/buildoptions.dsc
new file mode 100644
index 0000000000..9ca9e101ff
--- /dev/null
+++ b/TestPkg/buildoptions.dsc
@@ -0,0 +1,42 @@
+[BuildOptions]
+  GCC:RELEASE_*_*_CC_FLAGS             = -DMDEPKG_NDEBUG
+  INTEL:RELEASE_*_*_CC_FLAGS           = /D MDEPKG_NDEBUG
+  MSFT:RELEASE_*_*_CC_FLAGS            = /D MDEPKG_NDEBUG
+!if $(TOOL_CHAIN_TAG) != "XCODE5" && $(TOOL_CHAIN_TAG) != "CLANGPDB"
+  GCC:*_*_*_CC_FLAGS                   = -mno-mmx -mno-sse
+!endif
+!if $(SOURCE_DEBUG_ENABLE) == TRUE
+  MSFT:*_*_X64_GENFW_FLAGS  = --keepexceptiontable
+  GCC:*_*_X64_GENFW_FLAGS   = --keepexceptiontable
+  INTEL:*_*_X64_GENFW_FLAGS = --keepexceptiontable
+!endif
+
+  #
+  # Disable deprecated APIs.
+  #
+  MSFT:*_*_*_CC_FLAGS = /D DISABLE_NEW_DEPRECATED_INTERFACES
+  INTEL:*_*_*_CC_FLAGS = /D DISABLE_NEW_DEPRECATED_INTERFACES
+  GCC:*_*_*_CC_FLAGS = -D DISABLE_NEW_DEPRECATED_INTERFACES
+
+[BuildOptions.common.EDKII.DXE_RUNTIME_DRIVER]
+  GCC:*_*_*_DLINK_FLAGS = -z common-page-size=0x1000
+  XCODE:*_*_*_DLINK_FLAGS = -seg1addr 0x1000 -segalign 0x1000
+  XCODE:*_*_*_MTOC_FLAGS = -align 0x1000
+  CLANGPDB:*_*_*_DLINK_FLAGS = /ALIGN:4096
+
+# Force PE/COFF sections to be aligned at 4KB boundaries to support page level
+# protection of DXE_SMM_DRIVER/SMM_CORE modules
+[BuildOptions.common.EDKII.DXE_SMM_DRIVER, BuildOptions.common.EDKII.SMM_CORE]
+  GCC:*_*_*_DLINK_FLAGS = -z common-page-size=0x1000
+  XCODE:*_*_*_DLINK_FLAGS = -seg1addr 0x1000 -segalign 0x1000
+  XCODE:*_*_*_MTOC_FLAGS = -align 0x1000
+  CLANGPDB:*_*_*_DLINK_FLAGS = /ALIGN:4096
+  
+[BuildOptions.IA32]
+  RELEASE_MYTOOLS_IA32_CC_FLAGS        = /D MDEPKG_NDEBUG
+
+[BuildOptions.IA32.EDKII.PEIM]
+  GCC:*_*_*_DLINK_FLAGS = -z common-page-size=0x1000
+  
+[BuildOptions.common.EDKII.BASE]
+  MSFT:RELEASE_*_*_CC_FLAGS            = /D MDEPKG_NDEBUG
\ No newline at end of file
diff --git a/TestPkg/iasl_ext_dep.yaml b/TestPkg/iasl_ext_dep.yaml
new file mode 100644
index 0000000000..af0270d8f8
--- /dev/null
+++ b/TestPkg/iasl_ext_dep.yaml
@@ -0,0 +1,21 @@
+## @file
+# Download iasl executable tool from a nuget.org package
+# - package contains different binaries based on host
+# Add the folder with the tool to the path
+#
+# This is only downloaded for scope cibuild thus
+# should have no impact on the asl compiler used by any
+# given platform to build.
+#
+# Copyright (c) Microsoft Corporation.
+# SPDX-License-Identifier: BSD-2-Clause-Patent
+##
+{
+  "id": "iasl-testpkg-1",
+  "scope": "testpkg",
+  "type": "nuget",
+  "name": "iasl",
+  "source": "https://api.nuget.org/v3/index.json",
+  "version": "20190215.0.0",
+  "flags": ["set_path", "host_specific"]
+}
diff --git a/TestPkg/modulelist.txt b/TestPkg/modulelist.txt
new file mode 100644
index 0000000000..0a87c14f3d
--- /dev/null
+++ b/TestPkg/modulelist.txt
@@ -0,0 +1,37 @@
+PEIM
+MdeModulePkg\Core\DxeIplPeim\DxeIpl.inf
+MdeModulePkg\Universal\PCD\Pei\Pcd.inf
+UefiCpuPkg\Library\MpInitLib\PeiMpInitLib.inf
+MdePkg\Library\PeiPcdLib\PeiPcdLib.inf
+
+SEC
+OvmfPkg\Sec\SecMain.inf
+OvmfPkg\ResetVector\ResetVector.inf
+
+PEICORE
+MdeModulePkg\Core\Pei\PeiMain.inf
+MdePkg\Library\PeiCoreEntryPoint\PeiCoreEntryPoint.inf
+
+UEFI_APPLICATION
+MdeModulePkg\Application\UiApp\UiApp.inf
+
+BASE
+libraries
+
+DXE_DRIVER
+MdeModulePkg\Universal\PCD\Dxe\Pcd.inf
+
+DXE_CORE
+MdePkg\Library\DxeCoreHobLib\DxeCoreHobLib.inf
+MdePkg\Library\DxeCoreEntryPoint\DxeCoreEntryPoint.inf
+MdeModulePkg\Core\Dxe\DxeMain.inf
+MdeModulePkg\Library\DxeCoreMemoryAllocationLib\DxeCoreMemoryAllocationLib.inf
+
+DXE_RUNTIME_DRIVER
+MdeModulePkg\Core\RuntimeDxe\RuntimeDxe.inf
+
+UEFI_DRIVER
+FatPkg\EnhancedFatDxe\Fat.inf
+
+USER_DEFINED
+OvmfPkg\AcpiTables\AcpiTables.inf
\ No newline at end of file
-- 
2.18.0.windows.1

