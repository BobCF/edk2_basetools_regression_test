From 07babbb068472445a114bb9749096170813305bb Mon Sep 17 00:00:00 2001
From: Bob Feng <bob.c.feng@intel.com>
Date: Mon, 23 Nov 2020 16:59:59 +0800
Subject: [Patch 11/12] 1. Support for UNI test cases. 2. Support for Add &
 Delete test cases. 1.ASL 2.ASM 3.NASM 3. Support for edk2 test cases: 1. Add
 - C, H, UNI 2.Modify - H include H, NASM include H

Signed-off-by: Bob Feng <bob.c.feng@intel.com>
---
 TestPkg/AcpiTables/ForAddTest.asi      |  33 +
 TestPkg/AcpiTables/ForAddTest.asl      | 704 ++++++++++++++++++++
 TestPkg/AcpiTables/ForAddTest.h        |  11 +
 TestPkg/AcpiTables/ForHIncludedH.h     |  10 +
 TestPkg/FakeEmuSec/Ia32/ForAddTest.asm |  20 +
 TestPkg/LibraryClass.dsc               |   1 +
 TestPkg/PlatformDxe/FirstTestFile.h    |   9 +
 TestPkg/PlatformDxe/ForAddTest.hfr     |  16 +
 TestPkg/PlatformDxe/JustATest.uni      | Bin 0 -> 904 bytes
 TestPkg/PlatformDxe/Platform.c         | 869 +++++++++++++++++++++++++
 TestPkg/PlatformDxe/Platform.h         |  37 ++
 TestPkg/PlatformDxe/Platform.inf       |  64 ++
 TestPkg/PlatformDxe/Platform.uni       |  28 +
 TestPkg/PlatformDxe/PlatformConfig.c   | 125 ++++
 TestPkg/PlatformDxe/PlatformConfig.h   |  53 ++
 TestPkg/PlatformDxe/PlatformForms.vfr  |  67 ++
 TestPkg/PlatformDxe/SecondTestFile.h   |   9 +
 TestPkg/PlatformDxe/ThirdTestFile.uni  | Bin 0 -> 950 bytes
 TestPkg/Sec/Ia32/ForHAddTest.h         |   9 +
 TestPkg/Sec/Ia32/ForHAddTest.inc       |   9 +
 TestPkg/Sec/Ia32/ForNASMIncludeH.h     |  10 +
 TestPkg/TestIa32X64.fdf                |   1 +
 TestPkg/TestPkg32X64.dsc               |   1 +
 23 files changed, 2086 insertions(+)
 create mode 100644 TestPkg/AcpiTables/ForAddTest.asi
 create mode 100644 TestPkg/AcpiTables/ForAddTest.asl
 create mode 100644 TestPkg/AcpiTables/ForAddTest.h
 create mode 100644 TestPkg/AcpiTables/ForHIncludedH.h
 create mode 100644 TestPkg/FakeEmuSec/Ia32/ForAddTest.asm
 create mode 100644 TestPkg/PlatformDxe/FirstTestFile.h
 create mode 100644 TestPkg/PlatformDxe/ForAddTest.hfr
 create mode 100644 TestPkg/PlatformDxe/JustATest.uni
 create mode 100644 TestPkg/PlatformDxe/Platform.c
 create mode 100644 TestPkg/PlatformDxe/Platform.h
 create mode 100644 TestPkg/PlatformDxe/Platform.inf
 create mode 100644 TestPkg/PlatformDxe/Platform.uni
 create mode 100644 TestPkg/PlatformDxe/PlatformConfig.c
 create mode 100644 TestPkg/PlatformDxe/PlatformConfig.h
 create mode 100644 TestPkg/PlatformDxe/PlatformForms.vfr
 create mode 100644 TestPkg/PlatformDxe/SecondTestFile.h
 create mode 100644 TestPkg/PlatformDxe/ThirdTestFile.uni
 create mode 100644 TestPkg/Sec/Ia32/ForHAddTest.h
 create mode 100644 TestPkg/Sec/Ia32/ForHAddTest.inc
 create mode 100644 TestPkg/Sec/Ia32/ForNASMIncludeH.h

diff --git a/TestPkg/AcpiTables/ForAddTest.asi b/TestPkg/AcpiTables/ForAddTest.asi
new file mode 100644
index 0000000000..dbec6c9e7a
--- /dev/null
+++ b/TestPkg/AcpiTables/ForAddTest.asi
@@ -0,0 +1,33 @@
+/** @file
+
+  @copyright
+  INTEL CONFIDENTIAL
+  Copyright 2018 - 2019 Intel Corporation. <BR>
+
+  The source code contained or described herein and all documents related to the
+  source code ("Material") are owned by Intel Corporation or its suppliers or
+  licensors. Title to the Material remains with Intel Corporation or its suppliers
+  and licensors. The Material may contain trade secrets and proprietary    and
+  confidential information of Intel Corporation and its suppliers and licensors,
+  and is protected by worldwide copyright and trade secret laws and treaty
+  provisions. No part of the Material may be used, copied, reproduced, modified,
+  published, uploaded, posted, transmitted, distributed, or disclosed in any way
+  without Intel's prior express written permission.
+
+  No license under any patent, copyright, trade secret or other intellectual
+  property right is granted to or conferred upon you by disclosure or delivery
+  of the Materials, either expressly, by implication, inducement, estoppel or
+  otherwise. Any license under such intellectual property rights must be
+  express and approved by Intel in writing.
+
+  Unless otherwise agreed by Intel in writing, you may not remove or alter
+  this notice or any other notice embedded in Materials by Intel or
+  Intel's suppliers or licensors in any way.
+**/
+
+
+#define MaxRangeForAddTest 0xFEFF
+#define RangeLengthForAddTest 0xF200
+
+
+
diff --git a/TestPkg/AcpiTables/ForAddTest.asl b/TestPkg/AcpiTables/ForAddTest.asl
new file mode 100644
index 0000000000..b74999068f
--- /dev/null
+++ b/TestPkg/AcpiTables/ForAddTest.asl
@@ -0,0 +1,704 @@
+/** @file
+  ACPI DSDT table
+
+  @copyright
+  INTEL CONFIDENTIAL
+  Copyright 2011 - 2014 Intel Corporation. <BR>
+
+  The source code contained or described herein and all documents related to the
+  source code ("Material") are owned by Intel Corporation or its suppliers or
+  licensors. Title to the Material remains with Intel Corporation or its suppliers
+  and licensors. The Material may contain trade secrets and proprietary    and
+  confidential information of Intel Corporation and its suppliers and licensors,
+  and is protected by worldwide copyright and trade secret laws and treaty
+  provisions. No part of the Material may be used, copied, reproduced, modified,
+  published, uploaded, posted, transmitted, distributed, or disclosed in any way
+  without Intel's prior express written permission.
+
+  No license under any patent, copyright, trade secret or other intellectual
+  property right is granted to or conferred upon you by disclosure or delivery
+  of the Materials, either expressly, by implication, inducement, estoppel or
+  otherwise. Any license under such intellectual property rights must be
+  express and approved by Intel in writing.
+
+  Unless otherwise agreed by Intel in writing, you may not remove or alter
+  this notice or any other notice embedded in Materials by Intel or
+  Intel's suppliers or licensors in any way.
+**/
+
+//
+// PCI IRQ Link D
+//
+//
+  //  System Bus
+  //
+  Scope (\_SB) {
+    //
+    // PCI Root Bridge
+    //
+    Device (PCI0) {
+      Name (_HID, EISAID ("PNP0A03"))
+      Name (_ADR, 0x00000000)
+      Name (_BBN, 0x00)
+      Name (_UID, 0x00)
+
+      //
+      // BUS, I/O, and MMIO resources
+      //
+      Name (CRES, ResourceTemplate () {
+        WORDBusNumber (          // Bus number resource (0); the bridge produces bus numbers for its subsequent buses
+          ResourceProducer,      // bit 0 of general flags is 1
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is fixed
+          PosDecode,             // PosDecode
+          0x0000,                // Granularity
+          0x0000,                // Min
+          0x00FF,                // Max
+          0x0000,                // Translation
+          0x0100                 // Range Length = Max-Min+1
+          )
+
+        IO (Decode16, 0xCF8, 0xCF8, 0x01, 0x08)       //Consumed resource (0xCF8-0xCFF)
+
+        WORDIO (                 // Consumed-and-produced resource (all I/O below CF8)
+          ResourceProducer,      // bit 0 of general flags is 0
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is fixed
+          PosDecode,
+          EntireRange,
+          0x0000,                // Granularity
+          0x0000,                // Min
+          0x0CF7,                // Max
+          0x0000,                // Translation
+          0x0CF8                 // Range Length
+          )
+
+        WORDIO (                 // Consumed-and-produced resource (all I/O above CFF)
+          ResourceProducer,      // bit 0 of general flags is 0
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is fixed
+          PosDecode,
+          EntireRange,
+          0x0000,                // Granularity
+          0x0D00,                // Min
+          0xFFFF,                // Max
+          0x0000,                // Translation
+          0xF300                 // Range Length
+          )
+
+        DWORDMEMORY (            // Descriptor for legacy VGA video RAM
+          ResourceProducer,      // bit 0 of general flags is 0
+          PosDecode,
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is Fixed
+          Cacheable,
+          ReadWrite,
+          0x00000000,            // Granularity
+          0x000A0000,            // Min
+          MAX_DWORDMEMORY,       // Max
+          0x00000000,            // Translation
+          0x00020000             // Range Length
+          )
+
+        DWORDMEMORY (            // Descriptor for 32-bit MMIO
+          ResourceProducer,      // bit 0 of general flags is 0
+          PosDecode,
+          MinFixed,              // Range is fixed
+          MaxFixed,              // Range is Fixed
+          NonCacheable,
+          ReadWrite,
+          0x00000000,            // Granularity
+          0xF8000000,            // Min
+          0xFFFBFFFF,            // Max
+          0x00000000,            // Translation
+          0x07FC0000,            // Range Length
+          ,                      // ResourceSourceIndex
+          ,                      // ResourceSource
+          PW32                   // DescriptorName
+          )
+      })
+
+      Name (CR64, ResourceTemplate () {
+        QWordMemory (            // Descriptor for 64-bit MMIO
+            ResourceProducer,    // bit 0 of general flags is 0
+            PosDecode,
+            MinFixed,            // Range is fixed
+            MaxFixed,            // Range is Fixed
+            Cacheable,
+            ReadWrite,
+            0x00000000,          // Granularity
+            0x8000000000,        // Min
+            MAX_QWordMemory,     // Max
+            0x00000000,          // Translation
+            0x8000000000,        // Range Length
+            ,                    // ResourceSourceIndex
+            ,                    // ResourceSource
+            PW64                 // DescriptorName
+            )
+      })
+
+      Method (_CRS, 0, Serialized) {
+        //
+        // see the FIRMWARE_DATA structure in "OvmfPkg/AcpiPlatformDxe/Qemu.c"
+        //
+        External (FWDT, OpRegionObj)
+        Field(FWDT, QWordAcc, NoLock, Preserve) {
+          P0S, 64,               // PciWindow32.Base
+          P0E, 64,               // PciWindow32.End
+          P0L, 64,               // PciWindow32.Length
+          P1S, 64,               // PciWindow64.Base
+          P1E, 64,               // PciWindow64.End
+          P1L, 64                // PciWindow64.Length
+        }
+        Field(FWDT, DWordAcc, NoLock, Preserve) {
+          P0SL, 32,              // PciWindow32.Base,   low  32 bits
+          P0SH, 32,              // PciWindow32.Base,   high 32 bits
+          P0EL, 32,              // PciWindow32.End,    low  32 bits
+          P0EH, 32,              // PciWindow32.End,    high 32 bits
+          P0LL, 32,              // PciWindow32.Length, low  32 bits
+          P0LH, 32,              // PciWindow32.Length, high 32 bits
+          P1SL, 32,              // PciWindow64.Base,   low  32 bits
+          P1SH, 32,              // PciWindow64.Base,   high 32 bits
+          P1EL, 32,              // PciWindow64.End,    low  32 bits
+          P1EH, 32,              // PciWindow64.End,    high 32 bits
+          P1LL, 32,              // PciWindow64.Length, low  32 bits
+          P1LH, 32               // PciWindow64.Length, high 32 bits
+        }
+
+        //
+        // fixup 32-bit PCI IO window
+        //
+        CreateDWordField (CRES, \_SB.PCI0.PW32._MIN, PS32)
+        CreateDWordField (CRES, \_SB.PCI0.PW32._MAX, PE32)
+        CreateDWordField (CRES, \_SB.PCI0.PW32._LEN, PL32)
+        Store (P0SL, PS32)
+        Store (P0EL, PE32)
+        Store (P0LL, PL32)
+
+        If (LAnd (LEqual (P1SL, 0x00), LEqual (P1SH, 0x00))) {
+          Return (CRES)
+        } Else {
+          //
+          // fixup 64-bit PCI IO window
+          //
+          CreateQWordField (CR64, \_SB.PCI0.PW64._MIN, PS64)
+          CreateQWordField (CR64, \_SB.PCI0.PW64._MAX, PE64)
+          CreateQWordField (CR64, \_SB.PCI0.PW64._LEN, PL64)
+          Store (P1S, PS64)
+          Store (P1E, PE64)
+          Store (P1L, PL64)
+
+          //
+          // add window and return result
+          //
+          ConcatenateResTemplate (CRES, CR64, Local0)
+          Return (Local0)
+        }
+      }
+
+      //
+      // PCI Interrupt Routing Table - PIC Mode Only
+      //
+      Method (_PRT, 0, NotSerialized) {
+        Return (
+          Package () {
+            //
+            // Bus 0; Devices 0 to 15
+            //
+            Package () {0x0000FFFF, 0x00, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0000FFFF, 0x01, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0000FFFF, 0x02, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0000FFFF, 0x03, \_SB.PCI0.LPC.LNKC, 0x00},
+
+            //
+            // Bus 0, Device 1, Pin 0 (INTA) is special; it corresponds to the
+            // internally generated SCI (System Control Interrupt), which is
+            // always routed to GSI 9. By setting the third (= Source) field to
+            // zero, we could use the fourth (= Source Index) field to hardwire
+            // the pin to GSI 9 directly.
+            //
+            // That way however, in accordance with the ACPI spec's description
+            // of SCI, the interrupt would be treated as "active low,
+            // shareable, level", and that doesn't match qemu.
+            //
+            // In QemuInstallAcpiMadtTable() [OvmfPkg/AcpiPlatformDxe/Qemu.c]
+            // we install an Interrupt Override Structure for the identity
+            // mapped IRQ#9 / GSI 9 (the corresponding bit being set in
+            // Pcd8259LegacyModeEdgeLevel), which describes the correct
+            // polarity (active high). As a consequence, some OS'en (eg. Linux)
+            // override the default (active low) polarity originating from the
+            // _PRT; others (eg. FreeBSD) don't. Therefore we need a separate
+            // link device just to specify a polarity that matches the MADT.
+            //
+            Package () {0x0001FFFF, 0x00, \_SB.PCI0.LPC.LNKS, 0x00},
+
+            Package () {0x0001FFFF, 0x01, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0001FFFF, 0x02, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0001FFFF, 0x03, \_SB.PCI0.LPC.LNKD, 0x00},
+
+            Package () {0x0002FFFF, 0x00, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0002FFFF, 0x01, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0002FFFF, 0x02, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0002FFFF, 0x03, \_SB.PCI0.LPC.LNKA, 0x00},
+
+            Package () {0x0003FFFF, 0x00, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0003FFFF, 0x01, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0003FFFF, 0x02, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0003FFFF, 0x03, \_SB.PCI0.LPC.LNKB, 0x00},
+
+            Package () {0x0004FFFF, 0x00, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0004FFFF, 0x01, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0004FFFF, 0x02, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0004FFFF, 0x03, \_SB.PCI0.LPC.LNKC, 0x00},
+
+            Package () {0x0005FFFF, 0x00, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0005FFFF, 0x01, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0005FFFF, 0x02, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0005FFFF, 0x03, \_SB.PCI0.LPC.LNKD, 0x00},
+
+            Package () {0x0006FFFF, 0x00, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0006FFFF, 0x01, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0006FFFF, 0x02, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0006FFFF, 0x03, \_SB.PCI0.LPC.LNKA, 0x00},
+
+            Package () {0x0007FFFF, 0x00, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0007FFFF, 0x01, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0007FFFF, 0x02, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0007FFFF, 0x03, \_SB.PCI0.LPC.LNKB, 0x00},
+
+            Package () {0x0008FFFF, 0x00, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x0008FFFF, 0x01, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0008FFFF, 0x02, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0008FFFF, 0x03, \_SB.PCI0.LPC.LNKC, 0x00},
+
+            Package () {0x0009FFFF, 0x00, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x0009FFFF, 0x01, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x0009FFFF, 0x02, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x0009FFFF, 0x03, \_SB.PCI0.LPC.LNKD, 0x00},
+
+            Package () {0x000AFFFF, 0x00, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x000AFFFF, 0x01, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000AFFFF, 0x02, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000AFFFF, 0x03, \_SB.PCI0.LPC.LNKA, 0x00},
+
+            Package () {0x000BFFFF, 0x00, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000BFFFF, 0x01, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000BFFFF, 0x02, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x000BFFFF, 0x03, \_SB.PCI0.LPC.LNKB, 0x00},
+
+            Package () {0x000CFFFF, 0x00, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000CFFFF, 0x01, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x000CFFFF, 0x02, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x000CFFFF, 0x03, \_SB.PCI0.LPC.LNKC, 0x00},
+
+            Package () {0x000DFFFF, 0x00, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x000DFFFF, 0x01, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x000DFFFF, 0x02, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000DFFFF, 0x03, \_SB.PCI0.LPC.LNKD, 0x00},
+
+            Package () {0x000EFFFF, 0x00, \_SB.PCI0.LPC.LNKB, 0x00},
+            Package () {0x000EFFFF, 0x01, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000EFFFF, 0x02, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000EFFFF, 0x03, \_SB.PCI0.LPC.LNKA, 0x00},
+
+            Package () {0x000FFFFF, 0x00, \_SB.PCI0.LPC.LNKC, 0x00},
+            Package () {0x000FFFFF, 0x01, \_SB.PCI0.LPC.LNKD, 0x00},
+            Package () {0x000FFFFF, 0x02, \_SB.PCI0.LPC.LNKA, 0x00},
+            Package () {0x000FFFFF, 0x03, \_SB.PCI0.LPC.LNKB, 0x00}
+          }
+        )
+      }
+
+      //
+      // PCI to ISA Bridge (Bus 0, Device 1, Function 0)
+      // "Low Pin Count"
+      //
+      Device (LPC) {
+        Name (_ADR, 0x00010000)
+
+        //
+        // The SCI cannot be rerouted or disabled with PIRQRC[A:D]; we only
+        // need this link device in order to specify the polarity.
+        //
+        Device (LNKS) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 0)
+
+          Name (_STA, 0xB) // 0x1: device present
+                           // 0x2: enabled and decoding resources
+                           // 0x8: functioning properly
+
+          Method (_SRS, 1, NotSerialized) { /* no-op */ }
+          Method (_DIS, 0, NotSerialized) { /* no-op */ }
+
+          Name (_PRS, ResourceTemplate () {
+            Interrupt (ResourceConsumer, Level, ActiveHigh, Shared) { 9 }
+            //
+            // list of IRQs occupied thus far: 9
+            //
+          })
+          Method (_CRS, 0, NotSerialized) { Return (_PRS) }
+        }
+
+        //
+        // PCI Interrupt Routing Configuration Registers, PIRQRC[A:D]
+        //
+        OperationRegion (PRR0, PCI_Config, 0x60, 0x04)
+        Field (PRR0, ANYACC, NOLOCK, PRESERVE) {
+          PIRA, 8,
+          PIRB, 8,
+          PIRC, 8,
+          PIRD, 8
+        }
+
+        //
+        // _STA method for LNKA, LNKB, LNKC, LNKD
+        // Arg0[in]: value of PIRA / PIRB / PIRC / PIRD
+        //
+        Method (PSTA, 1, NotSerialized) {
+          If (And (Arg0, 0x80)) { // disable-bit set?
+            Return (0x9)          // "device present" | "functioning properly"
+          } Else {
+            Return (0xB)          // same | "enabled and decoding resources"
+          }
+        }
+
+        //
+        // _CRS method for LNKA, LNKB, LNKC, LNKD
+        // Arg0[in]: value of PIRA / PIRB / PIRC / PIRD
+        //
+        Method (PCRS, 1, Serialized) {
+          //
+          // create temporary buffer with an Extended Interrupt Descriptor
+          // whose single vector defaults to zero
+          //
+          Name (BUF0, ResourceTemplate () {
+              Interrupt (ResourceConsumer, Level, ActiveHigh, Shared){0}
+            }
+          )
+
+          //
+          // define reference to first interrupt vector in buffer
+          //
+          CreateDWordField (BUF0, 0x05, IRQW)
+
+          //
+          // If the disable-bit is clear, overwrite the default zero vector
+          // with the value in Arg0 (ie. PIRQRC[A:D]). Reserved bits are read
+          // as 0.
+          //
+          If (LNot (And (Arg0, 0x80))) {
+            Store (Arg0, IRQW)
+          }
+          Return (BUF0)
+        }
+
+        //
+        // _PRS resource for LNKA, LNKB, LNKC, LNKD
+        //
+        Name (PPRS, ResourceTemplate () {
+          Interrupt (ResourceConsumer, Level, ActiveHigh, Shared) {5, 10, 11}
+          //
+          // list of IRQs occupied thus far: 9, 5, 10, 11
+          //
+        })
+
+        //
+        // PCI IRQ Link A
+        //
+        Device (LNKA) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 1)
+
+          Method (_STA, 0, NotSerialized) { Return (PSTA (PIRA)) }
+          Method (_DIS, 0, NotSerialized) {
+            Or (PIRA, 0x80, PIRA) // set disable-bit
+          }
+          Method (_CRS, 0, NotSerialized) { Return (PCRS (PIRA)) }
+          Method (_PRS, 0, NotSerialized) { Return (PPRS) }
+          Method (_SRS, 1, NotSerialized) {
+            CreateDWordField (Arg0, 0x05, IRQW)
+            Store (IRQW, PIRA)
+          }
+        }
+
+        //
+        // PCI IRQ Link B
+        //
+        Device (LNKB) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 2)
+
+          Method (_STA, 0, NotSerialized) { Return (PSTA (PIRB)) }
+          Method (_DIS, 0, NotSerialized) {
+            Or (PIRB, 0x80, PIRB) // set disable-bit
+          }
+          Method (_CRS, 0, NotSerialized) { Return (PCRS (PIRB)) }
+          Method (_PRS, 0, NotSerialized) { Return (PPRS) }
+          Method (_SRS, 1, NotSerialized) {
+            CreateDWordField (Arg0, 0x05, IRQW)
+            Store (IRQW, PIRB)
+          }
+        }
+
+        //
+        // PCI IRQ Link C
+        //
+        Device (LNKC) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 3)
+
+          Method (_STA, 0, NotSerialized) { Return (PSTA (PIRC)) }
+          Method (_DIS, 0, NotSerialized) {
+            Or (PIRC, 0x80, PIRC) // set disable-bit
+          }
+          Method (_CRS, 0, NotSerialized) { Return (PCRS (PIRC)) }
+          Method (_PRS, 0, NotSerialized) { Return (PPRS) }
+          Method (_SRS, 1, NotSerialized) {
+            CreateDWordField (Arg0, 0x05, IRQW)
+            Store (IRQW, PIRC)
+          }
+        }
+
+        //
+        // PCI IRQ Link D
+        //
+        Device (LNKD) {
+          Name (_HID, EISAID("PNP0C0F"))
+          Name (_UID, 4)
+
+          Method (_STA, 0, NotSerialized) { Return (PSTA (PIRD)) }
+          Method (_DIS, 0, NotSerialized) {
+            Or (PIRD, 0x80, PIRD) // set disable-bit
+          }
+          Method (_CRS, 0, NotSerialized) { Return (PCRS (PIRD)) }
+          Method (_PRS, 0, NotSerialized) { Return (PPRS) }
+          Method (_SRS, 1, NotSerialized) {
+            CreateDWordField (Arg0, 0x05, IRQW)
+            Store (IRQW, PIRD)
+          }
+        }
+
+        //
+        // Programmable Interrupt Controller (PIC)
+        //
+        Device(PIC) {
+          Name (_HID, EISAID ("PNP0000"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x020, 0x020, 0x00, 0x02)
+            IO (Decode16, 0x0A0, 0x0A0, 0x00, 0x02)
+            IO (Decode16, 0x4D0, 0x4D0, 0x00, 0x02)
+            IRQNoFlags () {2}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2
+            //
+          })
+        }
+
+        //
+        // ISA DMA
+        //
+        Device (DMAC) {
+          Name (_HID, EISAID ("PNP0200"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x00, 0x00, 0, 0x10)
+            IO (Decode16, 0x81, 0x81, 0, 0x03)
+            IO (Decode16, 0x87, 0x87, 0, 0x01)
+            IO (Decode16, 0x89, 0x89, 0, 0x03)
+            IO (Decode16, 0x8f, 0x8f, 0, 0x01)
+            IO (Decode16, 0xc0, 0xc0, 0, 0x20)
+            DMA (Compatibility, NotBusMaster, Transfer8) {4}
+          })
+        }
+
+        //
+        // 8254 Timer
+        //
+        Device(TMR) {
+          Name(_HID,EISAID("PNP0100"))
+          Name(_CRS, ResourceTemplate () {
+            IO (Decode16, 0x40, 0x40, 0x00, 0x04)
+            IRQNoFlags () {0}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2, 0
+            //
+          })
+        }
+
+        //
+        // Real Time Clock
+        //
+        Device (RTC) {
+          Name (_HID, EISAID ("PNP0B00"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x70, 0x70, 0x00, 0x02)
+            IRQNoFlags () {8}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2, 0, 8
+            //
+          })
+        }
+
+        //
+        // PCAT Speaker
+        //
+        Device(SPKR) {
+          Name (_HID, EISAID("PNP0800"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x61, 0x61, 0x01, 0x01)
+          })
+        }
+
+        //
+        // Floating Point Coprocessor
+        //
+        Device(FPU) {
+          Name (_HID, EISAID("PNP0C04"))
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0xF0, 0xF0, 0x00, 0x10)
+            IRQNoFlags () {13}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2, 0, 8, 13
+            //
+          })
+        }
+
+        //
+        // Generic motherboard devices and pieces that don't fit anywhere else
+        //
+        Device(XTRA) {
+          Name (_HID, EISAID ("PNP0C02"))
+          Name (_UID, 0x01)
+          Name (_CRS, ResourceTemplate () {
+            IO (Decode16, 0x010, 0x010, 0x00, 0x10)
+            IO (Decode16, 0x022, 0x022, 0x00, 0x1E)
+            IO (Decode16, 0x044, 0x044, 0x00, 0x1C)
+            IO (Decode16, 0x062, 0x062, 0x00, 0x02)
+            IO (Decode16, 0x065, 0x065, 0x00, 0x0B)
+            IO (Decode16, 0x072, 0x072, 0x00, 0x0E)
+            IO (Decode16, 0x080, 0x080, 0x00, 0x01)
+            IO (Decode16, 0x084, 0x084, 0x00, 0x03)
+            IO (Decode16, 0x088, 0x088, 0x00, 0x01)
+            IO (Decode16, 0x08c, 0x08c, 0x00, 0x03)
+            IO (Decode16, 0x090, 0x090, 0x00, 0x10)
+            IO (Decode16, 0x0A2, 0x0A2, 0x00, 0x1E)
+            IO (Decode16, 0x0E0, 0x0E0, 0x00, 0x10)
+            IO (Decode16, 0x1E0, 0x1E0, 0x00, 0x10)
+            IO (Decode16, 0x160, 0x160, 0x00, 0x10)
+            IO (Decode16, 0x278, 0x278, 0x00, 0x08)
+            IO (Decode16, 0x370, 0x370, 0x00, 0x02)
+            IO (Decode16, 0x378, 0x378, 0x00, 0x08)
+            IO (Decode16, FixedPcdGet16 (PcdDebugIoPort), FixedPcdGet16 (PcdDebugIoPort), 0x00, 0x01)
+            IO (Decode16, 0x440, 0x440, 0x00, 0x10)
+            IO (Decode16, 0x678, 0x678, 0x00, 0x08)
+            IO (Decode16, 0x778, 0x778, 0x00, 0x08)
+            IO (Decode16, 0xafe0, 0xafe0, 0x00, 0x04)      // QEMU GPE0 BLK
+            IO (Decode16, 0xb000, 0xb000, 0x00, 0x40)      // PMBLK1
+            Memory32Fixed (ReadOnly, 0xFEC00000, 0x1000)   // IO APIC
+            Memory32Fixed (ReadOnly, 0xFEE00000, 0x100000) // LAPIC
+          })
+        }
+
+        //
+        // PS/2 Keyboard and PC/AT Enhanced Keyboard 101/102
+        //
+        Device (PS2K) {
+          Name (_HID, EISAID ("PNP0303"))
+          Name (_CID, EISAID ("PNP030B"))
+          Name(_CRS,ResourceTemplate() {
+            IO (Decode16, 0x60, 0x60, 0x00, 0x01)
+            IO (Decode16, 0x64, 0x64, 0x00, 0x01)
+            IRQNoFlags () {1}
+            //
+            // list of IRQs occupied thus far: 9, 5, 10, 11, 2, 0, 8, 13, 1
+            //
+          })
+        }
+
+        //
+        // PS/2 Mouse and Microsoft Mouse
+        //
+        Device (PS2M) {  // PS/2 stype mouse port
+          Name (_HID, EISAID ("PNP0F03"))
+          Name (_CID, EISAID ("PNP0F13"))
+          Name (_CRS, ResourceTemplate() {
+            IRQNoFlags () {12}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12
+            //
+          })
+        }
+
+        //
+        // UART Serial Port - COM1
+        //
+        Device (UAR1) {
+          Name (_HID, EISAID ("PNP0501"))
+          Name (_DDN, "COM1")
+          Name (_UID, 0x01)
+          Name(_CRS,ResourceTemplate() {
+            IO (Decode16, 0x3F8, 0x3F8, 0x01, 0x08)
+            IRQ (Edge, ActiveHigh, Exclusive, ) {4}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12, 4
+            //
+          })
+        }
+
+        //
+        // UART Serial Port - COM2
+        //
+        Device (UAR2) {
+          Name (_HID, EISAID ("PNP0501"))
+          Name (_DDN, "COM2")
+          Name (_UID, 0x02)
+          Name(_CRS,ResourceTemplate() {
+            IO (Decode16, 0x2F8, 0x2F8, 0x01, 0x08)
+            IRQ (Edge, ActiveHigh, Exclusive, ) {3}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12, 4, 3
+            //
+          })
+        }
+
+        //
+        // Floppy Disk Controller
+        //
+        Device (FDC) {
+          Name (_HID, EISAID ("PNP0700"))
+          Name (_CRS,ResourceTemplate() {
+            IO (Decode16, 0x3F0, 0x3F0, 0x01, 0x06)
+            IO (Decode16, 0x3F7, 0x3F7, 0x01, 0x01)
+            IRQNoFlags () {6}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12, 4, 3, 6
+            //
+            DMA (Compatibility, NotBusMaster, Transfer8) {2}
+          })
+        }
+
+        //
+        // parallel port -- no DMA for now
+        //
+        Device (PAR1) {
+          Name (_HID, EISAID ("PNP0400"))
+          Name (_DDN, "LPT1")
+          Name (_UID, 0x01)
+          Name(_CRS, ResourceTemplate() {
+            IO (Decode16, 0x0378, 0x0378, 0x00, 0x08)
+            IRQNoFlags () {7}
+            //
+            // list of IRQs occupied thus far:
+            // 9, 5, 10, 11, 2, 0, 8, 13, 1, 12, 4, 3, 6, 7
+            // in order:
+            // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
+            //
+          })
+        }
+      }
+    }
+  }
\ No newline at end of file
diff --git a/TestPkg/AcpiTables/ForAddTest.h b/TestPkg/AcpiTables/ForAddTest.h
new file mode 100644
index 0000000000..a3a45d65e3
--- /dev/null
+++ b/TestPkg/AcpiTables/ForAddTest.h
@@ -0,0 +1,11 @@
+/** @file
+  Platform specific defines for constructing ACPI tables
+
+  Copyright (c) 2012, 2013, Red Hat, Inc.
+  Copyright (c) 2008, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define MaxRangeForAddTest 0x00FA
+#define RangeLengthForAddTest 0x00FB
\ No newline at end of file
diff --git a/TestPkg/AcpiTables/ForHIncludedH.h b/TestPkg/AcpiTables/ForHIncludedH.h
new file mode 100644
index 0000000000..ee74452f3d
--- /dev/null
+++ b/TestPkg/AcpiTables/ForHIncludedH.h
@@ -0,0 +1,10 @@
+/** @file
+  Platform specific defines for constructing ACPI tables
+
+  Copyright (c) 2012, 2013, Red Hat, Inc.
+  Copyright (c) 2008, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define ATestAddrH 0x0000b004
\ No newline at end of file
diff --git a/TestPkg/FakeEmuSec/Ia32/ForAddTest.asm b/TestPkg/FakeEmuSec/Ia32/ForAddTest.asm
new file mode 100644
index 0000000000..a1398b8539
--- /dev/null
+++ b/TestPkg/FakeEmuSec/Ia32/ForAddTest.asm
@@ -0,0 +1,20 @@
+;------------------------------------------------------------------------------
+;
+; Copyright (c) 2007 - 2012, Intel Corporation. All rights reserved.<BR>
+; SPDX-License-Identifier: BSD-2-Clause-Patent
+;
+; Module Name:
+;
+;   Stack.asm
+;
+; Abstract:
+;
+;   Switch the stack from temporary memory to permanent memory.
+;
+;------------------------------------------------------------------------------
+
+    mov   eax, ebp
+    sub   eax, ebx
+    add   eax, ecx
+    mov   ebp, eax                ; From now, ebp is pointed to permanent memory
+
diff --git a/TestPkg/LibraryClass.dsc b/TestPkg/LibraryClass.dsc
index 6530bafbe7..6f09564e2a 100644
--- a/TestPkg/LibraryClass.dsc
+++ b/TestPkg/LibraryClass.dsc
@@ -2,10 +2,11 @@
 #
 # Library Class section - list of all Library Classes needed by this Platform.
 #
 ################################################################################
 [LibraryClasses]
+  VmgExitLib|UefiCpuPkg/Library/VmgExitLibNull/VmgExitLibNull.inf
 NvVarsFileLib|TestPkg/Library/NvVarsFileLib/NvVarsFileLib.inf
   BaseLib|MdePkg/Library/BaseLib/BaseLib.inf
   PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
   BaseMemoryLib|MdePkg/Library/BaseMemoryLibRepStr/BaseMemoryLibRepStr.inf
   DebugPrintErrorLevelLib|MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.inf
diff --git a/TestPkg/PlatformDxe/FirstTestFile.h b/TestPkg/PlatformDxe/FirstTestFile.h
new file mode 100644
index 0000000000..91bd0506c0
--- /dev/null
+++ b/TestPkg/PlatformDxe/FirstTestFile.h
@@ -0,0 +1,9 @@
+/** @file
+Head file for front page.
+
+Copyright (c) 2004 - 2016, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define efi_guid_testaddr 0x136b3448
\ No newline at end of file
diff --git a/TestPkg/PlatformDxe/ForAddTest.hfr b/TestPkg/PlatformDxe/ForAddTest.hfr
new file mode 100644
index 0000000000..85226dd54f
--- /dev/null
+++ b/TestPkg/PlatformDxe/ForAddTest.hfr
@@ -0,0 +1,16 @@
+///** @file
+//  Boot Maintenance Utility Formset
+//
+//  Copyright (c) 2004 - 2018, Intel Corporation. All rights reserved.<BR>
+//  SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+//**/
+
+
+    form formid = FORM_DRV_CHG_ID,
+       title = STRING_TOKEN(STR_FORM_DRV_CHG_TITLE);
+
+       label FORM_DRV_CHG_ID;
+       label LABEL_END;
+
+    endform;
\ No newline at end of file
diff --git a/TestPkg/PlatformDxe/JustATest.uni b/TestPkg/PlatformDxe/JustATest.uni
new file mode 100644
index 0000000000000000000000000000000000000000..25c48dcb2d7a7d62ca39c844e3612d4a440b05ef
GIT binary patch
literal 904
zcmb7@+e*Vg5QhJ2!FO2dwZ4N54GKMxsJBIEdVttU4y8}8ezRdou_RHJ?ab_UcK-Qx
z^YyJe<$BjaTdkF8Bj-oP%DrBd5{)$R`?>ZiwIjaOO-J5F1$nU&pBEEx_Sy3KvaDKD
z*Q%weyrMO~1*+UX>-U{>t*Ggxq-H^X#=)WBg$`EqvB1uVC#<ZP&&(-Ns1a;Su}1Y4
zl8$-FaG^I&idkQJ;uWlq)cjy2!aES}$*euI3g6ZOwZG|mLfMq_gR0gJ>x;PA<{g;!
zlV@)lYVOX#A*lbnQeV<(#c1f2dKgeW(<2<`7ks<O4y$f;rN314lS?3#q9Edp+gt4(
m!y1;{n0+}J);xQ$3ATh@4!>}h4yF}*bN0^O8}pAN-slH7nT&q`

literal 0
HcmV?d00001

diff --git a/TestPkg/PlatformDxe/Platform.c b/TestPkg/PlatformDxe/Platform.c
new file mode 100644
index 0000000000..f2e51960ce
--- /dev/null
+++ b/TestPkg/PlatformDxe/Platform.c
@@ -0,0 +1,869 @@
+/** @file
+  This driver effectuates OVMF's platform configuration settings and exposes
+  them via HII.
+
+  Copyright (C) 2014, Red Hat, Inc.
+  Copyright (c) 2009 - 2014, Intel Corporation. All rights reserved.<BR>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#include <Library/BaseLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/DebugLib.h>
+#include <Library/DevicePathLib.h>
+#include <Library/HiiLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/PrintLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiHiiServicesLib.h>
+#include <Protocol/DevicePath.h>
+#include <Protocol/GraphicsOutput.h>
+#include <Protocol/HiiConfigAccess.h>
+#include <Guid/MdeModuleHii.h>
+#include <Guid/OvmfPlatformConfig.h>
+
+#include "Platform.h"
+#include "PlatformConfig.h"
+
+//
+// The HiiAddPackages() library function requires that any controller (or
+// image) handle, to be associated with the HII packages under installation, be
+// "decorated" with a device path. The tradition seems to be a vendor device
+// path.
+//
+// We'd like to associate our HII packages with the driver's image handle. The
+// first idea is to use the driver image's device path. Unfortunately, loaded
+// images only come with an EFI_LOADED_IMAGE_DEVICE_PATH_PROTOCOL (not the
+// usual EFI_DEVICE_PATH_PROTOCOL), ie. a different GUID. In addition, even the
+// EFI_LOADED_IMAGE_DEVICE_PATH_PROTOCOL interface may be NULL, if the image
+// has been loaded from an "unnamed" memory source buffer.
+//
+// Hence let's just stick with the tradition -- use a dedicated vendor device
+// path, with the driver's FILE_GUID.
+//
+#pragma pack(1)
+typedef struct {
+  VENDOR_DEVICE_PATH       VendorDevicePath;
+  EFI_DEVICE_PATH_PROTOCOL End;
+} PKG_DEVICE_PATH;
+#pragma pack()
+
+STATIC PKG_DEVICE_PATH mPkgDevicePath = {
+  {
+    {
+      HARDWARE_DEVICE_PATH,
+      HW_VENDOR_DP,
+      {
+        (UINT8) (sizeof (VENDOR_DEVICE_PATH)     ),
+        (UINT8) (sizeof (VENDOR_DEVICE_PATH) >> 8)
+      }
+    },
+    EFI_CALLER_ID_GUID
+  },
+  {
+    END_DEVICE_PATH_TYPE,
+    END_ENTIRE_DEVICE_PATH_SUBTYPE,
+    {
+      (UINT8) (END_DEVICE_PATH_LENGTH     ),
+      (UINT8) (END_DEVICE_PATH_LENGTH >> 8)
+    }
+  }
+};
+
+//
+// The configuration interface between the HII engine (form display etc) and
+// this driver.
+//
+STATIC EFI_HII_CONFIG_ACCESS_PROTOCOL mConfigAccess;
+
+//
+// The handle representing our list of packages after installation.
+//
+STATIC EFI_HII_HANDLE mInstalledPackages;
+
+//
+// The arrays below constitute our HII package list. They are auto-generated by
+// the VFR compiler and linked into the driver image during the build.
+//
+// - The strings package receives its C identifier from the driver's BASE_NAME,
+//   plus "Strings".
+//
+// - The forms package receives its C identifier from the VFR file's basename,
+//   plus "Bin".
+//
+//
+extern UINT8 PlatformDxeStrings[];
+extern UINT8 PlatformFormsBin[];
+
+//
+// We want to be notified about GOP installations until we find one GOP
+// interface that lets us populate the form.
+//
+STATIC EFI_EVENT mGopEvent;
+
+//
+// The registration record underneath this pointer allows us to iterate through
+// the GOP instances one by one.
+//
+STATIC VOID *mGopTracker;
+
+//
+// Cache the resolutions we get from the GOP.
+//
+typedef struct {
+  UINT32 X;
+  UINT32 Y;
+} GOP_MODE;
+
+STATIC UINTN    mNumGopModes;
+STATIC GOP_MODE *mGopModes;
+
+
+/**
+  Load the persistent platform configuration and translate it to binary form
+  state.
+
+  If the platform configuration is missing, then the function fills in a
+  default state.
+
+  @param[out] MainFormState  Binary form/widget state after translation.
+
+  @retval EFI_SUCCESS  Form/widget state ready.
+  @return              Error codes from underlying functions.
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+PlatformConfigToFormState (
+  OUT MAIN_FORM_STATE *MainFormState
+  )
+{
+  EFI_STATUS      Status;
+  PLATFORM_CONFIG PlatformConfig;
+  UINT64          OptionalElements;
+  UINTN           ModeNumber;
+
+  ZeroMem (MainFormState, sizeof *MainFormState);
+
+  Status = PlatformConfigLoad (&PlatformConfig, &OptionalElements);
+  switch (Status) {
+  case EFI_SUCCESS:
+    if (OptionalElements & PLATFORM_CONFIG_F_GRAPHICS_RESOLUTION) {
+      //
+      // Format the preferred resolution as text.
+      //
+      UnicodeSPrintAsciiFormat (
+        (CHAR16 *) MainFormState->CurrentPreferredResolution,
+        sizeof MainFormState->CurrentPreferredResolution,
+        "%Ldx%Ld",
+        (INT64) PlatformConfig.HorizontalResolution,
+        (INT64) PlatformConfig.VerticalResolution);
+
+      //
+      // Try to locate it in the drop-down list too. This may not succeed, but
+      // that's fine.
+      //
+      for (ModeNumber = 0; ModeNumber < mNumGopModes; ++ModeNumber) {
+        if (mGopModes[ModeNumber].X == PlatformConfig.HorizontalResolution &&
+            mGopModes[ModeNumber].Y == PlatformConfig.VerticalResolution) {
+          MainFormState->NextPreferredResolution = (UINT32) ModeNumber;
+          break;
+        }
+      }
+
+      break;
+    }
+    //
+    // fall through otherwise
+    //
+
+  case EFI_NOT_FOUND:
+    UnicodeSPrintAsciiFormat (
+      (CHAR16 *) MainFormState->CurrentPreferredResolution,
+      sizeof MainFormState->CurrentPreferredResolution,
+      "Unset");
+    break;
+
+  default:
+    return Status;
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function is called by the HII machinery when it fetches the form state.
+
+  See the precise documentation in the UEFI spec.
+
+  @param[in]  This      The Config Access Protocol instance.
+
+  @param[in]  Request   A <ConfigRequest> format UCS-2 string describing the
+                        query.
+
+  @param[out] Progress  A pointer into Request on output, identifying the query
+                        element where processing failed.
+
+  @param[out] Results   A <MultiConfigAltResp> format UCS-2 string that has
+                        all values filled in for the names in the Request
+                        string.
+
+  @retval EFI_SUCCESS  Extraction of form state in <MultiConfigAltResp>
+                       encoding successful.
+  @return              Status codes from underlying functions.
+
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+ExtractConfig (
+  IN CONST  EFI_HII_CONFIG_ACCESS_PROTOCOL  *This,
+  IN CONST  EFI_STRING                      Request,
+  OUT       EFI_STRING                      *Progress,
+  OUT       EFI_STRING                      *Results
+)
+{
+  MAIN_FORM_STATE MainFormState;
+  EFI_STATUS      Status;
+
+  DEBUG ((DEBUG_VERBOSE, "%a: Request=\"%s\"\n", __FUNCTION__, Request));
+
+  Status = PlatformConfigToFormState (&MainFormState);
+  if (EFI_ERROR (Status)) {
+    *Progress = Request;
+    return Status;
+  }
+
+  //
+  // Answer the textual request keying off the binary form state.
+  //
+  Status = gHiiConfigRouting->BlockToConfig (gHiiConfigRouting, Request,
+                                (VOID *) &MainFormState, sizeof MainFormState,
+                                Results, Progress);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "%a: BlockToConfig(): %r, Progress=\"%s\"\n",
+      __FUNCTION__, Status, (Status == EFI_DEVICE_ERROR) ? NULL : *Progress));
+  } else {
+    DEBUG ((DEBUG_VERBOSE, "%a: Results=\"%s\"\n", __FUNCTION__, *Results));
+  }
+  return Status;
+}
+
+
+/**
+  Interpret the binary form state and save it as persistent platform
+  configuration.
+
+  @param[in] MainFormState  Binary form/widget state to verify and save.
+
+  @retval EFI_SUCCESS  Platform configuration saved.
+  @return              Error codes from underlying functions.
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+FormStateToPlatformConfig (
+  IN CONST MAIN_FORM_STATE *MainFormState
+  )
+{
+  EFI_STATUS      Status;
+  PLATFORM_CONFIG PlatformConfig;
+  CONST GOP_MODE  *GopMode;
+
+  //
+  // There's nothing to do with the textual CurrentPreferredResolution field.
+  // We verify and translate the selection in the drop-down list.
+  //
+  if (MainFormState->NextPreferredResolution >= mNumGopModes) {
+    return EFI_INVALID_PARAMETER;
+  }
+  GopMode = mGopModes + MainFormState->NextPreferredResolution;
+
+  ZeroMem (&PlatformConfig, sizeof PlatformConfig);
+  PlatformConfig.HorizontalResolution = GopMode->X;
+  PlatformConfig.VerticalResolution   = GopMode->Y;
+
+  Status = PlatformConfigSave (&PlatformConfig);
+  return Status;
+}
+
+
+/**
+  This function is called by the HII machinery when it wants the driver to
+  interpret and persist the form state.
+
+  See the precise documentation in the UEFI spec.
+
+  @param[in]  This           The Config Access Protocol instance.
+
+  @param[in]  Configuration  A <ConfigResp> format UCS-2 string describing the
+                             form state.
+
+  @param[out] Progress       A pointer into Configuration on output,
+                             identifying the element where processing failed.
+
+  @retval EFI_SUCCESS  Configuration verified, state permanent.
+
+  @return              Status codes from underlying functions.
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+RouteConfig (
+  IN CONST  EFI_HII_CONFIG_ACCESS_PROTOCOL  *This,
+  IN CONST  EFI_STRING                      Configuration,
+  OUT       EFI_STRING                      *Progress
+)
+{
+  MAIN_FORM_STATE MainFormState;
+  UINTN           BlockSize;
+  EFI_STATUS      Status;
+
+  DEBUG ((DEBUG_VERBOSE, "%a: Configuration=\"%s\"\n", __FUNCTION__,
+    Configuration));
+
+  //
+  // the "read" step in RMW
+  //
+  Status = PlatformConfigToFormState (&MainFormState);
+  if (EFI_ERROR (Status)) {
+    *Progress = Configuration;
+    return Status;
+  }
+
+  //
+  // the "modify" step in RMW
+  //
+  // (Update the binary form state. This update may be partial, which is why in
+  // general we must pre-load the form state from the platform config.)
+  //
+  BlockSize = sizeof MainFormState;
+  Status = gHiiConfigRouting->ConfigToBlock (gHiiConfigRouting, Configuration,
+                                (VOID *) &MainFormState, &BlockSize, Progress);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "%a: ConfigToBlock(): %r, Progress=\"%s\"\n",
+      __FUNCTION__, Status,
+      (Status == EFI_BUFFER_TOO_SMALL) ? NULL : *Progress));
+    return Status;
+  }
+
+  //
+  // the "write" step in RMW
+  //
+  Status = FormStateToPlatformConfig (&MainFormState);
+  if (EFI_ERROR (Status)) {
+    *Progress = Configuration;
+  }
+  return Status;
+}
+
+
+STATIC
+EFI_STATUS
+EFIAPI
+Callback (
+  IN     CONST EFI_HII_CONFIG_ACCESS_PROTOCOL   *This,
+  IN     EFI_BROWSER_ACTION                     Action,
+  IN     EFI_QUESTION_ID                        QuestionId,
+  IN     UINT8                                  Type,
+  IN OUT EFI_IFR_TYPE_VALUE                     *Value,
+  OUT    EFI_BROWSER_ACTION_REQUEST             *ActionRequest
+  )
+{
+  DEBUG ((DEBUG_VERBOSE, "%a: Action=0x%Lx QuestionId=%d Type=%d\n",
+    __FUNCTION__, (UINT64) Action, QuestionId, Type));
+
+  if (Action != EFI_BROWSER_ACTION_CHANGED) {
+    return EFI_UNSUPPORTED;
+  }
+
+  switch (QuestionId) {
+  case QUESTION_SAVE_EXIT:
+    *ActionRequest = EFI_BROWSER_ACTION_REQUEST_FORM_SUBMIT_EXIT;
+    break;
+
+  case QUESTION_DISCARD_EXIT:
+    *ActionRequest = EFI_BROWSER_ACTION_REQUEST_FORM_DISCARD_EXIT;
+    break;
+
+  default:
+    break;
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Query and save all resolutions supported by the GOP.
+
+  @param[in]  Gop          The Graphics Output Protocol instance to query.
+
+  @param[out] NumGopModes  The number of modes supported by the GOP. On output,
+                           this parameter will be positive.
+
+  @param[out] GopModes     On output, a dynamically allocated array containing
+                           the resolutions returned by the GOP. The caller is
+                           responsible for freeing the array after use.
+
+  @retval EFI_UNSUPPORTED       No modes found.
+  @retval EFI_OUT_OF_RESOURCES  Failed to allocate GopModes.
+  @return                       Error codes from Gop->QueryMode().
+
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+QueryGopModes (
+  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL *Gop,
+  OUT UINTN                        *NumGopModes,
+  OUT GOP_MODE                     **GopModes
+  )
+{
+  EFI_STATUS Status;
+  UINT32     ModeNumber;
+
+  if (Gop->Mode->MaxMode == 0) {
+    return EFI_UNSUPPORTED;
+  }
+  *NumGopModes = Gop->Mode->MaxMode;
+
+  *GopModes = AllocatePool (Gop->Mode->MaxMode * sizeof **GopModes);
+  if (*GopModes == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  for (ModeNumber = 0; ModeNumber < Gop->Mode->MaxMode; ++ModeNumber) {
+    EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *Info;
+    UINTN                                SizeOfInfo;
+
+    Status = Gop->QueryMode (Gop, ModeNumber, &SizeOfInfo, &Info);
+    if (EFI_ERROR (Status)) {
+      goto FreeGopModes;
+    }
+
+    (*GopModes)[ModeNumber].X = Info->HorizontalResolution;
+    (*GopModes)[ModeNumber].Y = Info->VerticalResolution;
+    FreePool (Info);
+  }
+
+  return EFI_SUCCESS;
+
+FreeGopModes:
+  FreePool (*GopModes);
+
+  return Status;
+}
+
+
+/**
+  Create a set of "one-of-many" (ie. "drop down list") option IFR opcodes,
+  based on available GOP resolutions, to be placed under a "one-of-many" (ie.
+  "drop down list") opcode.
+
+  @param[in]  PackageList   The package list with the formset and form for
+                            which the drop down options are produced. Option
+                            names are added as new strings to PackageList.
+
+  @param[out] OpCodeBuffer  On output, a dynamically allocated opcode buffer
+                            with drop down list options corresponding to GOP
+                            resolutions. The caller is responsible for freeing
+                            OpCodeBuffer with HiiFreeOpCodeHandle() after use.
+
+  @param[in]  NumGopModes   Number of entries in GopModes.
+
+  @param[in]  GopModes      Array of resolutions retrieved from the GOP.
+
+  @retval EFI_SUCESS  Opcodes have been successfully produced.
+
+  @return             Status codes from underlying functions. PackageList may
+                      have been extended with new strings. OpCodeBuffer is
+                      unchanged.
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+CreateResolutionOptions (
+  IN  EFI_HII_HANDLE  PackageList,
+  OUT VOID            **OpCodeBuffer,
+  IN  UINTN           NumGopModes,
+  IN  GOP_MODE        *GopModes
+  )
+{
+  EFI_STATUS Status;
+  VOID       *OutputBuffer;
+  UINTN      ModeNumber;
+
+  OutputBuffer = HiiAllocateOpCodeHandle ();
+  if (OutputBuffer == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  for (ModeNumber = 0; ModeNumber < NumGopModes; ++ModeNumber) {
+    CHAR16        Desc[MAXSIZE_RES_CUR];
+    EFI_STRING_ID NewString;
+    VOID          *OpCode;
+
+    UnicodeSPrintAsciiFormat (Desc, sizeof Desc, "%Ldx%Ld",
+      (INT64) GopModes[ModeNumber].X, (INT64) GopModes[ModeNumber].Y);
+    NewString = HiiSetString (PackageList, 0 /* new string */, Desc,
+                  NULL /* for all languages */);
+    if (NewString == 0) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto FreeOutputBuffer;
+    }
+    OpCode = HiiCreateOneOfOptionOpCode (OutputBuffer, NewString,
+               0 /* Flags */, EFI_IFR_NUMERIC_SIZE_4, ModeNumber);
+    if (OpCode == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto FreeOutputBuffer;
+    }
+  }
+
+  *OpCodeBuffer = OutputBuffer;
+  return EFI_SUCCESS;
+
+FreeOutputBuffer:
+  HiiFreeOpCodeHandle (OutputBuffer);
+
+  return Status;
+}
+
+
+/**
+  Populate the form identified by the (PackageList, FormSetGuid, FormId)
+  triplet.
+
+  The drop down list of video resolutions is generated from (NumGopModes,
+  GopModes).
+
+  @retval EFI_SUCESS  Form successfully updated.
+  @return             Status codes from underlying functions.
+
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+PopulateForm (
+  IN  EFI_HII_HANDLE  PackageList,
+  IN  EFI_GUID        *FormSetGuid,
+  IN  EFI_FORM_ID     FormId,
+  IN  UINTN           NumGopModes,
+  IN  GOP_MODE        *GopModes
+  )
+{
+  EFI_STATUS         Status;
+  VOID               *OpCodeBuffer;
+  VOID               *OpCode;
+  EFI_IFR_GUID_LABEL *Anchor;
+  VOID               *OpCodeBuffer2;
+
+  OpCodeBuffer2 = NULL;
+
+  //
+  // 1. Allocate an empty opcode buffer.
+  //
+  OpCodeBuffer = HiiAllocateOpCodeHandle ();
+  if (OpCodeBuffer == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  //
+  // 2. Create a label opcode (which is a Tiano extension) inside the buffer.
+  // The label's number must match the "anchor" label in the form.
+  //
+  OpCode = HiiCreateGuidOpCode (OpCodeBuffer, &gEfiIfrTianoGuid,
+             NULL /* optional copy origin */, sizeof *Anchor);
+  if (OpCode == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto FreeOpCodeBuffer;
+  }
+  Anchor               = OpCode;
+  Anchor->ExtendOpCode = EFI_IFR_EXTEND_OP_LABEL;
+  Anchor->Number       = LABEL_RES_NEXT;
+
+  //
+  // 3. Create the opcodes inside the buffer that are to be inserted into the
+  // form.
+  //
+  // 3.1. Get a list of resolutions.
+  //
+  Status = CreateResolutionOptions (PackageList, &OpCodeBuffer2,
+             NumGopModes, GopModes);
+  if (EFI_ERROR (Status)) {
+    goto FreeOpCodeBuffer;
+  }
+
+  //
+  // 3.2. Create a one-of-many question with the above options.
+  //
+  OpCode = HiiCreateOneOfOpCode (
+             OpCodeBuffer,                        // create opcode inside this
+                                                  //   opcode buffer,
+             QUESTION_RES_NEXT,                   // ID of question,
+             FORMSTATEID_MAIN_FORM,               // identifies form state
+                                                  //   storage,
+             (UINT16) OFFSET_OF (MAIN_FORM_STATE, // value of question stored
+                        NextPreferredResolution), //   at this offset,
+             STRING_TOKEN (STR_RES_NEXT),         // Prompt,
+             STRING_TOKEN (STR_RES_NEXT_HELP),    // Help,
+             0,                                   // QuestionFlags,
+             EFI_IFR_NUMERIC_SIZE_4,              // see sizeof
+                                                  //   NextPreferredResolution,
+             OpCodeBuffer2,                       // buffer with possible
+                                                  //   choices,
+             NULL                                 // DEFAULT opcodes
+             );
+  if (OpCode == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto FreeOpCodeBuffer2;
+  }
+
+  //
+  // 4. Update the form with the opcode buffer.
+  //
+  Status = HiiUpdateForm (PackageList, FormSetGuid, FormId,
+             OpCodeBuffer, // buffer with head anchor, and new contents to be
+                           // inserted at it
+             NULL          // buffer with tail anchor, for deleting old
+                           // contents up to it
+             );
+
+FreeOpCodeBuffer2:
+  HiiFreeOpCodeHandle (OpCodeBuffer2);
+
+FreeOpCodeBuffer:
+  HiiFreeOpCodeHandle (OpCodeBuffer);
+
+  return Status;
+}
+
+
+/**
+  Load and execute the platform configuration.
+
+  @retval EFI_SUCCESS            Configuration loaded and executed.
+  @return                        Status codes from PlatformConfigLoad().
+**/
+STATIC
+EFI_STATUS
+EFIAPI
+ExecutePlatformConfig (
+  VOID
+  )
+{
+  EFI_STATUS      Status;
+  PLATFORM_CONFIG PlatformConfig;
+  UINT64          OptionalElements;
+  RETURN_STATUS   PcdStatus;
+
+  Status = PlatformConfigLoad (&PlatformConfig, &OptionalElements);
+  if (EFI_ERROR (Status)) {
+    DEBUG (((Status == EFI_NOT_FOUND) ? DEBUG_VERBOSE : DEBUG_ERROR,
+      "%a: failed to load platform config: %r\n", __FUNCTION__, Status));
+    return Status;
+  }
+
+  if (OptionalElements & PLATFORM_CONFIG_F_GRAPHICS_RESOLUTION) {
+    //
+    // Pass the preferred resolution to GraphicsConsoleDxe via dynamic PCDs.
+    //
+    PcdStatus = PcdSet32S (PcdVideoHorizontalResolution,
+      PlatformConfig.HorizontalResolution);
+    ASSERT_RETURN_ERROR (PcdStatus);
+
+    PcdStatus = PcdSet32S (PcdVideoVerticalResolution,
+      PlatformConfig.VerticalResolution);
+    ASSERT_RETURN_ERROR (PcdStatus);
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Notification callback for GOP interface installation.
+
+  @param[in] Event    Event whose notification function is being invoked.
+
+  @param[in] Context  The pointer to the notification function's context, which
+                      is implementation-dependent.
+**/
+STATIC
+VOID
+EFIAPI
+GopInstalled (
+  IN EFI_EVENT Event,
+  IN VOID      *Context
+  )
+{
+  EFI_STATUS                   Status;
+  EFI_GRAPHICS_OUTPUT_PROTOCOL *Gop;
+
+  ASSERT (Event == mGopEvent);
+
+  //
+  // Check further GOPs.
+  //
+  for (;;) {
+    mNumGopModes = 0;
+    mGopModes = NULL;
+
+    Status = gBS->LocateProtocol (&gEfiGraphicsOutputProtocolGuid, mGopTracker,
+                    (VOID **) &Gop);
+    if (EFI_ERROR (Status)) {
+      return;
+    }
+
+    Status = QueryGopModes (Gop, &mNumGopModes, &mGopModes);
+    if (EFI_ERROR (Status)) {
+      continue;
+    }
+
+    Status = PopulateForm (mInstalledPackages, &gOvmfPlatformConfigGuid,
+               FORMID_MAIN_FORM, mNumGopModes, mGopModes);
+    if (EFI_ERROR (Status)) {
+      FreePool (mGopModes);
+      continue;
+    }
+
+    break;
+  }
+
+  //
+  // Success -- so uninstall this callback. Closing the event removes all
+  // pending notifications and all protocol registrations.
+  //
+  Status = gBS->CloseEvent (mGopEvent);
+  ASSERT_EFI_ERROR (Status);
+  mGopEvent = NULL;
+  mGopTracker = NULL;
+}
+
+
+/**
+  Entry point for this driver.
+
+  @param[in] ImageHandle  Image handle of this driver.
+  @param[in] SystemTable  Pointer to SystemTable.
+
+  @retval EFI_SUCESS            Driver has loaded successfully.
+  @retval EFI_OUT_OF_RESOURCES  Failed to install HII packages.
+  @return                       Error codes from lower level functions.
+
+**/
+EFI_STATUS
+EFIAPI
+PlatformInit (
+  IN  EFI_HANDLE        ImageHandle,
+  IN  EFI_SYSTEM_TABLE  *SystemTable
+  )
+{
+  EFI_STATUS Status;
+
+  ExecutePlatformConfig ();
+
+  mConfigAccess.ExtractConfig = &ExtractConfig;
+  mConfigAccess.RouteConfig   = &RouteConfig;
+  mConfigAccess.Callback      = &Callback;
+
+  //
+  // Declare ourselves suitable for HII communication.
+  //
+  Status = gBS->InstallMultipleProtocolInterfaces (&ImageHandle,
+                  &gEfiDevicePathProtocolGuid,      &mPkgDevicePath,
+                  &gEfiHiiConfigAccessProtocolGuid, &mConfigAccess,
+                  NULL);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Publish the HII package list to HII Database.
+  //
+  mInstalledPackages = HiiAddPackages (
+                         &gEfiCallerIdGuid,  // PackageListGuid
+                         ImageHandle,        // associated DeviceHandle
+                         PlatformDxeStrings, // 1st package
+                         PlatformFormsBin,   // 2nd package
+                         NULL                // terminator
+                         );
+  if (mInstalledPackages == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto UninstallProtocols;
+  }
+
+  Status = gBS->CreateEvent (EVT_NOTIFY_SIGNAL, TPL_CALLBACK, &GopInstalled,
+                  NULL /* Context */, &mGopEvent);
+  if (EFI_ERROR (Status)) {
+    goto RemovePackages;
+  }
+
+  Status = gBS->RegisterProtocolNotify (&gEfiGraphicsOutputProtocolGuid,
+                  mGopEvent, &mGopTracker);
+  if (EFI_ERROR (Status)) {
+    goto CloseGopEvent;
+  }
+
+  //
+  // Check already installed GOPs.
+  //
+  Status = gBS->SignalEvent (mGopEvent);
+  ASSERT_EFI_ERROR (Status);
+
+  return EFI_SUCCESS;
+
+CloseGopEvent:
+  gBS->CloseEvent (mGopEvent);
+
+RemovePackages:
+  HiiRemovePackages (mInstalledPackages);
+
+UninstallProtocols:
+  gBS->UninstallMultipleProtocolInterfaces (ImageHandle,
+         &gEfiDevicePathProtocolGuid,      &mPkgDevicePath,
+         &gEfiHiiConfigAccessProtocolGuid, &mConfigAccess,
+         NULL);
+  return Status;
+}
+
+/**
+  Unload the driver.
+
+  @param[in]  ImageHandle  Handle that identifies the image to evict.
+
+  @retval EFI_SUCCESS  The image has been unloaded.
+**/
+EFI_STATUS
+EFIAPI
+PlatformUnload (
+  IN  EFI_HANDLE  ImageHandle
+  )
+{
+  if (mGopEvent == NULL) {
+    //
+    // The GOP callback ran successfully and unregistered itself. Release the
+    // resources allocated there.
+    //
+    ASSERT (mGopModes != NULL);
+    FreePool (mGopModes);
+  } else {
+    //
+    // Otherwise we need to unregister the callback.
+    //
+    ASSERT (mGopModes == NULL);
+    gBS->CloseEvent (mGopEvent);
+  }
+
+  //
+  // Release resources allocated by the entry point.
+  //
+  HiiRemovePackages (mInstalledPackages);
+  gBS->UninstallMultipleProtocolInterfaces (ImageHandle,
+         &gEfiDevicePathProtocolGuid,      &mPkgDevicePath,
+         &gEfiHiiConfigAccessProtocolGuid, &mConfigAccess,
+         NULL);
+  return EFI_SUCCESS;
+}
diff --git a/TestPkg/PlatformDxe/Platform.h b/TestPkg/PlatformDxe/Platform.h
new file mode 100644
index 0000000000..63b5e52575
--- /dev/null
+++ b/TestPkg/PlatformDxe/Platform.h
@@ -0,0 +1,37 @@
+/** @file
+  This driver effectuates OVMF's platform configuration settings and exposes
+  them via HII.
+
+  Copyright (C) 2014, Red Hat, Inc.
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _PLATFORM_H_
+#define _PLATFORM_H_
+
+//
+// Macro and type definitions that connect the form with the HII driver code.
+//
+#define FORMSTATEID_MAIN_FORM  1
+#define FORMID_MAIN_FORM       1
+
+#define QUESTION_RES_CUR       1
+#define MAXSIZE_RES_CUR       16
+
+#define LABEL_RES_NEXT         1
+#define QUESTION_RES_NEXT      2
+
+#define QUESTION_SAVE_EXIT     3
+#define QUESTION_DISCARD_EXIT  4
+
+//
+// This structure describes the form state. Its fields relate strictly to the
+// visual widgets on the form.
+//
+typedef struct {
+  UINT16 CurrentPreferredResolution[MAXSIZE_RES_CUR];
+  UINT32 NextPreferredResolution;
+} MAIN_FORM_STATE;
+
+#endif // _PLATFORM_H_
diff --git a/TestPkg/PlatformDxe/Platform.inf b/TestPkg/PlatformDxe/Platform.inf
new file mode 100644
index 0000000000..14727c1220
--- /dev/null
+++ b/TestPkg/PlatformDxe/Platform.inf
@@ -0,0 +1,64 @@
+## @file
+#  This driver effectuates OVMF's platform configuration settings and exposes
+#  them via HII.
+#
+#  Copyright (C) 2014, Red Hat, Inc.
+#  Copyright (c) 2009 - 2010, Intel Corporation. All rights reserved.<BR>
+#
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformDxe
+  FILE_GUID                      = D9DCC5DF-4007-435E-9098-8970935504B2
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = PlatformInit
+  UNLOAD_IMAGE                   = PlatformUnload
+
+[Sources]
+  Platform.c
+  Platform.h
+  Platform.uni
+  PlatformConfig.c
+  PlatformConfig.h
+  PlatformForms.vfr
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  BaseMemoryLib
+  DebugLib
+  DevicePathLib
+  HiiLib
+  MemoryAllocationLib
+  PrintLib
+  UefiBootServicesTableLib
+  UefiHiiServicesLib
+  UefiLib
+  UefiRuntimeServicesTableLib
+  UefiDriverEntryPoint
+
+[Pcd]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVideoHorizontalResolution
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVideoVerticalResolution
+
+[Protocols]
+  gEfiDevicePathProtocolGuid      ## PRODUCES
+  gEfiGraphicsOutputProtocolGuid  ## CONSUMES
+  gEfiHiiConfigAccessProtocolGuid ## PRODUCES
+
+[Guids]
+  gEfiIfrTianoGuid
+  gOvmfPlatformConfigGuid
+
+[Depex]
+  gEfiHiiConfigRoutingProtocolGuid  AND
+  gEfiHiiDatabaseProtocolGuid       AND
+  gEfiVariableArchProtocolGuid      AND
+  gEfiVariableWriteArchProtocolGuid
diff --git a/TestPkg/PlatformDxe/Platform.uni b/TestPkg/PlatformDxe/Platform.uni
new file mode 100644
index 0000000000..7fcef8df50
--- /dev/null
+++ b/TestPkg/PlatformDxe/Platform.uni
@@ -0,0 +1,28 @@
+// *++
+//
+// Copyright (C) 2014, Red Hat, Inc.
+// Copyright (c) 2009, Intel Corporation. All rights reserved.<BR>
+//
+// SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+// Module Name:
+//
+//   Platform.uni
+//
+// Abstract:
+//
+//   String definitions for PlatformForms.vfr
+//
+// --*/
+
+/=#
+
+#langdef en-US "English"
+#include "JustATest.uni"
+
+#string STR_RES_CUR_HELP         #language en-US "The preferred resolution of the Graphics Console at next boot. It might be unset, or even invalid (hence ignored) wrt. the video RAM size."
+#string STR_RES_NEXT             #language en-US "Change Preferred Resolution for Next Boot"
+#string STR_RES_NEXT_HELP        #language en-US "You can specify a new preference for the Graphics Console here. The list is filtered against the video RAM size."
+#string STR_SAVE_EXIT            #language en-US "Commit Changes and Exit"
+#string STR_DISCARD_EXIT         #language en-US "Discard Changes and Exit"
+
diff --git a/TestPkg/PlatformDxe/PlatformConfig.c b/TestPkg/PlatformDxe/PlatformConfig.c
new file mode 100644
index 0000000000..f3f0b54d6c
--- /dev/null
+++ b/TestPkg/PlatformDxe/PlatformConfig.c
@@ -0,0 +1,125 @@
+/** @file
+
+  Utility functions for serializing (persistently storing) and deserializing
+  OVMF's platform configuration.
+
+  Copyright (C) 2014, Red Hat, Inc.
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <Library/BaseMemoryLib.h>
+#include <Library/DebugLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/UefiLib.h>
+#include <Library/UefiRuntimeServicesTableLib.h>
+#include <Guid/OvmfPlatformConfig.h>
+
+#include "PlatformConfig.h"
+
+//
+// Name of the UEFI variable that we use for persistent storage.
+//
+STATIC CHAR16 mVariableName[] = L"PlatformConfig";
+
+
+/**
+  Serialize and persistently save platform configuration.
+
+  @param[in] PlatformConfig  The platform configuration to serialize and save.
+
+  @return  Status codes returned by gRT->SetVariable().
+**/
+EFI_STATUS
+EFIAPI
+PlatformConfigSave (
+  IN PLATFORM_CONFIG *PlatformConfig
+  )
+{
+  EFI_STATUS Status;
+
+  //
+  // We could implement any kind of translation here, as part of serialization.
+  // For example, we could expose the platform configuration in separate
+  // variables with human-readable contents, allowing other tools to access
+  // them more easily. For now, just save a binary dump.
+  //
+  Status = gRT->SetVariable (mVariableName, &gOvmfPlatformConfigGuid,
+                  EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS |
+                    EFI_VARIABLE_RUNTIME_ACCESS,
+                  sizeof *PlatformConfig, PlatformConfig);
+  return Status;
+}
+
+
+/**
+  Load and deserialize platform configuration.
+
+  When the function fails, output parameters are indeterminate.
+
+  @param[out] PlatformConfig    The platform configuration to receive the
+                                loaded data.
+
+  @param[out] OptionalElements  This bitmap describes the presence of optional
+                                configuration elements that have been loaded.
+                                PLATFORM_CONFIG_F_DOWNGRADE means that some
+                                unknown elements, present in the wire format,
+                                have been ignored.
+
+  @retval  EFI_SUCCESS         Loading & deserialization successful.
+  @return                      Error codes returned by GetVariable2().
+**/
+EFI_STATUS
+EFIAPI
+PlatformConfigLoad (
+  OUT PLATFORM_CONFIG *PlatformConfig,
+  OUT UINT64          *OptionalElements
+  )
+{
+  VOID       *Data;
+  UINTN      DataSize;
+  EFI_STATUS Status;
+
+  //
+  // Any translation done in PlatformConfigSave() would have to be mirrored
+  // here. For now, just load the binary dump.
+  //
+  // Versioning of the binary wire format is implemented based on size
+  // (only incremental changes, ie. new fields), and on GUID.
+  // (Incompatible changes require a GUID change.)
+  //
+  Status = GetVariable2 (mVariableName, &gOvmfPlatformConfigGuid, &Data,
+             &DataSize);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  *OptionalElements = 0;
+  if (DataSize > sizeof *PlatformConfig) {
+    //
+    // Handle firmware downgrade -- keep only leading part.
+    //
+    CopyMem (PlatformConfig, Data, sizeof *PlatformConfig);
+    *OptionalElements |= PLATFORM_CONFIG_F_DOWNGRADE;
+  } else {
+    CopyMem (PlatformConfig, Data, DataSize);
+
+    //
+    // Handle firmware upgrade -- zero out missing fields.
+    //
+    ZeroMem ((UINT8 *)PlatformConfig + DataSize,
+      sizeof *PlatformConfig - DataSize);
+  }
+
+  //
+  // Based on DataSize, report the optional features that we recognize.
+  //
+  if (DataSize >= (OFFSET_OF (PLATFORM_CONFIG, VerticalResolution) +
+                   sizeof PlatformConfig->VerticalResolution)) {
+    *OptionalElements |= PLATFORM_CONFIG_F_GRAPHICS_RESOLUTION;
+  }
+
+  FreePool (Data);
+  return EFI_SUCCESS;
+}
diff --git a/TestPkg/PlatformDxe/PlatformConfig.h b/TestPkg/PlatformDxe/PlatformConfig.h
new file mode 100644
index 0000000000..716514da21
--- /dev/null
+++ b/TestPkg/PlatformDxe/PlatformConfig.h
@@ -0,0 +1,53 @@
+/** @file
+
+  Utility functions for serializing (persistently storing) and deserializing
+  OVMF's platform configuration.
+
+  Copyright (C) 2014, Red Hat, Inc.
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _PLATFORM_CONFIG_H_
+#define _PLATFORM_CONFIG_H_
+
+#include <Base.h>
+
+//
+// This structure participates in driver configuration. It does not
+// (necessarily) reflect the wire format in the persistent store.
+//
+#pragma pack(1)
+typedef struct {
+  //
+  // preferred graphics console resolution when booting
+  //
+  UINT32 HorizontalResolution;
+  UINT32 VerticalResolution;
+} PLATFORM_CONFIG;
+#pragma pack()
+
+//
+// Please see the API documentation near the function definitions.
+//
+EFI_STATUS
+EFIAPI
+PlatformConfigSave (
+  IN PLATFORM_CONFIG *PlatformConfig
+  );
+
+EFI_STATUS
+EFIAPI
+PlatformConfigLoad (
+  OUT PLATFORM_CONFIG *PlatformConfig,
+  OUT UINT64          *OptionalElements
+  );
+
+//
+// Feature flags for OptionalElements.
+//
+#define PLATFORM_CONFIG_F_GRAPHICS_RESOLUTION BIT0
+#define PLATFORM_CONFIG_F_DOWNGRADE           BIT63
+
+#endif // _PLATFORM_CONFIG_H_
diff --git a/TestPkg/PlatformDxe/PlatformForms.vfr b/TestPkg/PlatformDxe/PlatformForms.vfr
new file mode 100644
index 0000000000..59520ef9d4
--- /dev/null
+++ b/TestPkg/PlatformDxe/PlatformForms.vfr
@@ -0,0 +1,67 @@
+// *++
+//
+// Copyright (C) 2014, Red Hat, Inc.
+// Copyright (c) 2009 - 2011, Intel Corporation. All rights reserved.<BR>
+//
+// SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+// Module Name:
+//
+//   PlatformForms.vfr
+//
+// Abstract:
+//
+//   Form definitions for exposing some of OVMF's platform knobs via HII.
+//
+// --*/
+
+#include <Guid/OvmfPlatformConfig.h>
+#include "Platform.h"
+
+formset
+  guid  = OVMF_PLATFORM_CONFIG_GUID,
+  title = STRING_TOKEN(STR_FORMSET_TITLE),
+  help  = STRING_TOKEN(STR_FORMSET_HELP),
+
+  varstore MAIN_FORM_STATE,
+    varid = FORMSTATEID_MAIN_FORM,
+    name  = MainFormState,
+    guid  = OVMF_PLATFORM_CONFIG_GUID;
+
+  form
+    formid = FORMID_MAIN_FORM,
+    title  = STRING_TOKEN(STR_MAIN_FORM_TITLE);
+
+    //
+    // Display the current preference in a read-only string field.
+    //
+    string
+      varid      = MainFormState.CurrentPreferredResolution,
+      questionid = QUESTION_RES_CUR,
+      prompt     = STRING_TOKEN(STR_RES_CUR),
+      help       = STRING_TOKEN(STR_RES_CUR_HELP),
+      flags      = READ_ONLY,
+      minsize    = 0,
+      maxsize    = MAXSIZE_RES_CUR,
+    endstring;
+
+    //
+    // We'll dynamically generate a one-of-many selection at this label.
+    //
+    label LABEL_RES_NEXT;
+
+    text
+      help  = STRING_TOKEN(STR_SAVE_EXIT),
+      text  = STRING_TOKEN(STR_SAVE_EXIT),
+      flags = INTERACTIVE,
+      key   = QUESTION_SAVE_EXIT;
+
+    text
+      help  = STRING_TOKEN(STR_DISCARD_EXIT),
+      text  = STRING_TOKEN(STR_DISCARD_EXIT),
+      flags = INTERACTIVE,
+      key   = QUESTION_DISCARD_EXIT;
+
+  endform;
+
+endformset;
diff --git a/TestPkg/PlatformDxe/SecondTestFile.h b/TestPkg/PlatformDxe/SecondTestFile.h
new file mode 100644
index 0000000000..a820cbabdd
--- /dev/null
+++ b/TestPkg/PlatformDxe/SecondTestFile.h
@@ -0,0 +1,9 @@
+/** @file
+Head file for front page.
+
+Copyright (c) 2004 - 2016, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define front_page_guid 0x9e0c30ab
\ No newline at end of file
diff --git a/TestPkg/PlatformDxe/ThirdTestFile.uni b/TestPkg/PlatformDxe/ThirdTestFile.uni
new file mode 100644
index 0000000000000000000000000000000000000000..dc37c295b4aa4118d4b9f60be9da2a4a28fda6c0
GIT binary patch
literal 950
zcmb`FTT22_6ouDw(0>^0r6jc^dWeWp3xqQ90=<cN83mnU9Hahx_3d+<v1pJUVwgE+
z_GPWL*Et`bs<@}9q5@rOs<{@LXkU9So~{Aet`f!MBZd5psj}*bH{pF|w<11e7qix=
zSg8%#ki3sBv;30Wgm^iZsSd`A-W^-08FhgUHPR7lRVO@W>`I%zQ=RLWeG>%<s0;Rn
z5QAY~<M;Z?WNye?g-znIO?6D4DT?*VcZ{w}Cg|uY)8`#%tDz^D@97><X){mwZ#qAW
zf9_l{qziCsxYi(F<*hp})|-yD(`5)r#*w;hr%`cHiyXK<bKQGxN&?4SQXl+41>M0n
zRP;6nz2G|YyQb8YsP4F~Ti8R;t!uWk&vbfTW3!t88+wM|jmi8S$rS8D`aOyFU<K#)
z_I1@`h5?>Fs>Qy^w~vYeH?BkMfwh<Mq<rbR^=8ckAzuFU(`K|A<j*tGnhNh~its;c
No{sM)l&2$B;R^uKhz9@w

literal 0
HcmV?d00001

diff --git a/TestPkg/Sec/Ia32/ForHAddTest.h b/TestPkg/Sec/Ia32/ForHAddTest.h
new file mode 100644
index 0000000000..7ddaa302cc
--- /dev/null
+++ b/TestPkg/Sec/Ia32/ForHAddTest.h
@@ -0,0 +1,9 @@
+/** @file
+  Exception definitions.
+
+  Copyright (c) 2010, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define NumForTest 4
\ No newline at end of file
diff --git a/TestPkg/Sec/Ia32/ForHAddTest.inc b/TestPkg/Sec/Ia32/ForHAddTest.inc
new file mode 100644
index 0000000000..ffa60e1cc4
--- /dev/null
+++ b/TestPkg/Sec/Ia32/ForHAddTest.inc
@@ -0,0 +1,9 @@
+/** @file
+  Exception definitions.
+
+  Copyright (c) 2010, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+NumForTest equ 4
\ No newline at end of file
diff --git a/TestPkg/Sec/Ia32/ForNASMIncludeH.h b/TestPkg/Sec/Ia32/ForNASMIncludeH.h
new file mode 100644
index 0000000000..1e3c91f038
--- /dev/null
+++ b/TestPkg/Sec/Ia32/ForNASMIncludeH.h
@@ -0,0 +1,10 @@
+/** @file
+  Platform specific defines for constructing ACPI tables
+
+  Copyright (c) 2012, 2013, Red Hat, Inc.
+  Copyright (c) 2008, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#define divnumber 4
diff --git a/TestPkg/TestIa32X64.fdf b/TestPkg/TestIa32X64.fdf
index 9c1cef54b0..71dfeccb9a 100644
--- a/TestPkg/TestIa32X64.fdf
+++ b/TestPkg/TestIa32X64.fdf
@@ -191,10 +191,11 @@ INF  UefiCpuPkg\CpuDxe\CpuDxe.inf
 #INF  MdeModulePkg/Universal/ReportStatusCodeRouter/RuntimeDxe/ReportStatusCodeRouterRuntimeDxe.inf
 #INF  MdeModulePkg/Universal/StatusCodeHandler/RuntimeDxe/StatusCodeHandlerRuntimeDxe.inf
 
 INF  MdeModulePkg/Logo/LogoDxe.inf
 INF  TestPkg\FakeLogo\JpegLogoDxe.inf
+INF  TestPkg/PlatformDxe/Platform.inf
 
 ################################################################################
 
 [FV.FVMAIN_COMPACT]
 FvNameGuid         = 48DB5E17-707C-472D-91CD-1613E7EF51B0
diff --git a/TestPkg/TestPkg32X64.dsc b/TestPkg/TestPkg32X64.dsc
index 8c881de93b..8fb88ac251 100644
--- a/TestPkg/TestPkg32X64.dsc
+++ b/TestPkg/TestPkg32X64.dsc
@@ -164,10 +164,11 @@
       NULL|TestPkg/Csm/LegacyBootMaintUiLib/LegacyBootMaintUiLib.inf
 !endif
   }
   FatPkg/EnhancedFatDxe/Fat.inf
   TestPkg/AcpiTables/AcpiTables.inf
+  TestPkg/PlatformDxe/Platform.inf
   MdeModulePkg\Universal\DevicePathDxe\DevicePathDxe.inf
 
 
 
 ################################################################################
-- 
2.29.1.windows.1

